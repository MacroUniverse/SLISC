//% types = {'Int'; 'Llong'; 'Long'; 'Doub'; 'Comp';};
//%----------------------------------------
//% T = varargin{:};
//% DiagT = ['Diag' T];
//% VecT = ['Vec' T];
//% if is_Long(T)
#ifdef SLS_USE_INT_AS_LONG
typedef DiagInt DiagLong;
#else
typedef DiagLlong DiagLong;
#endif
//% else
void veccpy(@T@ *, const @T@ *, Llong_I);

class @DiagT@ : public @VecT@
{
private:
    typedef @VecT@ Base;
public:
    @DiagT@(Long_I N);
    @DiagT@(@VecT@_I v);
    Long size() const;
    Long nnz() const;
    Long n1() const;
    Long n2() const;
    @T@ &ref(Long_I i, Long_I j);
    const @T@ operator()(Long_I i, Long_I j) const;
};

@DiagT@::@DiagT@(Long_I N) : Base(N) {}

@DiagT@::@DiagT@(@VecT@_I v) : Base(v.size())
{
    veccpy(m_p, v.ptr(), m_N);
}

Long @DiagT@::size() const
{
    SLS_ERR("use nnz() instead!");
    return 0;
}

Long @DiagT@::nnz() const
{
    return Base::size();
}

Long @DiagT@::n1() const
{
    return Base::size();
}

Long @DiagT@::n2() const
{
    return Base::size();
}

@T@ &@DiagT@::ref(Long_I i, Long_I j)
{
    if (i == j)
        return (*this)[i];
    SLS_ERR("not a diagonal element!");
    return (*this)[i];
}

const @T@ @DiagT@::operator()(Long_I i, Long_I j) const
{
    if (i == j) return (*this)[i];
    return 0;
}

// convert vector to diagonal matrix
const @DiagT@ &diag(@VecT@_I v)
{
    return (@DiagT@&)v;
}
//% end

typedef const @DiagT@ & @DiagT@_I;
typedef @DiagT@ & @DiagT@_O, & @DiagT@_IO;
