//% types = {'Llong'; 'Doub'; 'Comp';};
//%----------------------------------------
//% T = varargin{:};
//% DcmatT = ['Dcmat' T];
class @DcmatT@
{
private:
    @T@ *m_p;
    Long m_N;
    Long m_Nr, m_Nc;
    Long m_lda; // leading dimension (here is m_Nr of host matrix)
public:
    typedef @T@ value_type;
    @DcmatT@();
    @DcmatT@(const @T@ *ptr, Long_I Nr, Long_I Nc, Long_I lda);
    void set(const @T@ *ptr, Long_I Nr, Long_I Nc, Long_I lda);

    // === Cmat member functions ===
    @T@& operator[](Long_I i);    // single indexing (inefficient)
    const @T@& operator[](Long_I i) const;
    @T@& operator()(Long_I i);    // same as operator[]
    const @T@& operator()(Long_I i) const;
    @T@& operator()(Long_I i, Long_I j);    // double indexing
    const @T@& operator()(Long_I i, Long_I j) const;
    Long n1() const;
    Long n2() const;
    Long lda() const;
    Long size() const;
    const @T@ *ptr() const;
    @T@ *ptr();
};

inline @DcmatT@::@DcmatT@() {}

inline @DcmatT@::@DcmatT@(const @T@ *ptr, Long_I Nr, Long_I Nc, Long_I lda)
    : m_p((@T@ *)ptr), m_Nr(Nr), m_Nc(Nc), m_N(Nr*Nc), m_lda(lda)
{}

inline void @DcmatT@::set(const @T@ *ptr, Long_I Nr, Long_I Nc, Long_I lda)
{
    m_p = (@T@ *)ptr; m_Nr = Nr; m_Nc = Nc; m_N = Nr * Nc; m_lda = lda;
}

inline @T@ & @DcmatT@::operator[](Long_I i)
{
#ifdef SLS_CHECK_BOUNDS
    if (i < 0 || i >= m_N)
        SLS_ERR("Matrix subscript out of bounds");
#endif
    return m_p[i % m_Nc + m_lda * i/m_Nc];
}

inline const @T@ & @DcmatT@::operator[](Long_I i) const
{
#ifdef SLS_CHECK_BOUNDS
    if (i < 0 || i >= m_N)
        SLS_ERR("Matrix subscript out of bounds");
#endif
    return m_p[i % m_Nc + m_lda * i / m_Nc];
}

inline @T@ & @DcmatT@::operator()(Long_I i)
{
    return operator[](i);
}

inline const @T@ & @DcmatT@::operator()(Long_I i) const
{
    return operator[](i);
}

inline @T@ & @DcmatT@::operator()(Long_I i, Long_I j)
{
#ifdef SLS_CHECK_BOUNDS
    if (i < 0 || i >= m_Nr || j < 0 || j >= m_Nc)
        SLS_ERR("Matrix subscript out of bounds");
#endif
    return m_p[i + m_lda * j];
}

inline const @T@ & @DcmatT@::operator()(Long_I i, Long_I j) const
{
#ifdef SLS_CHECK_BOUNDS
    if (i < 0 || i >= m_Nr || j < 0 || j >= m_Nc)
        SLS_ERR("Matrix subscript out of bounds");
#endif
    return m_p[i + m_lda * j];
}

inline Long @DcmatT@::n1() const
{
    return m_Nr;
}

inline Long @DcmatT@::n2() const
{
    return m_Nc;
}

inline Long @DcmatT@::lda() const
{
    return m_lda;
}

inline Long @DcmatT@::size() const
{
    return m_N;
}

inline const @T@ * @DcmatT@::ptr() const
{
    return m_p;
}

inline @T@ * @DcmatT@::ptr()
{
    return m_p;
}

//% if is_Long(T)
#ifdef SLS_USE_INT_AS_LONG
typedef DcmatInt DcmatLong;
#else
typedef DcmatLlong DcmatLong;
#endif
//% else
typedef const @DcmatT@ & @DcmatT@_I;
typedef @DcmatT@ & @DcmatT@_O, & @DcmatT@_IO;
//% end
