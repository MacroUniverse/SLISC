//% types = {'Char'; 'Int'; 'Llong'; 'Doub'; 'Comp';
//%         'VecChar'; 'VecInt'; 'VecDoub'; 'VecComp';
//%         'MatInt'; 'MatLlong'; 'MatDoub'; 'MatComp';
//%         'CmatInt'; 'CmatLlong'; 'CmatDoub'; 'CmatComp';
//% };
//%---------------------
//% T = varargin{:};
//% Ts = contain_type(T);
//% numTs = num2str(type_num(Ts));
//% if ~(is_Char(Ts) || is_Int(Ts) || is_Llong(Ts) || is_Doub(Ts) || is_Comp(Ts))
//%     error('not implemented!');
//% end
//% if is_scalar(T)
inline Int load(@T@_O s, Str_I varname, Matt_IO matt)
{
    Long i;
    ifstream &fin = matt.m_in;
    i = matt.search(varname);
    if (i < 0)
        return -1;
    fin.seekg(matt.m_ind[i]);

    if (@numTs@ < matt.m_type[i])
        SLS_ERR("wrong type!");
    if (matt.m_size[i].size() != 0)
        SLS_ERR("wrong dimension!");

    matt_read_scalar(s, fin);
    return 0;
}
//% elseif is_Vec(T) == 1
inline Int load(@T@_O v, Str_I varname, Matt_IO matt)
{
    ifstream &fin = matt.m_in;
    Long i = matt.search(varname);
    if (i < 0)
        return -1;
    fin.seekg(matt.m_ind[i]);

    if (@numTs@ < matt.m_type[i])
        SLS_ERR("wrong type!");
    if (matt.m_size[i].size() != 1)
        SLS_ERR("wrong dimension!");

    Long n = matt.m_size[i][0]; v.resize(n);
    // read var data
    for (Long i = 0; i < n; ++i)
		matt_read_scalar(v[i], fin);
    return 0;
}
//% elseif is_Mat(T) || is_Cmat(T)
inline Int load(@T@_O a, Str_I varname, Matt_IO matt)
{
    Long i, j, m, n;
    ifstream &fin = matt.m_in;
    i = matt.search(varname);
    if (i < 0)
        return -1;
    fin.seekg(matt.m_ind[i]);

    if (@numTs@ < matt.m_type[i])
        SLS_ERR("wrong type!");
    if (matt.m_size[i].size() != 2)
        SLS_ERR("wrong dimension!");

    m = matt.m_size[i][0]; n = matt.m_size[i][1]; a.resize(m, n);
    // read var data
    for (j = 0; j < n; ++j)
        for (i = 0; i < m; ++i)
			matt_read_scalar(a(i, j), fin);
    return 0;
}
//% elseif is_Mat3(T) || is_Cmat3(T)
inline Int load(@T@_O a, Str_I varname, Matt_IO matt)
{
    Long i, j, k, m, n, q;
    ifstream &fin = matt.m_in;
    i = matt.search(varname);
    if (i < 0)
        return -1;
    fin.seekg(matt.m_ind[i]);

    if (@numTs@ < matt.m_type[i])
        SLS_ERR("wrong type!");
    if (matt.m_size[i].size() != 3)
        SLS_ERR("wrong dimension!");
    
    m = matt.m_size[i][0]; n = matt.m_size[i][1]; q = matt.m_size[i][2];
    a.resize(m, n, q);
    // read var data
    for (k = 0; k < q; ++k)
        for (j = 0; j < n; ++j)
            for (i = 0; i < m; ++i)
                matt_read_scalar(a(i, j, k), fin);
    return 0;
}
//% else
//%     disp(T); error('not implemented!');
//% end

//% % read one var from one file
inline void load(@T@_O var, Str_I varname, Str_I matt_file)
{
    Matt matt(matt_file, "r");
    load(var, varname, matt);
    matt.close();
}
