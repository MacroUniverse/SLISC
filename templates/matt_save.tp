//% types = {'Char'; 'Int'; 'Llong'; 'Doub'; 'Comp';
//%         'VecChar'; 'VecInt'; 'VecDoub'; 'VecComp';
//%         'SvecChar'; 'SvecInt'; 'SvecLlong'; 'SvecDoub'; 'SvecComp';
//%         'MatInt'; 'MatLlong'; 'MatDoub'; 'MatComp';
//%         'CmatInt'; 'CmatLlong'; 'CmatDoub'; 'CmatComp';
//%         'Cmat3Int'; 'Cmat3Llong'; 'Cmat3Doub'; 'Cmat3Comp';
//%         'ScmatInt'; 'ScmatLlong'; 'ScmatDoub'; 'ScmatComp';
//%         'DcmatInt'; 'DcmatLlong'; 'DcmatDoub'; 'DcmatComp';
//% };
//%---------------------
//% T = varargin{:};
//% Ts = contain_type(T);
//% numTs = num2str(type_num(Ts));
//% if is_Char(T) || is_Int(T) || is_Llong(T) || is_Doub(T) || is_Comp(T)
inline void save(@T@_I s, Str_I varname, Matt_IO matt)
{
    ofstream &fout = matt.m_out;
    if (!fout.is_open())
        SLS_ERR("matt file not open: " + matt.fname);
    ++matt.m_n; matt.m_ind.push_back(fout.tellp());
    // write variable name info
    Long n = varname.size();
    fout << n << Matt::dlm;
    for (Long i = 0; i < n; ++i) {
        fout << to_num(varname.at(i)) << Matt::dlm;
    }
    // write data type info
    fout << @numTs@ << Matt::dlm;
    // write dimension info
    fout << 0 << Matt::dlm;
    // write matrix data
	matt_write_scalar(s, fout);
}
//% elseif ndim(T) == 1 && is_scalar(Ts)
inline void save(@T@_I v, Str_I varname, Matt_IO matt)
{
    ofstream &fout = matt.m_out;
    if (!fout.is_open())
        SLS_ERR("matt file not open!");
    ++matt.m_n; matt.m_ind.push_back(fout.tellp());
    // write variable name info
    Long n = varname.size();
    fout << n << Matt::dlm;
    for (Long i = 0; i < n; ++i) {
        fout << to_num(varname.at(i)) << Matt::dlm;
    }
    // write data type info
    fout << @numTs@ << Matt::dlm;
    // write dimension info
    n = v.size();
    fout << 1 << Matt::dlm << n << Matt::dlm;
    // write matrix data
    for (Long i = 0; i < n; ++i)
		matt_write_scalar(v[i], fout);
}
//% elseif ndim(T) == 2
inline void save(@T@_I a, Str_I varname, Matt_IO matt)
{
    Long N1 = a.n1(), N2 = a.n2();
    ofstream &fout = matt.m_out;
    if (!fout.is_open())
        SLS_ERR("matt file not open!");
    ++matt.m_n; matt.m_ind.push_back(fout.tellp());
    // write variable name info
    Long n = varname.size();
    fout << n << Matt::dlm;
    for (Long i = 0; i < n; ++i)
        fout << to_num(varname.at(i)) << Matt::dlm;
    // write data type info
    fout << @numTs@ << Matt::dlm;
    // write dimension info
    fout << 2 << Matt::dlm << N1 << Matt::dlm << N2 << Matt::dlm;
    // write matrix data
    for (Long j = 0; j < N2; ++j)
        for (Long i = 0; i < N1; ++i)
            matt_write_scalar(a(i, j), fout);
}
//% elseif is_Cmat3(T) || is_Mat3(T)
inline void save(@T@_I a, Str_I varname, Matt_IO matt)
{
    Long i, j, k, N1 = a.n1(), N2 = a.n2(), N3 = a.n3();
    ofstream &fout = matt.m_out;
    if (!fout.is_open())
        SLS_ERR("matt file not open!");
    ++matt.m_n; matt.m_ind.push_back(fout.tellp());
    // write variable name info
    Long n = varname.size();
    fout << n << Matt::dlm;
    for (i = 0; i < n; ++i) {
        fout << to_num(varname.at(i)) << Matt::dlm;
    }
    // write data type info
    fout << @numTs@ << Matt::dlm;
    // write dimension info
    fout << 3 << Matt::dlm << N1 << Matt::dlm << N2 << Matt::dlm << N3 << Matt::dlm;
    // write matrix data
    for (k = 0; k < N3; ++k)
    	for (j = 0; j < N2; ++j)
    		for (i = 0; i < N1; ++i)
        		matt_write_scalar(a(i, j, k), fout);
}
//% elseif is_Str(T)
inline void save(Str_I str, Str_I varname, Matt_IO matt)
{
    SvecChar_c sli; sli.set(str.data(), str.size());
    save(sli, varname, matt);
}
//% else
//%     disp(T);
//%     error('not implemented!');
//% end

//% % save one var to one file (replace old file)
inline void save(@T@_I s, Str_I varname, Str_I matt_file)
{
    Matt matt(matt_file, "w");
    save(s, varname, matt);
    matt.close();
}
