//% types = {
//%     'VecChar', 'Char';
//%     'VecInt', 'Int';
//%     'VecDoub', 'Doub';
//%     'VecComp', 'Comp';
//%     'CmatChar', 'Char';
//%     'CmatInt', 'Int';
//%     'CmatDoub', 'Doub';
//%     'CmatComp', 'Comp';
//%     };
//%-------------------
//% [T, Ts] = varargin{:};
//% if is_dense(T) && is_scalar(Ts)
inline void operator+=(@T@_IO v, @Ts@_I s)
{
    plus_equals_vs(v.ptr(), s, v.size());
}

inline void operator-=(@T@_IO v, @Ts@_I s)
{
    minus_equals_vs(v.ptr(), s, v.size());
}

inline void operator*=(@T@_IO v, @Ts@_I s)
{
    times_equals_vs(v.ptr(), s, v.size());
}

inline void operator/=(@T@_IO v, @Ts@_I s)
{
    divide_equals_vs(v.ptr(), s, v.size());
}
//% elseif is_Dvec(T) && is_scalar(Ts)
inline void operator*=(@T@_IO v, @Ts@_I s)
{
    times_equals_vs(v.ptr(), s, v.size(), v.step());
}

inline void operator/=(@T@_IO v, @Ts@_I s)
{
    divide_equals_vs(v.ptr(), s, v.size(), v.step());
}
//% else
//%     disp(T); disp(Ts);
//%     error('not implemented');
//% end
