//% T = varargin{:};
//% McoohT = ['Mcooh' T];
//% McooT = ['Mcoo' T];
class @McoohT@ : public @McooT@
{
private:
    typedef @McooT@ Base;
    // @McoohT@() : Base() {} // default constructor : uninitialized
public:
    @McoohT@(Long_I Nr, Long_I Nc);
    @McoohT@(Long_I Nr, Long_I Nc, Long_I Nnz);
    using Base::operator();
    @T@ &ref(Long_I i, Long_I j); // reference to an element
    const @T@ operator()(Long_I i, Long_I j) const; // double indexing (element need not exist)
    void push(@T@_I s, Long_I i, Long_I j); // add one nonzero element
    void set(@T@_I s, Long_I i, Long_I j); // change existing element or push new element
    void reshape(Long_I Nr, Long_I Nc); // change matrix shape
};

@McoohT@::@McoohT@(Long_I Nr, Long_I Nc) : Base(Nr, Nc)
{
#ifdef SLS_CHECK_SHAPE
    if (Nr != Nc) SLS_ERR("must be square matrix!");
#endif
}

@McoohT@::@McoohT@(Long_I Nr, Long_I Nc, Long_I Nnz) : Base(Nr, Nc, Nnz)
{
#ifdef SLS_CHECK_SHAPE
    if (Nr != Nc) SLS_ERR("must be square matrix!");
#endif
}

// cannot return a const reference since conj() might create a temporary
const @T@ @McoohT@::operator()(Long_I i, Long_I j) const
{
    if (i > j) {
        return CONJ(Base::operator()(j, i));
    }
    return Base::operator()(i, j);
}

@T@ &@McoohT@::ref(Long_I i, Long_I j)
{
    if (i > j) {
        SLS_ERR("lower triangle is empty!");
        return Base::ref(j, i);
    }
    else
        return Base::ref(i, j);
}

void @McoohT@::push(@T@_I s, Long_I i, Long_I j)
{
    if (i > j)
        Base::push(CONJ(s), j, i);
    else
        Base::push(s, i, j);
}

void @McoohT@::set(@T@_I s, Long_I i, Long_I j)
{
    if (i > j)
        Base::set(s, j, i);
    else
        Base::set(s, i, j);
}

void @McoohT@::reshape(Long_I Nr, Long_I Nc)
{
#ifdef SLS_CHECK_SHAPE
    if (Nr != Nc) SLS_ERR("must be a square matrix!");
#endif
    Base::reshape(Nr, Nc);
}
