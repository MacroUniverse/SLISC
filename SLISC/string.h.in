// string utilities

#pragma once
#include "global.h"

namespace slisc {

// string utilities

// see if a string match the first part of another string
//% types = {
//%     'Str'; 'Str32';
//% };
//%------------------------
//% T = varargin{:};
inline Bool match_head(@T@_I str_short, @T@_I str_long)
{
    if (str_short.size() > str_long.size())
        return false;
    return str_long.substr(0, str_short.size()) == str_short;
}
//%------------------------

//% types = {'Char'; 'Int'; 'Llong'; 'Doub';};
//%---------------------
//% T = varargin{:};
inline void num2str(Str_O str, @T@_I s, Long_I min_len = -1)
{
    str = to_string(s);
    // erase trailing zeros
    if (str.find('.') != Str::npos)
        str.erase(str.find_last_not_of('0') + 1);
    // 0 padding on the left
    if (min_len > 0 && (Long)str.size() < min_len) {
        Str str1;
        for (Long i = 0; i < min_len - (Long)str.size(); ++i)
            str1 += '0';
        str = str1 + str;
    }
}

inline Str num2str(@T@_I s, Long_I min_len = -1)
{
    Str str;
    num2str(str, s, min_len);
    return str;
}
//%------------------------

// trim all occurance of key on the left
// return the number of charaters trimed
// e.g. key = "\n " to trim space and '\n'
inline Long trimL(Str_IO str, Str_I key = " ")
{
    Long N;
    Long ind = str.find_first_not_of(key);
    if (ind < 0) {
        N = str.size();
        str.clear();
        return N;
    }
    N = ind;
    str.erase(0, N);
    return N;
}

// trim all occurance of key on the right
// return the number of charaters trimed
// e.g. key = "\n " to trim space and '\n'
inline Long trimR(Str_IO str, Str_I key = " ")
{
    Long N;
    Long ind = str.find_last_not_of(key);
    if (ind < 0) {
        N = str.size();
        str.clear();
        return N;
    }
    str.erase(ind + 1);
    N = str.size() - ind;
    return N;
}

// get a line starting from ind0
inline Str getline(Str_I str, Long_I start = 0)
{
    Long ind = str.find('\n', start);
    if (ind < 0)
        return str.substr(start);
    return str.substr(start, ind - start);
}

inline Str32 getline(Str32_I str, Long_I start = 0)
{
    Long ind = str.find('\n', start);
    if (ind < 0)
        return str.substr(start);
    return str.substr(start, ind - start);
}

// trim both sides
// e.g. key = "\n " to trim space and '\n'
inline Long trim(Str_IO str, Str_I key = " ")
{
    return trimL(str, key) + trimR(str, key);
}

// replace every "\r\n" with "\n"
inline Long CRLF_to_LF(Str_IO str)
{
    Long ind0{}, N{};
    while (true) {
        ind0 = str.find("\r\n", ind0);
        if (ind0 < 0) return N;
        str.erase(ind0, 1);
    }
}

// convert string to lower case
//% types = {'Str'; 'Str32'};
//%----------------------------
//% T = varargin{:}; Ts = value_type(T);
inline void to_lower(@T@_O str)
{
    @Ts@ C, diff = 'a' - 'A';
    Long N = str.size();
    for (Long i = 0; i < N; ++i) {
        C = str[i];
        if (C >= 'A' && C <= 'Z')
            str[i] = C + diff;
        else
            str[i] = C;
    }
}
//%----------------------------

// convert string to lower case
//% types = {'Str'; 'Str32'};
//%----------------------------
//% T = varargin{:}; Ts = value_type(T);
inline void to_lower(@T@_O str, @T@_I STR)
{
    @Ts@ C, diff = 'a' - 'A';
    Long N = STR.size();
    str.resize(N);
    for (Long i = 0; i < N; ++i) {
        C = STR[i];
        if (C >= 'A' && C <= 'Z')
            str[i] = C + diff;
        else
            str[i] = C;
    }
}
//%----------------------------

// convert string to lower case
//% types = {'Str'; 'Str32'};
//%----------------------------
//% T = varargin{:}; Ts = value_type(T);
inline void to_upper(@T@_O STR, @T@_I str)
{
    @Ts@ c, diff = 'A' - 'a';
    Long N = str.size();
    STR.resize(N);
    for (Long i = 0; i < N; ++i) {
        c = str[i];
        if (c >= 'a' && c <= 'z')
            STR[i] = c + diff;
        else
            STR[i] = c;
    }
}
//%----------------------------

// convert string to lower case
//% types = {'Str'; 'Str32'};
//%----------------------------
//% T = varargin{:}; Ts = value_type(T);
inline void to_upper(@T@_IO str)
{
    @Ts@ c, diff = 'A' - 'a';
    Long N = str.size();
    for (Long i = 0; i < N; ++i) {
        c = str[i];
        if (c >= 'a' && c <= 'z')
            str[i] = c + diff;
        else
            str[i] = c;
    }
}
//%----------------------------

//% types = {'vecStr'; 'vecStr32'};
//%----------------------------
//% T = varargin{:};
inline void to_lower(@T@_O vs, @T@_I VS)
{
    Long N = VS.size();
    vs.resize(N);
    for (Long i = 0; i < N; ++i)
        to_lower(vs[i], VS[i]);
}
//%-----------------------------

//% types = {'vecStr'; 'vecStr32'};
//%----------------------------
//% T = varargin{:};
inline void to_lower(@T@_IO vs)
{
    Long N = vs.size();
    for (Long i = 0; i < N; ++i)
        to_lower(vs[i]);
}
//%-----------------------------

//% types = {'vecStr'; 'vecStr32'};
//%----------------------------
//% T = varargin{:};
inline void to_upper(@T@_O VS, @T@_I vs)
{
    Long N = vs.size();
    VS.resize(N);
    for (Long i = 0; i < N; ++i)
        to_upper(VS[i], vs[i]);
}
//%-----------------------------

//% types = {'vecStr'; 'vecStr32'};
//%----------------------------
//% T = varargin{:};
inline void to_upper(@T@_IO vs)
{
    Long N = vs.size();
    vs.resize(N);
    for (Long i = 0; i < N; ++i)
        to_upper(vs[i]);
}
//%-----------------------------

} // namespace slisc
