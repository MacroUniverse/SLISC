// copy data from one container to another
// includes container shape checking
// all `container = container` should be implemented using copy
#pragma once
#include "compare.h"
#include "slice_arith.h"

namespace slisc {
//  === pointer interface ===

//% types = {
//%     'Char'; 'Int'; 'Llong'; 'Float'; 'Doub'; 'Comp';
//%     };
//%-----------------------
//% T = varargin{:};
inline void vecset(@T@ *v, @T@_I val, Long_I n)
{
    for (@T@ *p = v; p < v + n; ++p)
        *p = val;
}

inline void vecset(@T@ *v, @T@_I val, Long_I n, Long_I step)
{
    for (@T@ *p = v; p < v + n*step; p += step)
        *p = val;
}
//%------------------------

//% types = {
//%     'Char', 'Char';
//%     'Int', 'Int';
//%     'Llong', 'Llong';
//%     'Doub', 'Llong';
//%     'Float', 'Float';
//%     'Doub', 'Float';
//%     'Doub', 'Doub';
//%     'Comp', 'Doub';
//%     'Comp', 'Llong';
//%     'Comp', 'Comp';
//%     };
//%----------------------------
//% [T, T1] = varargin{:};
//% if ~is_promo(T, T1)
//%     error('illegal types!');
//% end
inline void veccpy(@T@ *v, const @T1@ *v1, Long_I n)
{
    for (Long i = 0; i < n; ++i)
        v[i] = v1[i];
}

inline void veccpy(@T@ *v, const @T1@ *v1, Long_I step1, Long_I n)
{
    for (@T@ *p = v; p < v + n; ++p) {
        *p = *v1;
        v1 += step1;
    }
}

inline void veccpy(@T@ *v, Long_I step, const @T1@ *v1, Long_I n)
{
    for (@T@ *p = v; p < v + n*step; p += step) {
        *p = *v1;
        ++v1;
    }
}

inline void veccpy(@T@ *v, Long_I step, const @T1@ *v1, Long_I step1, Long_I n)
{
    @T@ *end = v + n * step;
    for (; v < end; v += step) {
        *v = *v1;
        v1 += step1;
    }
}
//%------------------------

//% types = {
//%     'Int', 'Int';
//%     'Llong', 'Llong';
//%     'Doub', 'Doub';
//%     'Comp', 'Comp';
//%     };
//%--------------------------
//% [T, T1] = varargin{:};
//% if ~is_promo(T, T1);
//%     error('illegal types!');
//% end
inline void matcpy(@T@ *v, Long_I lda, const @T1@ *v1, Long_I lda1, Long_I Nld, Long_I Nsd)
{
    for (Long j = 0; j < Nsd; ++j) {
        veccpy(v, v1, Nld);
        v += lda; v1 += lda1;
    }
}
//%------------------------

//% types = {
//%     'Llong', 'Llong';
//%     'Doub', 'Doub';
//%     'Comp', 'Comp';
//%     };
//%----------------------------
//% [T, T1] = varargin{:};
//% if ~is_promo(T, T1);
//%     error('illegal types!');
//% end
inline void matcpy_diff_major(@T@ *a2, const @T1@ *a1, Long_I N2, Long_I N1)
{
    for (Long i2 = 0; i2 < N2; ++i2) {
        Long start = N1 * i2, k2 = i2;
        for (Long k1 = start; k1 < start + N1; ++k1) {
            a2[k2] = a1[k1];
            k2 += N2;
        }
    }
}

inline void matcpy_diff_major(@T@ *a2, const @T1@ *a1, Long_I N2, Long_I lda2, Long_I N1, Long_I lda1)
{
    for (Long i2 = 0; i2 < N2; ++i2) {
        Long start = lda1 * i2, k2 = i2;
        for (Long k1 = start; k1 < start + N1; ++k1) {
            a2[k2] = a1[k1];
            k2 += lda2;
        }
    }
}
//%------------------------

// copy dense matrix with different majors
// lda1 is leading dimension of a1, lda2 is leading dimension of a2
// if a1 is row major and a2 is column major, N1 is number of columns, N2 is number of rows
// if a1 is column major and a2 is row major, N1 is number of rows, N2 is number of columns
// #include "matcpy_diff_major.inl"

// === container interface ===
// must use pointer version

// scalar to container
//% types = {
//%     'VecInt'; 'VecLlong'; 'VecDoub';
//%     'VecComp'; 'SvecLlong'; 'SvecDoub';
//%     'SvecComp'; 'MatInt'; 'MatDoub';
//%     'DvecDoub'; 'DvecComp';
//%     'MatComp'; 'Mat3Doub'; 'CmatInt';
//%     'CmatLlong'; 'CmatDoub'; 'CmatComp';
//%     'Cmat3Int';
//%     'Cmat3Doub'; 'Cmat3Comp'; 'Cmat4Doub';
//%     'DcmatDoub'; 'DcmatComp';
//%     'Jcmat3Doub'; 'Jcmat3Comp';
//% };
//%-------------------------------------
//% T = varargin{:}; Ts = contain_type(T);
inline void copy(@T@_O v, @Ts@_I s)
{
//% if is_dense(T)
    vecset(v.ptr(), s, v.size());
//% elseif is_Dvec(T)
    vecset(v.ptr(), s, v.size(), v.step());
//% elseif is_Dcmat(T)
    Long N1 = v.n1(), N2 = v.n2();
    for (Long j = 0; j < N2; ++j)
        vecset(&v(0, j), s, N1);
//% elseif is_Dmat(T)
    Long N1 = v.n1(), N2 = v.n2();
    for (Long i = 0; i < N1; ++i)
        vecset(&v(i, 0), s, N2);
//% elseif ndim(T) == 3
    // slow
    if (v.size() != 0)
    for (Long k = 0; k < v.n3(); ++k)
        for (Long j = 0; j < v.n2(); ++j)
            for (Long i = 0; i < v.n1(); ++i)
                v(i, j, k) = s;
//% else
//%     error('not implemented!');
//% end
}
//%------------------------

// container to container
//% types = {
//%     'VecChar', 'VecChar';
//%     'VecInt', 'VecInt';
//%     'VecInt', 'SvecInt';
//%     'VecInt', 'DvecInt';
//%     'VecLlong', 'VecLlong';
//%     'VecDoub', 'VecDoub';
//%     'VecDoub', 'SvecDoub';
//%     'VecComp', 'VecComp';
//%     'MatLlong', 'MatLlong';
//%     'MatDoub', 'MatDoub';
//%     'MatComp', 'MatComp';
//%     'CmatLlong', 'CmatLlong';
//%     'CmatDoub', 'CmatDoub';
//%     'CmatDoub', 'ScmatDoub';
//%     'CmatDoub', 'DcmatDoub';
//%     'CmatComp', 'CmatComp';
//%     'CmatComp', 'ScmatComp';
//%     'CmatComp', 'DcmatComp';
//%     'MatDoub', 'CmatDoub';
//%     'CmatDoub', 'MatDoub';
//%     'Cmat3Int', 'Cmat3Int';
//%     'Cmat3Doub', 'Cmat3Doub';
//%     'Cmat3Comp', 'Cmat3Doub';
//%     'Cmat3Comp', 'Cmat3Comp';
//%     'DvecInt', 'DvecInt';
//%     'DvecLlong', 'DvecLlong';
//%     'DvecDoub', 'DvecDoub';
//%     'VecComp', 'DvecComp';
//%     'SvecComp', 'SvecComp';
//%     'SvecComp', 'DvecComp';
//%     'DvecComp', 'SvecComp';
//%     'ScmatInt', 'ScmatInt';
//%     'ScmatLlong', 'ScmatLlong';
//%     'ScmatDoub', 'CmatDoub';
//%     'ScmatDoub', 'ScmatDoub';
//%     'ScmatComp', 'CmatComp';
//%     'ScmatComp', 'ScmatComp';
//%     'DcmatInt', 'CmatInt';
//%     'DcmatInt', 'DcmatInt';
//%     'DcmatLlong', 'DcmatLlong';
//%     'DcmatDoub', 'CmatDoub';
//%     'DcmatDoub', 'DcmatDoub';
//%     'DcmatComp', 'CmatComp';
//%     'DcmatComp', 'DcmatComp';
//%     'Jcmat3Doub', 'Jcmat3Doub';
//%     'Jcmat3Comp', 'Jcmat3Comp';
//% };
//%---------------------------
//% [T, T1] = varargin{:};
//% if ~is_promo(contain_type(T), contain_type(T1))
//%     error('illegal types');
//% end
inline void copy(@T@_O v, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong shape!");
#endif
    if (v.size() == 0)
        return;
//% if is_dense(T) && is_dense(T1) && is_same_major(T, T1)
    veccpy(v.ptr(), v1.ptr(), v.size());
//% elseif is_Dvec(T) && is_Dvec(T1)
    veccpy(v.ptr(), v.step(), v1.ptr(), v1.step(), v.size());
//% elseif is_dense_vec(T) && is_Dvec(T1)
    veccpy(v.ptr(), v1.ptr(), v1.step(), v1.size());
//% elseif is_Dvec(T) && is_dense_vec(T1)
    veccpy(v.ptr(), v.step(), v1.ptr(), v1.size());
//% elseif is_dense_mat(T) && is_dense_mat(T1) && is_diff_major(T, T1)
//%     if is_cmajor(T)
    matcpy_diff_major(v.ptr(), v1.ptr(), v.n1(), v.n2());
//%     else
    matcpy_diff_major(v.ptr(), v1.ptr(), v.n2(), v.n1());
//%     end
//% elseif is_Dcmat(T) && is_Dcmat(T1)
    matcpy(v.ptr(), v.lda(), v1.ptr(), v1.lda(), v.n1(), v.n2());
//% elseif is_Dmat(T) && is_Dmat(T1)
    matcpy(v.ptr(), v.lda(), v1.ptr(), v1.lda(), v.n2(), v.n1());
//% elseif is_Cmat(T) && is_Dcmat(T1)
    matcpy(v.ptr(), v.n1(), v1.ptr(), v1.lda(), v.n1(), v.n2());
//% elseif is_Dcmat(T) && is_Cmat(T1)
    matcpy(v.ptr(), v.lda(), v1.ptr(), v.n1(), v.n1(), v.n2());
//% elseif ndim(T) == 3 && ndim(T1) == 3
    // slow
    if (v1.size() != 0)
    for (Long k = 0; k < v.n3(); ++k)
        for (Long j = 0; j < v.n2(); ++j)
            for (Long i = 0; i < v.n1(); ++i)
                v(i, j, k) = v1(i, j, k);
//% else
//%     disp(['T = ', T]);
//%     disp(['T1 = ', T1]);
//%     error('not implemented!!');
//% end
}
//%------------------------

// for sparse containers
//% types = {
//%     'Doub', 'Doub';
//%     'Comp', 'Comp';
//% };
//%----------------------------
//% [T, T1] = varargin{:};
//% McooT = ['Mcoo', T]; McooT1 = ['Mcoo', T1];
inline void copy(@McooT@_O v, @McooT1@_I v1)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong shape!");
    if (v.capacity() < v1.nnz())
        SLS_ERR("not enough capacity!");
#endif
    if (v1.nnz() == 0)
        return;
//% if is_same(T, T1)
    if (v.ptr() == v1.ptr())
        SLS_ERR("self assignment is forbidden!");
//% end
    Long Nnz = v1.nnz();
    v.resize(Nnz);
    veccpy(v.ptr(), v1.ptr(), Nnz);
    veccpy(v.row_ptr(), v1.row_ptr(), Nnz);
    veccpy(v.col_ptr(), v1.col_ptr(), Nnz);
}
//%------------------------

//% types = {
//%     'CmatDoub', 'Doub';
//%     'CmatComp', 'Comp';
//% };
//%----------------------------
//% [Tmat, Ts] = varargin{:};
//% if ~((is_dense_mat(Tmat) || is_Dmat(Tmat) || is_Jmat(Tmat)) && is_scalar(Ts))
//%     error('illegal types');
//% end
//% McooTs = ['Mcoo', Ts]; McoohTs = ['Mcooh', Ts];
inline void copy(@Tmat@_O lhs, @McooTs@_I rhs)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(lhs, rhs))
        SLS_ERR("wrong shape!");
#endif
    copy(lhs, 0);
    for (Long i = 0; i < rhs.nnz(); ++i) {
        lhs(rhs.row(i), rhs.col(i)) = rhs[i];
    }
}
//%-------------------

//% types = {
//%     'CmobdInt', 'CmobdInt';
//%     'CmobdDoub', 'CmobdDoub';
//%     'CmobdComp', 'CmobdDoub';
//% };
//%-----------------------
//% [T, T1] = varargin{:};
inline void copy(@T@_O lhs, @T1@_I rhs)
{
    copy(lhs.cmat3(), rhs.cmat3());
}
//%-------------------

//% types = {
//%     'CmobdInt', 'Cmat3Int';
//%     'CmobdDoub', 'Cmat3Doub';
//% };
//%-----------------------
//% [T, T1] = varargin{:};
inline void copy(@T@_O lhs, @T1@_I rhs)
{
    copy(lhs.cmat3(), rhs);
    Long step = sqr(lhs.n0());
    vecset(lhs.ptr() + step - 1, 0, lhs.nblk() - 1, step);
}
//%--------------------

//% types = {
//%     'CmobdInt', 'McooInt';
//%     'CmobdDoub', 'McooDoub';
//% };
//%-----------------------
//% [T, T1] = varargin{:};
inline void copy(@T@_O lhs, @T1@_I rhs)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(lhs, rhs))
        SLS_ERR("wrong shape!");
#endif
    auto & c3 = lhs.cmat3();
    copy(c3, 0);
    for (Long k = 0; k < rhs.nnz(); ++k) {
        Long i = rhs.row(k) + 1, j = rhs.col(k) + 1;
        Long N = lhs.n0() - 1, Nblk = lhs.nblk();
        Long iblk = i / N, jblk = j / N;
        Long m = i % N;
        if (iblk == jblk) {
            if (iblk == Nblk)
                c3(N, N, Nblk - 1) = rhs[k];
            else if (i == j && m == 0 && iblk > 0)
                c3(0, 0, iblk) = rhs[k];
            else
                c3(m, j % N, iblk) = rhs[k];
            continue;
        }
        else if (jblk == iblk - 1) {
            if (m == 0) {
                c3(N, j % N, jblk) = rhs[k];
                continue;
            }
        }
        else if (jblk == iblk + 1) {
            Long n = j % N;
            if (n == 0) {
                c3(m, N, iblk) = rhs[k];
                continue;
            }
        }
        SLS_ERR("element out of block!");
    }
}
//%--------------------

// inline void cooh2dense(@Tmat@_O lhs, @McoohTs@_I rhs)
// {
// #ifdef SLS_CHECK_SHAPE
//     if (!shape_cmp(lhs, rhs))
//         SLS_ERR("wrong shape!");
// #endif
//     copy(lhs, 0);
//     for (Long i = 0; i < rhs.nnz(); ++i) {
//         Long r = rhs.row(i), c = rhs.col(i);
//         if (r == c)
//             lhs(r, r) = rhs(i);
//         else {
//             lhs(r, c) = rhs(i);
//             lhs(c, r) = conj(rhs(i));
//         }
//     }
// }

// from MatCoo and MatCooH to dense matrix
// #include "matrix_coo2dense.inl"

// template <class T, class T1, SLS_IF(is_promo<T, T1>())>
// void copy(MatCoo<T> &v, const CmatObd<T1> &v1)
// {
// #ifdef SLS_CHECK_SHAPE
//     if (!shape_cmp(v, v1))
//         SLS_ERR("wrong shape!");
//     if (v.capacity() < v1.nnz())
//         SLS_ERR("not enough capacity!");
// #endif
//     if (v1.nnz() == 0)
//         return;
//     Long N0 = v1.n0(), N1 = N0 - 1;
//     Long N = v1.n1();
//     Long k = 0;
//     for (Long blk = 0; blk < v1.nblk(); ++blk) {
//         for (Long j = 0; j < N0; ++j) {
//             for (Long i = 0; i < N0; ++i) {
//                 Long shift = blk * N1 - 1;
//                 Long ii = shift + i, jj = shift + j;
//                 if (!((i == N1 && j == N1) || ii < 0 || jj < 0 || ii == N || jj == N))
//                     v.push(v1(k), ii, jj);
//                 ++k;
//             }
//         }
//     }
// }

//% types = {
//%     'CbandDoub'; 'CbandComp';
//% };
//%------------------------------
//% T = varargin{:}; Ts = contain_type(T);
//% DcmatTs = ['Dcmat' Ts];
@DcmatTs@ band(@T@_IO);
@DcmatTs@_c band(@T@_I);

inline void copy(@T@_O a, @Ts@_I s)
{
    copy(band(a), s);
}
//%------------------------------

//% types = {
//%     'CbandDoub' 'CbandDoub';
//%     'CbandComp' 'CbandComp';
//% };
//%------------------------------
//% [T, T1] = varargin{:};
inline void copy(@T@_O a, @T@_I b)
{
#ifdef SLS_CHECK_SHAPE
    if (a.idiag() < b.nup() || a.lda() - a.idiag() - 1 < b.nlow())
        SLS_ERR("wrong shape!");
#endif
    a.reshape(b.n1(), b.nup(), b.nlow());
    copy(band(a), band(b));
}
//%------------------------------

//% types = {
//%     'CbandDoub', 'CmatDoub';
//%     'CmatDoub', 'CbandDoub';
//%     'CbandDoub', 'ScmatDoub';
//%     'ScmatDoub', 'CbandDoub';
//%     'CbandComp', 'CmatComp';
//%     'CmatComp', 'CbandComp';
//%     'CbandComp', 'ScmatComp';
//%     'ScmatComp', 'CbandComp';
//%     'CbandComp', 'ScmatDoub';
//%     'ScmatComp', 'CbandDoub';
//% };
//%------------------------------
//% [T1, T2] = varargin{:};
//% Ts1 = contain_type(T1); Ts2 = contain_type(T2);
//% SvecTs1 = ['Svec' Ts1]; SvecTs2 = ['Svec' Ts2];
//% if is_Cband(T1)
inline void copy(@T1@_O b, @T2@_I a)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(a, b))
        SLS_ERR("wrong shape!");
#endif
    Long N1 = a.n1(), N2 = a.n2();
    for (Long j = 0; j < N2; ++j) {
        @SvecTs1@ sli_b = slice1(b.cmat(), j);
        @SvecTs2@_c sli_a = slice1(a, j);
        Long k = b.idiag() - j;
        Long i_beg = max(Long(0), j - b.nup()), i_end = min(N1, j + b.nlow() + 1);
        for (Long i = i_beg; i < i_end; ++i)
            sli_b[k + i] = sli_a[i];
    }
}
//% else
inline void copy(@T1@_O a, @T2@_I b)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(a, b))
        SLS_ERR("wrong shape!");
#endif
    Long N1 = a.n1(), N2 = a.n2();
    for (Long j = 0; j < N2; ++j) {
        Long k = b.idiag() - j;
        Long i_beg = max(Long(0), j - b.nup()), i_end = min(N1, j + b.nlow() + 1);
        @SvecTs1@ sli_a = slice1(a, j);
        @SvecTs2@_c sli_b = slice1(b.cmat(), j);
        for (Long i = 0; i < i_beg; ++i)
            sli_a[i] = 0;
        for (Long i = i_beg; i < i_end; i++)
            sli_a[i] = sli_b[k + i];
        for (Long i = i_end; i < N1; ++i)
            sli_a[i] = 0;
    }
}
//% end
//%------------------------------

// void copy(Matrix<T> &b, const Matrix<T> &a, Long_I Nup, Long_I Nlow)
// {
//     Long N1 = a.n1(), N2 = a.n2();
//     for (Long i = 0; i < N1; i++) {
//         Long k = Nlow - i;
//         for (Long j = max(Long(0), i - Nlow); j < MIN(N2, i + Nup + 1); j++) {
//             b(i, k + j) = a(i, j);
//         }
//     }
// }

// template <class T, SLS_IF0(is_scalar<T>())>
// void copy(Matrix<T> &a, const Matrix<T> &b, Long_I Nup, Long_I Nlow)
// {
//     Long N1 = a.n1(), N2 = a.n2();
//     for (Long i = 0; i < N1; i++) {
//         Long k = Nlow - i;
//         for (Long j = max(Long(0), i - Nlow); j < MIN(N2, i + Nup + 1); j++) {
//             a(i, j) = b(i, k + j);
//         }
//     }
// }


} // namespace slisc
