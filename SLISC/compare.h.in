#pragma once
#include "Vec.h"
#include "Mat.h"
#include "Mat3.h"
#include "Cmat.h"
#include "Cmat3.h"
#include "Cmat4.h"
#include "Cband.h"
#include "Mcoo.h"
#include "Cmobd.h"
#include "Svec.h"
#include "Dvec.h"
#include "Scmat.h"
#include "Scmat3.h"
#include "Dcmat.h"
#include "Jcmat3.h"

namespace slisc {
//% types = {
//%     'Int', 'Int';
//%     'Llong', 'Llong';
//%     'Doub', 'Doub';
//%     'Comp', 'Comp';
//%     };
//%------------------------
//% T = varargin{:};
inline Bool equals_to_vs(const @T@ *v, @T@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        if (v[i] != s)
            return false;
    return true;
}
//%------------------------

//% types = {
//%     'Char', 'Char';
//%     'Int', 'Int';
//%     'Llong', 'Llong';
//%     'Doub', 'Llong';
//%     'Doub', 'Doub';
//%     'Doub', 'Comp';
//%     'Comp', 'Doub';
//%     'Comp', 'Comp';
//%     };
//%--------------------------------
//% [T1, T2] = varargin{:};
inline Bool equals_to_vv(const @T1@ *v1, const @T2@ *v2, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        if (v1[i] != v2[i])
            return false;
    return true;
}
//%------------------------

//% types = {
//%     'VecBool' 'VecBool';
//%     'VecChar' 'VecChar';
//%     'VecChar' 'VecInt';
//%     'VecChar' 'VecLlong';
//%     'VecInt' 'VecInt';
//%     'VecInt' 'VecLlong';
//%     'VecInt' 'SvecInt';
//%     'VecInt' 'DvecInt';
//%     'VecLlong' 'DvecLlong';
//%     'VecDoub' 'SvecDoub';
//%     'VecDoub' 'DvecDoub';
//%     'VecDoub' 'VecLlong';
//%     'VecDoub' 'VecChar';
//%     'VecDoub' 'VecDoub';
//%     'VecDoub' 'VecComp';
//%     'VecDoub' 'SvecComp';
//%     'VecLlong' 'VecInt';
//%     'VecLlong' 'VecLlong';
//%     'VecComp' 'VecDoub';
//%     'VecComp' 'VecComp';
//%     'VecComp' 'SvecDoub';
//%     'VecComp' 'SvecComp';
//%     'VecComp' 'DvecComp';
//%     'MatInt' 'MatInt';
//%     'MatLlong' 'MatLlong';
//%     'MatDoub' 'MatDoub';
//%     'MatDoub' 'CmatDoub';
//%     'MatComp' 'MatComp';
//%     'MatComp' 'CmatComp';
//%     'Mat3Doub' 'Mat3Comp';
//%     'Mat3Doub' 'Mat3Doub';
//%     'Mat3Comp' 'Mat3Doub';
//%     'Mat3Comp' 'Mat3Comp';
//%     'CmatInt' 'CmatInt';
//%     'CmatInt' 'MatChar';
//%     'CmatLlong' 'CmatLlong';
//%     'CmatDoub' 'CmatDoub';
//%     'CmatDoub' 'ScmatDoub';
//%     'CmatDoub' 'DcmatDoub';
//%     'CmatComp' 'CmatDoub';
//%     'CmatComp' 'CmatComp';
//%     'CmatComp' 'ScmatComp';
//%     'CmatComp' 'DcmatComp';
//%     'CmatDoub' 'MatDoub';
//%     'CmatComp' 'MatComp';
//%     'DcmatChar' 'DcmatChar';
//%     'DcmatChar' 'DcmatInt';
//%     'DcmatInt' 'DcmatInt';
//%     'DcmatInt' 'CmatInt';
//%     'DcmatLlong' 'DcmatLlong';
//%     'DcmatFloat' 'DcmatFloat';
//%     'DcmatDoub' 'CmatDoub';
//%     'DcmatDoub' 'DcmatDoub';
//%     'DcmatLdoub' 'DcmatLdoub';
//%     'DcmatComp' 'DcmatDoub';
//%     'DcmatComp' 'CmatComp';
//%     'DcmatDoub' 'DcmatComp';
//%     'DcmatComp' 'DcmatComp';
//%     'Cmat3Int' 'Cmat3Int';
//%     'Cmat3Doub' 'Cmat3Doub';
//%     'Cmat3Doub' 'Cmat3Comp';
//%     'Cmat3Comp' 'Cmat3Doub';
//%     'Cmat3Comp' 'Cmat3Comp';
//%     'Cmat3Comp' 'Jcmat3Comp';
//%     'CmatDoub' 'McooDoub';
//%     'CmatComp' 'McooComp';
//%     'McooDoub' 'McooDoub';
//%     'McooDoub' 'CmatDoub';
//%     'McooComp' 'CmatComp';
//%     'McooComp' 'McooDoub';
//%     'McooComp' 'McooComp';
//%     'SvecChar' 'SvecChar';
//%     'SvecInt' 'SvecInt';
//%     'SvecInt' 'DvecInt';
//%     'SvecLlong' 'SvecLlong';
//%     'SvecLlong' 'DvecLlong';
//%     'SvecFloat' 'SvecFloat';
//%     'SvecDoub' 'VecDoub';
//%     'SvecDoub' 'SvecDoub';
//%     'SvecDoub' 'SvecComp';
//%     'SvecDoub' 'DvecDoub';
//%     'SvecLdoub' 'SvecLdoub';
//%     'SvecFcomp' 'SvecFcomp';
//%     'SvecComp' 'VecComp';
//%     'SvecComp' 'SvecDoub';
//%     'SvecComp' 'SvecComp';
//%     'SvecComp' 'DvecComp';
//%     'ScmatInt' 'ScmatInt';
//%     'ScmatLlong' 'ScmatLlong';
//%     'ScmatDoub' 'CmatDoub';
//%     'ScmatDoub' 'CbandDoub';
//%     'ScmatDoub' 'CbandComp';
//%     'ScmatComp' 'CmatDoub';
//%     'ScmatComp' 'CmatComp';
//%     'ScmatComp' 'CbandDoub';
//%     'ScmatComp' 'CbandComp';
//%     'DvecChar' 'DvecChar';
//%     'DvecInt' 'DvecInt';
//%     'DvecLlong' 'DvecLlong';
//%     'DvecDoub' 'DvecDoub';
//%     'DvecComp' 'SvecDoub';
//%     'DvecComp' 'SvecComp';
//%     'Jcmat3Float' 'Jcmat3Float';
//%     'Jcmat3Doub' 'Cmat3Doub';
//%     'Jcmat3Doub' 'Jcmat3Doub';
//%     'Jcmat3Ldoub' 'Jcmat3Ldoub';
//%     'Jcmat3Fcomp' 'Jcmat3Fcomp';
//%     'Jcmat3Comp' 'Jcmat3Comp';
//%     'Jcmat3Lcomp' 'Jcmat3Lcomp';
//%     'CmobdInt' 'McooInt';
//%     'CmobdDoub' 'McooDoub';
//%     'CmobdComp' 'McooDoub';
//%     'CbandDoub' 'CbandDoub';
//%     'CbandComp' 'CbandComp';
//%     'CbandDoub' 'CmatDoub';
//%     'CbandComp' 'CmatComp';
//%     'CmatDoub' 'CbandDoub';
//%     'CmatComp' 'CbandComp';
//% };
//%---------------------------------
//% [T1, T2] = varargin{:};
inline Bool shape_cmp(@T1@_I v1, @T2@_I v2)
{
//% N1 = ndim(T1); N2 = ndim(T2);
//% if N1 ~= N2
    return false;
//% elseif N1 == 1
    return v1.size() == v2.size();
//% elseif N1 == 2
    return v1.n1() == v2.n1() && v1.n2() == v2.n2();
//% elseif N1 == 3
    return v1.n1() == v2.n1() && v1.n2() == v2.n2()
            && v1.n3() == v2.n3();
//% elseif N1 == 4
    return v1.n1() == v2.n1() && v1.n2() == v2.n2()
            && v1.n3() == v2.n3() && v1.n4() == v2.n4();
}
//% else
//%     error('not implemented!');
//% end
}
//%------------------------

//% types = {
//%     'VecChar', 'VecChar';
//%     'VecInt', 'VecInt';
//%     'VecInt', 'DvecInt';
//%     'VecLlong', 'DvecLlong';
//%     'VecLlong', 'VecLlong';
//%     'VecDoub', 'DvecDoub';
//%     'VecDoub', 'VecDoub';
//%     'VecDoub', 'VecComp';
//%     'VecComp', 'VecComp';
//%     'SvecChar', 'SvecChar';
//%     'SvecInt', 'SvecInt';
//%     'SvecInt', 'DvecInt';
//%     'SvecLlong', 'DvecLlong';
//%     'SvecLlong', 'SvecLlong';
//%     'SvecDoub', 'DvecDoub';
//%     'SvecDoub', 'SvecDoub';
//%     'SvecDoub', 'SvecComp';
//%     'SvecComp', 'SvecComp';
//%     'MatInt', 'MatInt';
//%     'MatLlong', 'MatLlong';
//%     'MatDoub', 'MatDoub';
//%     'MatComp', 'MatComp';
//%     'CmatInt', 'CmatInt';
//%     'CmatDoub', 'CmatDoub';
//%     'CmatComp', 'CmatComp';
//%     'CmatComp', 'MatComp';
//%     'MatDoub', 'CmatDoub';
//%     'CmatDoub', 'MatDoub';
//%     'Cmat3Doub', 'Cmat3Doub';
//%     'Mat3Doub', 'Mat3Doub';
//%     'DvecInt', 'DvecInt';
//%     'DvecLong', 'DvecLong';
//%     'DvecDoub', 'DvecDoub';
//%     'DcmatDoub', 'CmatDoub';
//%     'Jcmat3Doub', 'Cmat3Doub';
//%     };
//%--------------------------
//% [T1, T2] = varargin{:};
inline Bool operator==(@T1@_I v1, @T2@_I v2)
{
//% if is_dense(T1) && is_dense(T2) && is_same_major(T1, T2)
    return shape_cmp(v1, v2) &&
        equals_to_vv(v1.ptr(), v2.ptr(), v2.size());
//% elseif ndim(T1) == 1 && ndim(T2) == 1
    if (!shape_cmp(v1, v2))
        return false;
    for (Long i = 0; i < v1.size(); ++i) {
        if (v1[i] != v2[i])
            return false;
    }
    return true;
//% elseif ndim(T1) == 2 && ndim(T2) == 2
    if (!shape_cmp(v1, v2))
        return false;
    for (Long i = 0; i < v1.n1(); ++i)
        for (Long j = 0; j < v1.n2(); ++j)
            if (v1(i, j) != v2(i, j))
                return false;
    return true;
//% elseif ndim(T1) == 3 && ndim(T2) == 3
    if (!shape_cmp(v1, v2))
        return false;
    for (Long i = 0; i < v1.n1(); ++i)
        for (Long j = 0; j < v1.n2(); ++j)
            for (Long k = 0; k < v1.n3(); ++k)
                if (v1(i, j, k) != v2(i, j, k))
                    return false;
    return true;
//% else
//%     error('not implemented!');
//% end
}

inline Bool operator!=(@T1@_I v1, @T2@_I v2)
{
    return !(v1 == v2);
}
//%------------------------

inline Bool operator==(VecBool_I v1, VecBool_I v2)
{
    for (Long i = 0; i < v1.size(); ++i)
        if (v1[i] != v2[i])
            return false;
    return true;
}

inline Bool operator!=(VecBool_I v1, VecBool_I v2)
{
    return !(v1 == v2);
}

//% types = {
//%     'VecInt'; 'VecLlong'; 'VecDoub'; 'VecComp';
//%     'DvecInt'; 'DvecLlong'; 'DvecDoub';
//%     'MatInt'; 'MatLlong'; 'MatDoub'; 'MatComp';
//%     'Mat3Doub'; 'CmatDoub'; 'CmatComp'; 'Cmat3Doub';
//%     'Cmat3Comp'
//%     };
//%--------------------------
//% T = varargin{:};
//% Ts = value_type(T);
inline Bool operator==(@T@_I v, @Ts@_I s)
{
//% if is_dense(T)
    return equals_to_vs(v.ptr(), s, v.size());
//% elseif is_Dcmat(T)
    for (Long j = 0; j < v.n2(); ++j)
        if !equals_to_vs(v.ptr() + v.n1()*j, s, v.n1());
            return false
    return true;
//% else
    for (Long i = 0; i < v.size(); ++i)
        if (v[i] != s)
            return false;
    return true;
//% end
}

inline Bool operator!=(@T@_I v, @Ts@_I s)
{
    return !(v == s);
}
//%------------------------
} // namespace slisc
