// functions that loop through every element of a container
#pragma once
#include "copy.h"

namespace slisc {

//% tem('resize_cpy', { 'VecInt'; 'VecLlong'; 'VecDoub'; 'VecComp';
//%     'CmatInt'; 'CmatLlong';
//%     'CmatDoub'; 'CmatComp'; 'Cmat3Doub';
//%     'Cmat3Comp';});
//%--------------------------------
//% Tv = varargin{:};
//% T = val_t(Tv);
//% if is_Vec(Tv)
inline void resize_cpy(@Tv@_IO v, Long_I N, @T@_I val = 0)
{
    Long Nold = v.size();
    if (N != Nold) {
        if (Nold == 0) {
//% req('copy(v,s)', {Tv});
            v.resize(N); copy(v, val);
        }
        else if (N == 0)
            v.resize(0);
        else {
            @Tv@ v1(N);
            if (N > Nold) {
//% req('vecset', {T});
                veccpy(v1.p(), v.p(), Nold);
                vecset(v1.p() + Nold, val, N - Nold);
            }
            else // N < Nold
                veccpy(v1.p(), v.p(), N);
            v << v1;
        }
    }
}
//% elseif is_Cmat(Tv) || is_Mat(Tv)
//%     Tsli = cut_type(Tv);
inline void resize_cpy(@Tv@_IO v, Long_I N0, Long_I N1, @T@_I val = 0)
{
    Long N10 = v.n0(), N20 = v.n1(), Nold = N0*N1;
    Long N = N0 * N1;
    if (N0 != N10 || N1 != N20) {
        if (Nold == 0) {
//%     req('copy(v,s)', {Tv});
            v.resize(N0, N1); copy(v, val);
        }
        else if (N == 0)
            v.resize(0, 0);
        else {
            @Tv@ v1(N0, N1); copy(v1, val);
            Long N1min = min(N0, N10), N2min = min(N1, N20);
//%     req('cut', {Tv}); req('copy(v,v)', {Tsli,Tsli});
            copy(cut(v1, 0, N1min, 0, N2min),
                cut(v, 0, N1min, 0, N2min));
            v << v1;
        }
    }
}
//% elseif is_Cmat3(Tv) || is_Mat3(Tv)
//%     Tsli = cut_type(Tv);
inline void resize_cpy(@Tv@_IO v, Long_I N0, Long_I N1, Long_I N2, @T@_I val = 0)
{
    Long N10 = v.n0(), N20 = v.n1(), N30 = v.n2(), Nold = N0*N1;
    Long N = N0 * N1 * N2;
    if (N0 != N10 || N1 != N20 || N2 != N30) {
        if (Nold == 0) {
//% req('copy(v,s)', {Tv});
            v.resize(N0, N1, N2); copy(v, val);
        }
        else if (N == 0)
            v.resize(0, 0, 0);
        else {
            @Tv@ v1(N0, N1, N2); copy(v1, val);
            Long N1min = min(N0, N10), N2min = min(N1, N20), N3min = min(N2, N30);
//%     req('cut', {Tv}); req('copy(v,v)', {Tsli,Tsli});
            copy(cut(v1, 0, N1min, 0, N2min, 0, N3min),
                cut(v, 0, N1min, 0, N2min, 0, N3min));
            v << v1;
        }
    }
}
//% else
//%     error('not implemented (7)');
//% end
//%-------------------------

//% tem('flip_v', { 'Doub' });
//%---------------------------------
//% T = varargin{:};
inline void flip_v(@T@ *v, Long_I N)
{
    for (Long i = 0; i < N / 2; ++i)
        swap(v[i], v[N - i - 1]);
}
//%---------------------

//% tem('flip_vv', { 'Doub', 'Doub' });
//%---------------------------------
//% [T, T1] = varargin{:};
inline void flip_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[N - i - 1];
}
//%----------------------------

//% tem('flip_vec', { 'VecInt'; 'VecLlong'; 'VecDoub'; 'VecComp';
//%  'vecLlong'; 'vecDoub'; 'vecComp'; 'vecStr'; });
//%---------------------------------
//% Tv = varargin{:}; Ts = val_t(Tv);
//% if is_dense(Tv)
//% req('flip_v', {Ts});
inline void flip(@Tv@_IO v)
{ flip_v(&v[0], v.size()); }
//% else
//%     error('flip: not implemented (8)!');
//% end
//%---------------------------

//% tem('flip(v,v)', { 'VecInt', 'VecInt';
//%    'VecDoub', 'VecDoub' });
//%---------------------------------
//% [T, T1] = varargin{:}; [Ts,Ts1] = val_t(T,T1);
//% if is_dense(T) && is_dense(T1)
inline void flip(@T@_O v, @T1@_I v1)
{
//% req('assert_same_shape', {T, T1});
    assert_same_shape(v, v1);
//% req('flip_vv', {Ts,Ts1});
    flip_vv(v.p(), v1.p(), v1.size());
}
//% else
//%     error('not implemented (9)!');
//% end
//%---------------------------

//% tem('reorder', {
//%     'VecInt', 'VecInt';
//%     'VecLlong', 'VecLlong';
//%     'VecDoub', 'VecLlong';
//%     'SvecComp', 'VecLlong';
//%     'vecStr', 'vecLlong';
//%     'vecStr32', 'vecLlong';
//% });
//%---------------------
//% [Tv, To] = varargin{:};
//% if ~is_vecStr(Tv) && ~is_vecStr32(Tv)
//%     Tu = ['Vec' val_t(Tv)];
//% else
//%     Tu = Tv;
//% end
inline void reorder(@Tv@_O v, @To@_I order)
{
#ifdef SLS_CHECK_SHAPES
    if ((Long)order.size() != (Long)v.size())
        SLS_ERR("wrong shape!");
#endif
    Long N = v.size();
    static @Tu@ u; u.resize(N);
    if (N > (Long)u.size())
        u.resize(max(N, Long(2*u.size())));
    for (Long i = 0; i < N; ++i)
        u[i] = v[order[i]];
    for (Long i = 0; i < N; ++i)
        v[i] = u[i];
}
//%-------------------------

//% tem('trans', { 'CmatInt'; 'CmatDoub'; 'ScmatDoub'; 'DcmatDoub';
//% 'CmatQdoub' });
//%--------------------------
//% T = varargin{:};
//% Ts = val_t(T);
inline void trans(@T@_IO v)
{
#ifdef SLS_CHECK_SHAPES
    if (v.n0() != v.n1())
        SLS_ERR("illegal shape!");
#endif
    for (Long i = 0; i < v.n0(); ++i)
        for (Long j = 0; j < i; ++j)
            swap(v(i, j), v(j, i));
}
//%-------------------------

//% tem('trans(v,v)', {
//%   'CmatInt' 'CmatInt';
//%   'CmatLlong' 'CmatLlong';
//%   'CmatDoub' 'CmatDoub';
//%   'CmatComp' 'CmatComp';
//%   'MatComp' 'CmatComp'
//%   'ScmatDoub' 'ScmatDoub';
//%   'ScmatComp' 'ScmatComp';
//%   'CmatQdoub' 'CmatQdoub' });
//%--------------------------
//% [T, T1] = varargin{:};
//% [Ts,Ts1] = val_t(T,T1);
inline void trans(@T@_O v, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPES
    if (v.n0() != v1.n1() || v.n1() != v1.n0())
        SLS_ERR("wrong shape!");
#endif
    for (Long i = 0; i < v.n0(); ++i)
        for (Long j = 0; j < v.n1(); ++j)
            v(i, j) = v1(j, i);
}
//%-------------------------

//% tem('her(v)', { 'CmatComp' });
//%--------------------------
//% T = varargin{:}; Ts = val_t(T);
//% if ~(is_comp(Ts) && ndim(T) == 2)
//%     error('error types!');
//% end
inline void her(@T@_IO v)
{
#ifdef SLS_CHECK_SHAPES
    if (v.n0() != v.n1()) SLS_ERR("illegal shape!");
#endif
//% req('trans', {T}); req('conj', {T});
    trans(v); conj(v);
}
//%---------------------------

//% tem('her(v,v)', {
//%    'CmatComp' 'MatComp'
//%    'MatComp' 'CmatComp'
//% 'DcmatComp' 'DcmatComp' });
//%--------------------------
//% [T, T1] = varargin{:};
//% req('trans(v,v)', {T,T1}); req('conj', {T});
inline void her(@T@_O v, @T1@_I v1)
{ trans(v, v1); conj(v); }
//%-------------------------

} // namespace slisc
