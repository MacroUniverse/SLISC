// Cmat container
#pragma once
#include "Vbase.h"

namespace slisc {
//% types = {
//%     'Char'; 'Int'; 'Llong'; 'Long';
//%     'Float'; 'Doub'; 'Ldoub';
//%     'Fcomp'; 'Comp'; 'Lcomp';
//%     'Fimag'; 'Imag'; 'Limag';};
//%----------------------------------------
//% T = varargin{:};
//% CmatT = ['Cmat' T];
//% VbaseT = ['Vbase' T];
//% if is_Long(T)
#ifdef SLS_USE_INT_AS_LONG
typedef CmatInt CmatLong;
#else
typedef CmatLlong CmatLong;
#endif
//% else
class @CmatT@ : public @VbaseT@
{
protected:
    typedef @VbaseT@ Base;
    Long m_N1, m_N2;
public:
    @CmatT@(): m_N1(0), m_N2(0) {};
    @CmatT@(Long_I N1, Long_I N2);
    @CmatT@(const @CmatT@ &rhs);        // Copy constructor
    @CmatT@ &operator=(const @CmatT@ &rhs) = delete;
    void operator<<(@CmatT@ &rhs); // move data and rhs.resize(0, 0)
    @T@& operator()(Long_I i, Long_I j);    // double indexing
    const @T@& operator()(Long_I i, Long_I j) const;
    Long n1() const;
    Long n2() const;
    void resize(Long_I N1, Long_I N2); // resize (contents not preserved)
    void reshape(Long_I N1, Long_I N2); // reshape (total elm # must be the same)
};

inline @CmatT@::@CmatT@(Long_I N1, Long_I N2) : Base(N1*N2), m_N1(N1), m_N2(N2) {}

inline @CmatT@::@CmatT@(const @CmatT@ &rhs) : Base(rhs), m_N1(rhs.m_N1), m_N2(rhs.m_N2)
{
#ifdef SLS_NO_CPY_CONSTRUCTOR
    SLS_ERR("copy constructor forbidden!");
#endif
    for (Long i = 0; i < m_N; ++i)
        m_p[i] = rhs.m_p[i];
}

inline void @CmatT@::operator<<(@CmatT@ &rhs)
{
    m_N1 = rhs.m_N1; m_N2 = rhs.m_N2;
    rhs.m_N1 = rhs.m_N2 = 0;
    Base::operator<<(rhs);
}

inline @T@ &@CmatT@::operator()(Long_I i, Long_I j)
{
#ifdef SLS_CHECK_BOUNDS
    if (i < 0 || i >= m_N1 || j < 0 || j >= m_N2)
        SLS_ERR("@CmatT@ index ("+num2str(i)+", "+num2str(j)
            +") out of bounds: shape = ("+num2str(m_N1)+", "+num2str(m_N2)+")");
#endif
    return m_p[i+m_N1*j];
}

inline const @T@ &@CmatT@::operator()(Long_I i, Long_I j) const
{
#ifdef SLS_CHECK_BOUNDS
    if (i < 0 || i >= m_N1 || j < 0 || j >= m_N2)
        SLS_ERR("@CmatT@ index ("+num2str(i)+", "+num2str(j)
            +") out of bounds: shape = ("+num2str(m_N1)+", "+num2str(m_N2)+")");
#endif
    return m_p[i+m_N1*j];
}

inline Long @CmatT@::n1() const
{ return m_N1; }

inline Long @CmatT@::n2() const
{ return m_N2; }

inline void @CmatT@::resize(Long_I N1, Long_I N2)
{
    if (N1 != m_N1 || N2 != m_N2) {
        Base::resize(N1*N2);
        m_N1 = N1; m_N2 = N2;
    }
}

inline void @CmatT@::reshape(Long_I N1, Long_I N2)
{
#ifdef SLS_CHECK_SHAPES
    if (N1 * N2 != m_N)
        SLS_ERR("@CmatT@ reshaping from ("+num2str(m_N1)+", "+num2str(m_N2)
            +") to ("+num2str(N1)+", "+num2str(N2)+"), element number not the same!");
#endif
    m_N1 = N1; m_N2 = N2;
}
//% end

typedef const @CmatT@ &@CmatT@_I;
typedef @CmatT@ &@CmatT@_O, &@CmatT@_IO;
//%----------------------------------------

class CmatBool : public VbaseBool
{
protected:
    typedef VbaseBool Base;
    Long m_N1, m_N2;
public:
    CmatBool(): m_N1(0), m_N2(0) {};
    CmatBool(Long_I N1, Long_I N2);
    CmatBool(const CmatBool &rhs);        // Copy constructor
    CmatBool &operator=(const CmatBool &rhs) = delete;
    void operator<<(CmatBool &rhs); // move data and rhs.resize(0, 0)
    CmatBool::ref operator()(Long_I i, Long_I j);    // double indexing
    Bool operator()(Long_I i, Long_I j) const;
    Long n1() const;
    Long n2() const;
    void resize(Long_I N1, Long_I N2); // resize (contents not preserved)
};

inline CmatBool::CmatBool(Long_I N1, Long_I N2) : Base(N1*N2), m_N1(N1), m_N2(N2) {}

inline CmatBool::CmatBool(const CmatBool &rhs) : Base(rhs.size()), m_N1(rhs.m_N1), m_N2(rhs.m_N2)
{
#ifdef SLS_NO_CPY_CONSTRUCTOR
    SLS_ERR("copy constructor forbidden!");
#endif
    Long N = size();
    for (Long i = 0; i < N; ++i)
        (*this)[i] = rhs[i];
}

inline void CmatBool::operator<<(CmatBool &rhs)
{
    m_N1 = rhs.m_N1; m_N2 = rhs.m_N2;
    rhs.m_N1 = rhs.m_N2 = 0;
    Base::operator<<(rhs);
}

inline CmatBool::ref CmatBool::operator()(Long_I i, Long_I j)
{
#ifdef SLS_CHECK_BOUNDS
    if (i < 0 || i >= m_N1 || j < 0 || j >= m_N2)
        SLS_ERR("CmatBool index ("+num2str(i)+", "+num2str(j)
            +") out of bounds: shape = ("+num2str(m_N1)+", "+num2str(m_N2)+")");
#endif
    return (*this)[i+m_N1*j];
}

inline Bool CmatBool::operator()(Long_I i, Long_I j) const
{
#ifdef SLS_CHECK_BOUNDS
    if (i < 0 || i >= m_N1 || j < 0 || j >= m_N2)
        SLS_ERR("CmatBool index ("+num2str(i)+", "+num2str(j)
            +") out of bounds: shape = ("+num2str(m_N1)+", "+num2str(m_N2)+")");
#endif
    return (*this)[i+m_N1*j];
}

inline Long CmatBool::n1() const
{ return m_N1; }

inline Long CmatBool::n2() const
{ return m_N2; }

inline void CmatBool::resize(Long_I N1, Long_I N2)
{
    if (N1 != m_N1 || N2 != m_N2) {
        Base::resize(N1*N2);
        m_N1 = N1; m_N2 = N2;
    }
}

typedef const CmatBool &CmatBool_I;
typedef CmatBool &CmatBool_O, &CmatBool_IO;

} // namespace slisc
