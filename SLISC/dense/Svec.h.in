#pragma once
#include "../global.h"
#include "../arith/Imag.h"
#include "../dense/Vec.h"

// this class is not memory safe!
// "C" means lower level const

namespace slisc {
//% tem('Svbase', {
//%     'Char', true;   'Char', false;
//%     'Uchar', true;   'Uchar', false;
//%     'Int', true;    'Int', false;
//%     'Llong', true;  'Llong', false;
//%     'Float', true;  'Float', false;
//%     'Doub', true;   'Doub', false;
//%     'Ldoub', true;  'Ldoub', false;
//%     'Qdoub', true;  'Qdoub', false;
//%     'Fcomp', true;  'Fcomp', false;
//%     'Comp', true;   'Comp', false;
//%     'Lcomp', true;  'Lcomp', false;
//%     'Qcomp', true;  'Qcomp', false;
//%     'Fimag', true;  'Fimag', false;
//%     'Imag', true;   'Imag', false;
//%     'Limag', true;  'Limag', false;
//%     'Qimag', true;  'Qimag', false;
//% });
//%------------------------
//% [T, constness] = varargin{:};
//% SvbaseT = ['Svbase' T];
//% SvbaseTC = [SvbaseT 'C'];
//% if constness
//%     CT = ['const ' T];
//%     Class = SvbaseTC;
//% else
//%     CT = T;
//%     Class = SvbaseT;
//% end
class @Class@
{
protected:
	@CT@ *m_p;
	Long m_N;
public:
	@Class@();
	explicit @Class@(Long_I N);
	@Class@(@CT@ *data, Long_I N);
	@CT@* p() const;
	Long size() const;
	@Class@ &operator=(const @Class@ &rhs) = delete;
	@CT@ &operator[](Long_I i) const;
	@CT@ &end() const;
	@CT@ &end(Long_I i) const;
//% if ~constness
	operator @SvbaseTC@() const;
//% end
	void set(const @Class@ &sli);
	void next(); // m_p += m_N
	
	// === unsafe operations (unsafe) ===
	void set(@CT@ *data);
//% % resize() is a bad name, don't try to use it!
	void set(Long_I N);
	void set(@CT@ *data, Long_I N);
	void last(); // m_p -= m_N
	void shift(Long_I N); // m_p += N

	~@Class@();
};

inline @Class@::@Class@() {}

inline @Class@::@Class@(Long_I N) : m_N(N)
{
#ifdef SLS_CHECK_BOUNDS
	m_p = nullptr;
#endif
}

inline @Class@::@Class@(@CT@ *data, Long_I N)
	: m_p(data), m_N(N) {}

inline @CT@ * @Class@::p() const
{
#ifdef SLS_CHECK_BOUNDS
	if (m_N == 0)
		SLS_ERR("using p() for empty container!");
#endif
	return m_p;
}

inline Long @Class@::size() const
{
	return m_N;
}

inline @CT@ &@Class@::operator[](Long_I i) const
{
#ifdef SLS_CHECK_BOUNDS
	if (i < 0 || i >= m_N)
		SLS_ERR("Vbase subscript out of bounds");
#endif
	return m_p[i];
}

inline @CT@ &@Class@::end() const
{
#ifdef SLS_CHECK_BOUNDS
	if (m_N == 0)
		SLS_ERR("tring to use end() on empty vector!");
#endif
	return m_p[m_N - 1];
}

inline @CT@ &@Class@::end(Long_I i) const
{
#ifdef SLS_CHECK_BOUNDS
	if (i <= 0 || i > m_N)
		SLS_ERR("index out of bound");
#endif
	return m_p[m_N - i];
}

//% if ~constness
inline @Class@::operator @SvbaseTC@() const
{
	return *((@SvbaseTC@ *)this);
}
//% end

inline void @Class@::set(@CT@ *data, Long_I N)
{
	m_p = data; m_N = N;
}

inline void @Class@::set(@CT@ *data)
{
	m_p = data;
}

inline void @Class@::set(Long_I N)
{
	m_N = N;
}

inline void @Class@::next()
{
	m_p += m_N;
}

inline void @Class@::last()
{
	m_p -= m_N;
}

inline void @Class@::shift(Long_I N)
{
	m_p += N;
}

inline void @Class@::set(const @Class@ &sli)
{
	m_p = sli.m_p; m_N = sli.m_N;
}

inline @Class@::~@Class@() {}

// common api for STL and SLISC
inline Long size(const @Class@ &v) { return v.size(); }

//% if constness
inline const @T@ *ptr(const @Class@ &v) { return v.p(); }
//% else
inline @T@ *ptr(@Class@ &v) { return v.p(); }
//% end
//%------------------------

#ifdef SLS_USE_INT_AS_LONG
typedef SvbaseInt SvbaseLong;
typedef SvbaseIntC SvbaseLongC;
#else
typedef SvbaseLlong SvbaseLong;
typedef SvbaseLlongC SvbaseLongC;
#endif

//% tem('Svec', {
//%     'Char', true;   'Char', false;
//%     'Uchar', true;  'Uchar', false;
//%     'Int', true;    'Int', false;
//%     'Llong', true;  'Llong', false;
//%     'Float', true;  'Float', false;
//%     'Doub', true;   'Doub', false;
//%     'Ldoub', true;  'Ldoub', false;
//%     'Qdoub', true;  'Qdoub', false;
//%     'Fcomp', true;  'Fcomp', false;
//%     'Comp', true;   'Comp', false;
//%     'Lcomp', true;  'Lcomp', false;
//%     'Qcomp', true;  'Qcomp', false;
//%     'Fimag', true;  'Fimag', false;
//%     'Imag', true;   'Imag', false;
//%     'Limag', true;  'Limag', false;
//% });
//%------------------------
//% [T, constness] = varargin{:};
//% SvecT = ['Svec' T]; SvbaseT = ['Svbase' T];
//% SvecTC = [SvecT 'C']; SvbaseTC = [SvbaseT 'C'];
//% if constness
//%     CT = ['const ' T];
//%     Class = SvecTC; Base = SvbaseTC;
//%     suffix = '_I';
//% else
//%     CT = T;
//%     Class = SvecT; Base = SvbaseT;
//%     suffix = '_IO';
//% end
class @Class@ : public @Base@
{
public:
	@Class@() = default;
	explicit @Class@(Long_I N);
	@Class@(@CT@ *data, Long_I N);
	@Class@(Vec@T@@suffix@ v);
	@Class@ &operator=(const @Class@ &v); // shalow copy
//% if ~constness
	operator @SvecTC@() const;
//% end
};

inline @Class@::@Class@(Long_I N) : @Base@(N) {}

inline @Class@::@Class@(@CT@ *data, Long_I N)
	: @Base@(data, N) {}

inline @Class@::@Class@(Vec@T@@suffix@ v)
	: @Base@(v.p(), v.size()) {}

inline @Class@ &@Class@::operator=(const @Class@ &rhs)
{
	if (this == &rhs) return *this;
	m_p = rhs.m_p; m_N = rhs.m_N;
	return *this;
}

//% if ~constness
inline @Class@::operator @SvecTC@() const
{
	return *((@SvecTC@ *)this);
}
//% end

//% if constness
typedef const @Class@ &@SvecT@_I;

// common api for STL and SLISC
inline Long size(@SvecT@_I v) { return v.size(); }

inline const @T@ *p(@SvecT@_I v) { return v.p(); }

//% else
// use "const" so that it can be bind to a temporary e.g. copy(cut0(a), cut0(b))
typedef const @Class@ &@SvecT@_O, &@SvecT@_IO;

// common api for STL and SLISC
inline @T@ *p(@SvecT@ &v) { return v.p(); }
//% end

//%------------------------

#ifdef SLS_USE_INT_AS_LONG
typedef SvecInt SvecLong;
typedef SvecIntC SvecLongC;
#else
typedef SvecLlong SvecLong;
typedef SvecLlongC SvecLongC;
#endif
typedef const SvecLongC &SvecLong_I;
// use "const" so that it can be bind to a temporary e.g. copy(cut0(a), cut0(b))
typedef const SvecLong &SvecLong_O, &SvecLong_IO;

} // namespace slisc
