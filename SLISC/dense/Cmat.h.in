// Cmat container
#pragma once
#include "../dense/Vbase.h"

namespace slisc {
//% tem('Cmat', {
//%     'Char'; 'Uchar'; 'Int'; 'Llong';
//%     'Float'; 'Doub'; 'Ldoub'; 'Qdoub';
//%     'Fcomp'; 'Comp'; 'Lcomp'; 'Qcomp';
//%     'Fimag'; 'Imag'; 'Limag'; 'Qimag';});
//%----------------------------------------
//% T = varargin{:};
//% CmatT = ['Cmat' T];
//% VbaseT = ['Vbase' T];
class @CmatT@ : public @VbaseT@
{
protected:
	typedef @VbaseT@ Base;
	Long m_N0, m_N1;
public:
	@CmatT@(): m_N0(0), m_N1(0) {};
	@CmatT@(Long_I N0, Long_I N1);
	@CmatT@(const @CmatT@ &rhs); // copy constructor
	@CmatT@(@CmatT@ &&rhs); // move constructor
	@CmatT@ &operator=(const @CmatT@ &rhs); // copy assignment
	@CmatT@ &operator=(@CmatT@ &&rhs); // move assignment
	@T@& operator()(Long_I i, Long_I j); // double indexing
	const @T@& operator()(Long_I i, Long_I j) const;
	Long n0() const;
	Long n1() const;
	void resize(Long_I N0, Long_I N1); // resize (values not preserved)
	void resize(Long_I N); // resize memory only (values not preserved, N > N1*N2)
	void reshape(Long_I N0, Long_I N1); // reshape (N0*N1 <= m_N)
};

inline @CmatT@::@CmatT@(Long_I N0, Long_I N1) : Base(N0*N1), m_N0(N0), m_N1(N1) {}

inline @CmatT@::@CmatT@(const @CmatT@ &rhs) : Base(rhs), m_N0(rhs.m_N0), m_N1(rhs.m_N1)
{
#ifdef SLS_NO_CPY_CONSTRUCTOR
	SLS_ERR("copy constructor forbidden!");
#endif
}

inline @CmatT@::@CmatT@(@CmatT@ &&rhs)
	: Base(std::move(rhs)), m_N0(rhs.m_N0), m_N1(rhs.m_N1) {}

inline @CmatT@ &@CmatT@::operator=(const @CmatT@ &rhs)
{
	Base::operator=(rhs);
	resize(rhs.n0(), rhs.n1());
	return *this;
}

inline @CmatT@ &@CmatT@::operator=(@CmatT@ &&rhs)
{
	Base::operator=(move(rhs));
	m_N0 = rhs.m_N0; m_N1 = rhs.m_N1;
	return *this;
}

inline @T@ &@CmatT@::operator()(Long_I i, Long_I j)
{
#ifdef SLS_CHECK_BOUNDS
	if (i < 0 || i >= m_N0 || j < 0 || j >= m_N1)
		SLS_ERR("@CmatT@ index ("+num2str(i)+", "+num2str(j)
			+") out of bounds: shape = ("+num2str(m_N0)+", "+num2str(m_N1)+")");
#endif
	return m_p[i+m_N0*j];
}

inline const @T@ &@CmatT@::operator()(Long_I i, Long_I j) const
{
#ifdef SLS_CHECK_BOUNDS
	if (i < 0 || i >= m_N0 || j < 0 || j >= m_N1) {
		stringstream ss; ss << "@CmatT@ index (" << i << ", " << j
			<< ") out of bounds: shape = (" << m_N0 << ", " << m_N1 << ')';
		SLS_ERR(ss.str());
	}
#endif
	return m_p[i+m_N0*j];
}

inline Long @CmatT@::n0() const
{ return m_N0; }

inline Long @CmatT@::n1() const
{ return m_N1; }

inline void @CmatT@::resize(Long_I N0, Long_I N1)
{
	if (N0 != m_N0 || N1 != m_N1) {
		Base::resize(N0*N1);
		m_N0 = N0; m_N1 = N1;
	}
}

inline void @CmatT@::resize(Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
	if (N < m_N0*m_N1) {
		stringstream ss;
		ss  << "@CmatT@ resizing from (" << m_N0 << ", " << m_N1
			<< ") , with " << m_N << "allocated elements, to "
			<< N << " elements is illegal!";
		SLS_ERR(ss.str());
	}
#endif
	Base::resize(N);
}

inline void @CmatT@::reshape(Long_I N0, Long_I N1)
{
#ifdef SLS_CHECK_SHAPES
	if (N0*N1 < m_N) {
		stringstream ss;
		ss  << "@CmatT@ reshaping from (" << m_N0 << ", " << m_N1
			<< ") , with " << m_N << "allocated elements, to (" << N0 << ", "
			<< num2str(N1) << "), element number not the same!";
		SLS_ERR(ss.str());
	}
#endif
	m_N0 = N0; m_N1 = N1;
}

typedef const @CmatT@ &@CmatT@_I;
typedef @CmatT@ &@CmatT@_O, &@CmatT@_IO;

// common api for STL and SLISC
inline Long size(@CmatT@_I v) { return v.size(); }

inline const @T@ *p(@CmatT@_I v) { return v.p(); }

inline @T@ *p(@CmatT@ &v) { return v.p(); }

//%----------------------------------------

#ifdef SLS_USE_INT_AS_LONG
typedef CmatInt CmatLong;
#else
typedef CmatLlong CmatLong;
#endif
typedef const CmatLong &CmatLong_I;
typedef CmatLong &CmatLong_O, &CmatLong_IO;

class CmatBool : public VbaseBool
{
protected:
	typedef VbaseBool Base;
	Long m_N0, m_N1;
public:
	CmatBool(): m_N0(0), m_N1(0) {};
	CmatBool(Long_I N0, Long_I N1);
	CmatBool(const CmatBool &rhs); // copy constructor
	CmatBool(CmatBool &&rhs); // move constructor
	CmatBool &operator=(const CmatBool &rhs) = delete;
	CmatBool::ref operator()(Long_I i, Long_I j);    // double indexing
	bool operator()(Long_I i, Long_I j) const;
	Long n0() const;
	Long n1() const;
	void resize(Long_I N0, Long_I N1); // resize (contents not preserved)
};

inline CmatBool::CmatBool(Long_I N0, Long_I N1) : Base(N0*N1), m_N0(N0), m_N1(N1) {}

inline CmatBool::CmatBool(const CmatBool &rhs) : Base(rhs.size()), m_N0(rhs.m_N0), m_N1(rhs.m_N1)
{
#ifdef SLS_NO_CPY_CONSTRUCTOR
	SLS_ERR("copy constructor forbidden!");
#endif
	Long N = size();
	for (Long i = 0; i < N; ++i)
		(*this)[i] = rhs[i];
}

inline CmatBool::CmatBool(CmatBool &&rhs)
	: Base(std::move(rhs)), m_N0(rhs.m_N0), m_N1(rhs.m_N1) {}

inline CmatBool::ref CmatBool::operator()(Long_I i, Long_I j)
{
#ifdef SLS_CHECK_BOUNDS
	if (i < 0 || i >= m_N0 || j < 0 || j >= m_N1)
		SLS_ERR("CmatBool index ("+num2str(i)+", "+num2str(j)
			+") out of bounds: shape = ("+num2str(m_N0)+", "+num2str(m_N1)+")");
#endif
	return (*this)[i+m_N0*j];
}

inline bool CmatBool::operator()(Long_I i, Long_I j) const
{
#ifdef SLS_CHECK_BOUNDS
	if (i < 0 || i >= m_N0 || j < 0 || j >= m_N1)
		SLS_ERR("CmatBool index ("+num2str(i)+", "+num2str(j)
			+") out of bounds: shape = ("+num2str(m_N0)+", "+num2str(m_N1)+")");
#endif
	return (*this)[i+m_N0*j];
}

inline Long CmatBool::n0() const
{ return m_N0; }

inline Long CmatBool::n1() const
{ return m_N1; }

inline void CmatBool::resize(Long_I N0, Long_I N1)
{
	if (N0 != m_N0 || N1 != m_N1) {
		Base::resize(N0*N1);
		m_N0 = N0; m_N1 = N1;
	}
}

typedef const CmatBool &CmatBool_I;
typedef CmatBool &CmatBool_O, &CmatBool_IO;

} // namespace slisc
