#pragma once
#include "arith1.h"
#include "arith2.h"
#include "arith4.h"
#include "reorder.h"
#include "copy.h"
#include "mul.h"
#include "cut.h"

namespace slisc {

// concatinate std::vector
//% tem('cat_vec', {'vecInt'; 'vecLong'; 'vecStr'; 'vecStr32';});
//%---------------------
//% T = varargin{:};
inline void cat(@T@_IO v, @T@_I v1)
{ v.insert(v.end(), v1.begin(), v1.end()); }
//%---------------------

// get unique elements from a vector
//% tem('uniq_elm', { 'vecInt' });
//%---------------------
//% T = varargin{:};
inline void uniq_elm(@T@_IO v)
{
    Long N = v.size(), n = 0; // already done
    for (Long i = 0; i < N; ++i) {
        Bool repeat = false;
        for (Long j = 0; j < n; ++j) {
            if (v[i] == v[j]) {
                repeat = true; break;
            }
        }
        if (!repeat) {
            v[n] = v[i];
            ++n;
        }
    }
    v.resize(n);
}
//%---------------------

// get all unique rows from a matrix
//% tem('uniq_rows', {
//% 'CmatInt' 'CmatInt'
//% 'CmatLlong' 'CmatLlong'
//% 'CmatLlong' 'ScmatLlong'
//% 'CmatDoub' 'CmatDoub' });
//%--------------------
//% [T, T1] = varargin{:};
//% Tcut = cut1_type(T); Tcut1 = cut1_type(T1);
inline void uniq_rows(@T@_O a, @T1@_I a1)
{
    Long k = 0;
    a.resize(a1.n0(), a1.n1());
    for (Long i = 0; i < a1.n0(); ++i) {
        // check repeat
        Bool repeat = false;
//% req('cut1', {T;T1});
        @Tcut1@_c s1 = cut1(a1, i);
        for (Long j = 0; j < k; ++j) {
//% req('v==v', {Tcut,Tcut1});
            if (cut1(a, j) == s1) {
                repeat = true; break;
            }
        }
        if (repeat)
            continue;
//% req('copy(v,v)', {Tcut,Tcut1});
        copy(cut1(a, k), s1);
        ++k;
    }
//% req('resize_cpy', {T});
    resize_cpy(a, k, a1.n1());
}
//%---------------------------

} // namespace slisc
