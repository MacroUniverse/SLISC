#pragma once
#include "copy.h"
#include "scalar_arith.h"
#include "cut.h"

namespace slisc {
// return signed size instead of unsigned
//% tem('size', { 'vecBool'; 'vecInt'; 'vecLlong';
//%    'vecDoub'; 'vecComp'; 'vecStr'; 'vecStr32';
//%    'Str'; 'Str32'; });
//%--------------------------
//% T = varargin{:};
//% Ts = val_t(T);
inline Long size(@T@_I v) { return v.size(); }
//%-------------------------

// sum of absolute values
//% tem('sum_abs_v', { 'Int'; 'Llong'; 'Doub'; 'Comp' });
//%--------------------------
//% T = varargin{:};
//% % decide return type
//% if is_integral(T)
//%     Tr = 'Llong';
//% elseif is_fpt(T) || is_comp(T)
//%     Tr = rm_comp(T);
//% else
//%     error('not implemented (1)!');
//% end
inline @Tr@ sum_abs_v(const @T@ *v, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @Tr@ s = abs(v[0]);
    for (Long i = 1; i < N; ++i)
        s += abs(v[i]);
    return s;
}
//%---------------------------

// sum of absolute values
//% tem('sum_abs', {'VecDoub'; 'SvecInt'; });
//%--------------------------
//% T = varargin{:}; Ts = val_t(T);
//% if is_integral(Ts)
//%     Tr = 'Llong';
//% elseif is_fpt(Ts) || is_comp(Ts)
//%     Tr = rm_comp(Ts);
//% else
//%     error(['sum_abs: not implemented (2): ' T]);
//% end
//% if is_dense(T)
//% req('sum_abs_v', {Ts});
inline @Tr@ sum_abs(@T@_I v)
{ return sum_abs_v(v.p(), v.size()); }
//% else
//%     error('sum_abs: not implemented (3)!');
//% end
//%---------------------------

//% tem('sum_abs_bool', {'VecBool'});
//%--------------------------
//% T = varargin{:};
inline Long sum_abs(@T@_I v)
{
    Long N = v.size();
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    Long s = v[0];
    for (Long i = 1; i < N; ++i)
        s += v[i];
    return s;
}
//%--------------------------

// maximum/minimum element (pointer version)
// max_v(), min_v()
//% tem('max_v', {
//%     'max', 'Doub';
//%     'min', 'Doub';
//% });
//%--------------------------
//% [fun, T] = varargin{:};
//% if strcmp(fun, 'max'), oper = '<'; else, oper = '>'; end
//% if is_real(T) && ~is_Bool(T)
inline @T@ @fun@_v(const @T@ *v, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @T@ s = v[0];
    for (Long i = 1; i < N; ++i) {
        if (s @oper@ v[i])
            s = v[i];
    }
    return s;
}

inline @T@ @fun@_v(const @T@ *v, Long_I N, Long_I step)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @T@ s = v[0];
    for (Long i = step; i < N*step; i += step) {
        if (s @oper@ v[i])
            s = v[i];
    }
    return s;
}

inline @T@ @fun@_v(Long_O ind, const @T@ *v, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @T@ s = v[0];
    for (Long i = 1; i < N; ++i) {
        if (s @oper@ v[i]) {
            s = v[i];  ind = i;
        }
    }
    return s;
}

inline @T@ @fun@_v(Long_O ind, const @T@ *v, Long_I N, Long_I step)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @T@ s = v[0];
    for (Long i = step; i < N*step; i += step) {
        if (s @oper@ v[i]) {
            s = v[i];  ind = i;
        }
    }
    return s;
}
//% else
//%     error(['max_v: not implemented (4): ' T]);
//% end
//%-------------------------

//% tem('max', {'VecDoub'});
//%--------------------------
//% T = varargin{:}; Ts = val_t(T);
//% req('max_v', { 'max', Ts; 'min', Ts });
//% if is_dense(T) && is_real(Ts) && ~is_Bool(Ts)
inline @Ts@ max(@T@_I v)
{ return max_v(v.p(), v.size()); }

inline @Ts@ max(Long_O ind, @T@_I v)
{ return max_v(ind, v.p(), v.size()); }

inline @Ts@ min(@T@_I v)
{ return min_v(v.p(), v.size()); }

inline @Ts@ min(Long_O ind, @T@_I v)
{ return min_v(ind, v.p(), v.size()); }
//% elseif is_Dvec(T) && is_real(Ts) && ~is_Bool(Ts)
inline @Ts@ max(@T@_I v)
{ return max_v(v.p(), v.size(), v.step()); }

inline @Ts@ max(Long_O ind, @T@_I v)
{ return max_v(v.p(), v.size(), v.step()); }

inline @Ts@ min(@T@_I v)
{ return min_v(v.p(), v.size(), v.step()); }

inline @Ts@ min(Long_O ind, @T@_I v)
{ return min_v(v.p(), v.size(), v.step()); }
//% else
//%     error(['max: not implemented (5): ' T]);
//% end
//%-------------------------

//% tem('max_abs_v', { 'Doub' });
//%------------------------------
//% T = varargin{:};
//% Tr = rm_comp(T);
inline @Tr@ max_abs_v(const @T@ *v, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @Tr@ s = abs(v[0]), val;
    for (Long i = 1; i < N; ++i) {
        val = abs(v[i]);
        if (s < val)
            s = val;
    }
    return s;
}

inline @Tr@ max_abs_v(const @T@ *v, Long_I N, Long_I step)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @Tr@ s = abs(v[0]), val;
    for (Long i = step; i < N*step; i += step) {
        val = abs(v[i]);
        if (s < val)
            s = val;
    }
    return s;
}
//%-------------------------

//% tem('max_abs', { 'VecDoub'; 'VecComp'; 'VecInt'; 'CmatComp'; 'MatComp'; });
//%------------------------------
//% T = varargin{:}; Ts = val_t(T);
//% Tr = rm_comp(Ts);
//% req('max_abs_v', { Ts });
//% if is_dense(T)
inline @Tr@ max_abs(@T@_I v)
{
    return max_abs_v(v.p(), v.size());
}
//% elseif is_Dvec(T)
inline @Tr@ max_abs(@T@_I v)
{
    return max_abs_v(v.p(), v.size(), v.step());
}
//% else
//%     error('Not implemented!');
//% end
//%--------------------------

//% tem('mod_vvs', {
//%     'Llong', 'Llong';
//%     'Doub', 'Doub';
//% });
//%--------------------------
//% [T, T1] = varargin{:};
//% Ts1 = val_t(T1);
//% req('mod', {Ts1,Ts1});
inline void mod_vvs(@T@ *v, const @T1@ *v1, @T1@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = mod(v1[i], s);
}
//%-------------------------

//% tem('mod(v,v,s)', { 'VecLlong', 'VecLlong' });
//%--------------------------
//% [T, T1] = varargin{:};
//% [Ts,Ts1] = val_t(T,T1);
//% if ~(is_dense(T) && is_dense(T1) && is_same_major(T, T1) && is_promo(Ts, Ts1))
//%     error('error types!');
//% end
//% req('mod_vvs', {Ts,Ts1});
inline void mod(@T@_O v, @T1@_I v1, @Ts1@_I s)
{
//% req('assert_same_shape', {T, T1});
    assert_same_shape(v, v1);
    mod_vvs(v.p(), v1.p(), s, v.size());
}
//%-------------------------

//% tem('real_v', { 'Comp' });
//%---------------------
//% T = varargin{:}; Tr = rm_comp(T);
inline void real_v(@T@ *v, Long_I N)
{
    @Tr@ *pr = (@Tr@ *)v;
    for (Long i = 1; i < 2*N; i += 2)
        pr[i] = 0;
}

inline void imag_v(@T@ *v, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = imag(v[i]);
}
//%---------------------

//% tem('real_vv', { 'Doub', 'Comp' });
//%---------------------
//% [T, T1] = varargin{:};
inline void real_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = real(v1[i]); 
}

inline void imag_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = imag(v1[i]); 
}
//%---------------------

//% tem('real', { 'VecComp' });
//%---------------------
//% T = varargin{:}; Ts = val_t(T);
//% req('real_v', {Ts});
inline void real(@T@_IO v)
{ real_v(v.p(), v.size()); }

inline void imag(@T@_IO v)
{ imag_v(v.p(), v.size()); }
//%---------------------

//% tem('real(v,v)', { 'VecDoub', 'VecComp' });
//%---------------------
//% [T, T1] = varargin{:};
//% [Ts, Ts1] = val_t(T, T1);
//% req('real_vv', {Ts, Ts1});
inline void real(@T@_O v, @T1@_I v1)
{
//% req('assert_same_shape', {T, T1});
    assert_same_shape(v, v1);
    real_vv(v.p(), v1.p(), v1.size());
}

inline void imag(@T@_O v, @T1@_I v1)
{
    assert_same_shape(v, v1);
    imag_vv(v.p(), v1.p(), v1.size());
}
//%--------------------

//% tem('abs_v', { 'Doub' });
//%---------------------
//% T = varargin{:}; Tr = rm_comp(T);
inline void abs_v(@T@ *v, Long_I N)
{ // not optimized for real numbers
    for (Long i = 0; i < N; ++i)
        v[i] = abs(v[i]);
}
//%---------------------

//% tem('abs_vv', { 'Doub', 'Comp' });
//%---------------------
//% [T, T1] = varargin{:};
inline void abs_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = abs(v1[i]); 
}
//%---------------------

//% tem('abs', { 'SvecComp' });
//%---------------------
//% T = varargin{:}; Ts = val_t(T);
//% req('abs_v', {Ts});
inline void abs(@T@_IO v)
{ abs_v(v.p(), v.size()); }
//%---------------------

//% tem('abs(v,v)', { 'VecDoub', 'VecComp' });
//%---------------------
//% [T, T1] = varargin{:};
inline void abs(@T@_O v, @T1@_I v1)
{
//% req('assert_same_shape', {T, T1});
    assert_same_shape(v, v1);
    abs_vv(v.p(), v1.p(), v1.size());
}
//%--------------------

//% tem('sum_v', { 'Doub' });
//%--------------------
//% T = varargin{:};
//% if is_integral(T)
//%     Tret = 'Llong';
//% else
//%     Tret = T;
//% end
inline @Tret@ sum_v(const @T@ *v, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @Tret@ s = v[0];
    for (Long i = 1; i < N; ++i)
        s += v[i];
    return s;
}

inline @Tret@ prod_v(const @T@ *v, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @Tret@ s = v[0];
    for (Long i = 1; i < N; ++i)
        s *= v[i];
    return s;
}
//%------------------------

//% tem('sum', { 'VecInt'; 'VecLlong';
//%   'VecDoub'; 'VecComp'; 'CmatDoub'; 'CmatComp'; 'MatComp'; });
//%----------------
//% T = varargin{:}; Ts = val_t(T);
//% if is_integral(Ts)
//%     Tret = 'Llong';
//% else
//%     Tret = Ts;
//% end
//% req('sum_v', {Ts});
inline @Tret@ sum(@T@_I v)
{ return sum_v(v.p(), v.size()); }

inline @Tret@ prod(@T@_I v)
{ return prod_v(v.p(), v.size()); }
//%-----------------

//% tem('norm2', { 'VecDoub'; 'VecComp';
//% 'SvecDoub'; 'SvecComp'; 'CmatDoub'; 'CmatComp'; 'MatComp';
//% 'ScmatComp'; 'DcmatComp' });
//%-------------------------------
//% T = varargin{:};
//% Ts = val_t(T);
//% Tr = rm_comp(Ts);
//% if is_dense(T) || is_Dvec(T)
inline @Tr@ norm2(@T@_I v)
{
    Long N = v.size();
    @Tr@ s2 = abs2(v[0]);
    for (Long i = 1; i < N; ++i)
        s2 += abs2(v[i]);
    return s2;
}

inline @Tr@ norm2_dif(@T@_I v, @T@_I v1)
{
    Long N = v.size();
    @Tr@ s2 = abs2(v[0] - v1[0]);
    for (Long i = 1; i < N; ++i)
        s2 += abs2(v[i] - v1[i]);
    return s2;
}
//% elseif is_Dcmat(T)
inline @Tr@ norm2(@T@_I a)
{
    const @Ts@ *p = a.p();
    Long Nr = a.n0(), lda = a.lda();
    @Tr@ s2 = 0;
    for (Long j = 0; j < a.n1(); ++j) {
        for (Long i = 0; i < Nr; ++i)
            s2 += abs2(p[i]);
        p += lda;
    }
    return s2;
}

inline @Tr@ norm2_dif(@T@_I a, @T@_I a1)
{
    const @Ts@ *p = a.p(), *p1 = a1.p();
    Long Nr = a.n0(), lda = a.lda(), lda1 = a1.lda();
    @Tr@ s2 = 0;
    for (Long j = 0; j < a.n1(); ++j) {
        for (Long i = 0; i < Nr; ++i)
            s2 += abs2(p[i] - p1[i]);
        p += lda; p1 += lda1;
    }
    return s2;
}
//% else
//%     error('not implemented (6)!');
//% end
inline @Tr@ norm(@T@_I v)
{
    return sqrt(norm2(v));
}

inline @Tr@ norm_dif(@T@_I v, @T@_I v1)
{
    return sqrt(norm2_dif(v, v1));
}
//%-------------------------

//% tem('resize_cpy', { 'VecInt'; 'VecLlong'; 'VecDoub'; 'VecComp';
//%     'CmatInt'; 'CmatLlong';
//%     'CmatDoub'; 'CmatComp'; 'Cmat3Doub';
//%     'Cmat3Comp';});
//%--------------------------------
//% Tv = varargin{:};
//% T = val_t(Tv);
//% if is_Vec(Tv)
inline void resize_cpy(@Tv@_IO v, Long_I N, @T@_I val = 0)
{
    Long Nold = v.size();
    if (N != Nold) {
        if (Nold == 0) {
//% req('copy(v,s)', {Tv});
            v.resize(N); copy(v, val);
        }
        else if (N == 0)
            v.resize(0);
        else {
            @Tv@ v1(N);
            if (N > Nold) {
//% req('vecset', {T});
                veccpy(v1.p(), v.p(), Nold);
                vecset(v1.p() + Nold, val, N - Nold);
            }
            else // N < Nold
                veccpy(v1.p(), v.p(), N);
            v << v1;
        }
    }
}
//% elseif is_Cmat(Tv) || is_Mat(Tv)
//%     Tsli = cut_type(Tv);
inline void resize_cpy(@Tv@_IO v, Long_I N0, Long_I N1, @T@_I val = 0)
{
    Long N10 = v.n0(), N20 = v.n1(), Nold = N0*N1;
    Long N = N0 * N1;
    if (N0 != N10 || N1 != N20) {
        if (Nold == 0) {
//%     req('copy(v,s)', {Tv});
            v.resize(N0, N1); copy(v, val);
        }
        else if (N == 0)
            v.resize(0, 0);
        else {
            @Tv@ v1(N0, N1); copy(v1, val);
            Long N1min = min(N0, N10), N2min = min(N1, N20);
//%     req('cut', {Tv}); req('copy(v,v)', {Tsli,Tsli});
            copy(cut(v1, 0, N1min, 0, N2min),
                cut(v, 0, N1min, 0, N2min));
            v << v1;
        }
    }
}
//% elseif is_Cmat3(Tv) || is_Mat3(Tv)
//%     Tsli = cut_type(Tv);
inline void resize_cpy(@Tv@_IO v, Long_I N0, Long_I N1, Long_I N2, @T@_I val = 0)
{
    Long N10 = v.n0(), N20 = v.n1(), N30 = v.n2(), Nold = N0*N1;
    Long N = N0 * N1 * N2;
    if (N0 != N10 || N1 != N20 || N2 != N30) {
        if (Nold == 0) {
//% req('copy(v,s)', {Tv});
            v.resize(N0, N1, N2); copy(v, val);
        }
        else if (N == 0)
            v.resize(0, 0, 0);
        else {
            @Tv@ v1(N0, N1, N2); copy(v1, val);
            Long N1min = min(N0, N10), N2min = min(N1, N20), N3min = min(N2, N30);
//%     req('cut', {Tv}); req('copy(v,v)', {Tsli,Tsli});
            copy(cut(v1, 0, N1min, 0, N2min, 0, N3min),
                cut(v, 0, N1min, 0, N2min, 0, N3min));
            v << v1;
        }
    }
}
//% else
//%     error('not implemented (7)');
//% end
//%-------------------------

//% tem('linspace_vss', { 'Doub' });
//%-----------------------
//% T = varargin{:};
inline void linspace_vss(@T@ *v, @T@_I first, @T@_I last, Long N)
{
//% if is_integral(T)
    @T@ delta = (last - first), Nm1 = N-1;
    for (Long i = 0; i < N; ++i)
        v[i] = first + delta * i / Nm1;
//% else
    @T@ delta = (last - first) / (N - 1);
    for (Long i = 0; i < N; ++i)
        v[i] = first + delta * i;
//% end
}
//%-------------------------

//% tem('linspace', { 'VecInt'; 'VecLlong';
//%     'VecDoub'; 'CmatDoub'; 'CmatComp'; 'Cmat4Int'; 'ScmatInt';
//%  'MatInt'; 'MatComp';
//% });
//%---------------------------------
//% Tv = varargin{:};
//% Ts = val_t(Tv);
//% if ~is_dense(Tv)
//%     error('illegal types');
//% end
//% req('linspace_vss', {Ts});
inline void linspace(@Tv@_O v, @Ts@_I first, @Ts@_I last)
{ linspace_vss(v.p(), first, last, v.size()); }
//%-------------------------

//% tem('flip_v', { 'Doub' });
//%---------------------------------
//% T = varargin{:};
inline void flip_v(@T@ *v, Long_I N)
{
    for (Long i = 0; i < N / 2; ++i)
        swap(v[i], v[N - i - 1]);
}
//%---------------------

//% tem('flip_vv', { 'Doub', 'Doub' });
//%---------------------------------
//% [T, T1] = varargin{:};
inline void flip_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[N - i - 1];
}
//%----------------------------

//% tem('flip_vec', { 'VecInt'; 'VecLlong'; 'VecDoub'; 'VecComp'; });
//%---------------------------------
//% Tv = varargin{:}; Ts = val_t(Tv);
//% if is_dense(Tv)
//% req('flip_v', {Ts});
inline void flip(@Tv@_IO v)
{ flip_v(&v[0], v.size()); }
//% else
//%     error('flip: not implemented (8)!');
//% end
//%---------------------------

//% tem('flip(v,v)', { 'VecInt', 'VecInt';
//%    'VecDoub', 'VecDoub' });
//%---------------------------------
//% [T, T1] = varargin{:}; [Ts,Ts1] = val_t(T,T1);
//% if is_dense(T) && is_dense(T1)
inline void flip(@T@_O v, @T1@_I v1)
{
//% req('assert_same_shape', {T, T1});
    assert_same_shape(v, v1);
//% req('flip_vv', {Ts,Ts1});
    flip_vv(v.p(), v1.p(), v1.size());
}
//% else
//%     error('not implemented (9)!');
//% end
//%---------------------------

//% tem('reorder', {
//%     'VecInt', 'VecInt';
//%     'VecLlong', 'VecLlong';
//%     'VecDoub', 'VecLlong';
//%     'SvecComp', 'VecLlong';
//%     'vecStr', 'vecLlong';
//%     'vecStr32', 'vecLlong';
//% });
//%---------------------
//% [Tv, To] = varargin{:};
//% if ~is_vecStr(Tv) && ~is_vecStr32(Tv)
//%     Tu = ['Vec' val_t(Tv)];
//% else
//%     Tu = Tv;
//% end
inline void reorder(@Tv@_O v, @To@_I order)
{
#ifdef SLS_CHECK_SHAPES
    if ((Long)order.size() != (Long)v.size())
        SLS_ERR("wrong shape!");
#endif
    Long N = v.size();
    static @Tu@ u; u.resize(N);
    if (N > (Long)u.size())
        u.resize(max(N, Long(2*u.size())));
    for (Long i = 0; i < N; ++i)
        u[i] = v[order[i]];
    for (Long i = 0; i < N; ++i)
        v[i] = u[i];
}
//%-------------------------

//% tem('trans', { 'CmatInt'; 'CmatDoub'; 'ScmatDoub'; 'DcmatDoub' });
//%--------------------------
//% T = varargin{:};
//% Ts = val_t(T);
inline void trans(@T@_IO v)
{
#ifdef SLS_CHECK_SHAPES
    if (v.n0() != v.n1())
        SLS_ERR("illegal shape!");
#endif
    for (Long i = 0; i < v.n0(); ++i)
        for (Long j = 0; j < i; ++j)
            swap(v(i, j), v(j, i));
}
//%-------------------------

//% tem('trans(v,v)', { 'CmatDoub' 'CmatDoub';
//%    'MatComp' 'CmatComp' });
//%--------------------------
//% [T, T1] = varargin{:};
//% [Ts,Ts1] = val_t(T,T1);
inline void trans(@T@_O v, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPES
    if (v.n0() != v1.n1() || v.n1() != v1.n0())
        SLS_ERR("wrong shape!");
#endif
    for (Long i = 0; i < v.n0(); ++i)
        for (Long j = 0; j < v.n1(); ++j)
            v(i, j) = v1(j, i);
}
//%-------------------------

//% tem('conj_v', {
//%        'Comp';
//% });
//%--------------------------
//% T = varargin{:}; Tr = rm_comp(T);
inline void conj_v(@T@ *v, Long_I N)
{
    @Tr@ *p = (@Tr@ *)v;
    for (Long i = 1; i < 2*N; i += 2)
        p[i] = -p[i];
}
//%--------------------------

//% tem('conj_vv', {
//%        'Comp', 'Comp';
//% });
//%--------------------------
//% [T, T1] = varargin{:};
inline void conj_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = conj(v1[i]);
}
//%-------------------------------

//% tem('conj', { 'CmatComp' });
//%--------------------------
//% T = varargin{:}; Ts = val_t(T);
//% if ~(is_comp(Ts))
//%     error('error types!');
//% end
//% if is_dense(T)
inline void conj(@T@_IO v)
{ conj_v(v.p(), v.size()); }
//% elseif is_Dcmat(T)
inline void conj(@T@_IO v)
{
    for (Long j = 0; j < v.n1(); ++j)
        conj_v(v.p(), v.n0());
}
//% end
//%----------------------------

//% tem('conj(v,v)', { 'CmatComp', 'CmatComp' });
//%--------------------------
//% [T, T1] = varargin{:};
inline void conj(@T@_O v, @T1@_I v1)
{
//% req('assert_same_shape', {T, T1});
    assert_same_shape(v, v1);
    conj_vv(v.p(), v1.p(), v.size());
}
//%----------------------------

//% tem('her(v)', { 'CmatComp' });
//%--------------------------
//% T = varargin{:}; Ts = val_t(T);
//% if ~(is_comp(Ts) && ndim(T) == 2)
//%     error('error types!');
//% end
inline void her(@T@_IO v)
{
#ifdef SLS_CHECK_SHAPES
    if (v.n0() != v.n1()) SLS_ERR("illegal shape!");
#endif
//% req('trans', {T}); req('conj', {T});
    trans(v); conj(v);
}
//%---------------------------

//% tem('her(v,v)', { 'DcmatComp' 'DcmatComp' });
//%--------------------------
//% [T, T1] = varargin{:};
//% req('trans(v,v)', {T,T1}); req('conj', {T});
inline void her(@T@_O v, @T1@_I v1)
{ trans(v, v1); conj(v); }
//%-------------------------

//% tem('plus_equals_vs', { 'Comp', 'Doub' });
//%-------------------
//% [T, Ts] = varargin{:};
//% if ~is_promo(T, Ts)
//%     error('illegal types');
//% end
inline void plus_equals_vs(@T@ *v, @Ts@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] += s;
}

inline void plus_equals_vs(@T@ *v, @Ts@_I s, Long_I N, Long step)
{
    for (Long i = 0; i < N*step; i += step)
        v[i] += s;
}

inline void minus_equals_vs(@T@ *v, @Ts@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] -= s;
}

inline void minus_equals_vs(@T@ *v, @Ts@_I s, Long_I N, Long step)
{
    for (Long i = 0; i < N*step; i += step)
        v[i] -= s;
}

inline void times_equals_vs(@T@ *v, @Ts@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] *= s;
}

inline void times_equals_vs(@T@ *v, @Ts@_I s, Long_I N, Long step)
{
    for (Long i = 0; i < N*step; i += step)
        v[i] *= s;
}
//% if is_integral(T)
inline void divide_equals_vs(@T@ *v, @Ts@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] /= s;
}

inline void divide_equals_vs(@T@ *v, @Ts@_I s, Long_I N, Long_I step)
{
    for (Long i = 0; i < N*step; i += step)
        v[i] /= s;
}
//% elseif is_fpt(Ts) || is_comp(Ts)
inline void divide_equals_vs(@T@ *v, @Ts@_I s, Long_I N)
{
    times_equals_vs(v, (@Ts@)1/s, N);
}

inline void divide_equals_vs(@T@ *v, @Ts@_I s, Long_I N, Long_I step)
{
    times_equals_vs(v, (@Ts@)1/s, N, step);
}
//% else
//%     disp(T); disp(Ts);
//%     error('not implemented (10)');
//% end
//%-------------------------

//% tem('v+=s', {
//%   'VecInt', 'Int';
//%   'VecLlong', 'Llong';
//%   'VecDoub', 'Doub';
//%   'VecComp', 'Doub';
//%   'DcmatComp', 'Doub';
//% });
//%-------------------
//% [T, Ts] = varargin{:}; Tsv = val_t(T);
//% if ~is_promo(Tsv, Ts)
//%     error('illegal type!');
//% end
//% req('plus_equals_vs', {Tsv,Ts});
//% if is_dense(T) && is_scalar(Ts)
inline void operator+=(@T@_IO v, @Ts@_I s)
{ plus_equals_vs(v.p(), s, v.size()); }

inline void operator-=(@T@_IO v, @Ts@_I s)
{ minus_equals_vs(v.p(), s, v.size()); }

inline void operator*=(@T@_IO v, @Ts@_I s)
{ times_equals_vs(v.p(), s, v.size()); }

inline void operator/=(@T@_IO v, @Ts@_I s)
{ divide_equals_vs(v.p(), s, v.size()); }
//% elseif is_Dvec(T) && is_scalar(Ts)
inline void operator+=(@T@_IO v, @Ts@_I s)
{ plus_equals_vs(v.p(), s, v.size(), v.step()); }

inline void operator-=(@T@_IO v, @Ts@_I s)
{ minus_equals_vs(v.p(), s, v.size(), v.step()); }

inline void operator*=(@T@_IO v, @Ts@_I s)
{ times_equals_vs(v.p(), s, v.size(), v.step()); }

inline void operator/=(@T@_IO v, @Ts@_I s)
{ divide_equals_vs(v.p(), s, v.size(), v.step()); }
//% elseif is_Dcmat(T) && is_scalar(Ts)
inline void operator+=(@T@_IO v, @Ts@_I s)
{
    for (Long j = 0; j < v.n1(); ++j)
        plus_equals_vs(&v(0,j), s, v.n0());
}

inline void operator-=(@T@_IO v, @Ts@_I s)
{
    for (Long j = 0; j < v.n1(); ++j)
        minus_equals_vs(&v(0,j), s, v.n0());
}

inline void operator*=(@T@_IO v, @Ts@_I s)
{
    for (Long j = 0; j < v.n1(); ++j)
        times_equals_vs(&v(0,j), s, v.n0());
}

inline void operator/=(@T@_IO v, @Ts@_I s)
{
    for (Long j = 0; j < v.n1(); ++j)
        divide_equals_vs(&v(0,j), s, v.n0());
}
//% elseif is_Dvec(T) && is_scalar(Ts)
inline void operator*=(@T@_IO v, @Ts@_I s)
{
    times_equals_vs(v.p(), s, v.size(), v.step());
}

inline void operator/=(@T@_IO v, @Ts@_I s)
{
    divide_equals_vs(v.p(), s, v.size(), v.step());
}
//% else
//%     disp(T); disp(Ts);
//%     error('not implemented (11)');
//% end
//%-------------------------

//% tem('plus_equals_vv', { 'Comp', 'Doub' });
//%-------------------
//% [T, T1] = varargin{:};
//% if ~is_promo(T, T1)
//%     error('illegal types');
//% end
inline void plus_equals_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] += v1[i];
}

inline void minus_equals_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] -= v1[i];
}

inline void times_equals_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] *= v1[i];
}

inline void divide_equals_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] /= v1[i];
}
//%-------------------------

//% tem('v+=v', { 'DvecComp', 'SvecDoub' });
//%-------------------
//% [T, T1] = varargin{:};
//% Ts = val_t(T); Ts1 = val_t(T1);
//% if is_dense(T) && is_dense(T1) && is_same_major(T, T1)
inline void operator+=(@T@_O &v, @T1@_I v1)
{
//%     req('assert_same_shape', {T, T1});
//%     req('plus_equals_vv', {Ts, Ts1});
    assert_same_shape(v, v1);
    plus_equals_vv(v.p(), v1.p(), v1.size());
}

inline void operator-=(@T@_O &v, @T1@_I v1)
{
    assert_same_shape(v, v1);
    minus_equals_vv(v.p(), v1.p(), v1.size());
}

inline void operator*=(@T@_O &v, @T1@_I v1)
{
    assert_same_shape(v, v1);
    times_equals_vv(v.p(), v1.p(), v1.size());
}

inline void operator/=(@T@_O &v, @T1@_I v1)
{
    assert_same_shape(v, v1);
    divide_equals_vv(v.p(), v1.p(), v1.size());
}
//% elseif ndim(T) == 1 && ndim(T1) == 1
inline void operator+=(@T@_O &v, @T1@_I v1)
{
//% req('assert_same_shape', {T, T1});
    assert_same_shape(v, v1);
    for (Long i = 0; i < v.size(); ++i)
        v[i] += v1[i];
}

inline void operator-=(@T@_O &v, @T1@_I v1)
{
    assert_same_shape(v, v1);
    for (Long i = 0; i < v.size(); ++i)
        v[i] -= v1[i];
}

inline void operator*=(@T@_O &v, @T1@_I v1)
{
    assert_same_shape(v, v1);
    for (Long i = 0; i < v.size(); ++i)
        v[i] *= v1[i];
}

inline void operator/=(@T@_O &v, @T1@_I v1)
{
    assert_same_shape(v, v1);
    for (Long i = 0; i < v.size(); ++i)
        v[i] /= v1[i];
}
//% elseif ndim(T) == 2 && ndim(T1) == 2
inline void operator+=(@T@_O &v, @T1@_I v1) // slow!
{
//% req('assert_same_shape', {T, T1});
    assert_same_shape(v, v1);
    for (Long j = 0; j < v.n1(); ++j)
        for (Long i = 0; i < v.n0(); ++i)
            v(i, j) += v1(i, j);
}

inline void operator-=(@T@_O &v, @T1@_I v1) // slow!
{
    assert_same_shape(v, v1);
    for (Long j = 0; j < v.n1(); ++j)
        for (Long i = 0; i < v.n0(); ++i)
            v(i, j) -= v1(i, j);
}

inline void operator*=(@T@_O &v, @T1@_I v1) // slow!
{
    assert_same_shape(v, v1);
    for (Long j = 0; j < v.n1(); ++j)
        for (Long i = 0; i < v.n0(); ++i)
            v(i, j) *= v1(i, j);
}

inline void operator/=(@T@_O &v, @T1@_I v1) // slow!
{
    assert_same_shape(v, v1);
    for (Long j = 0; j < v.n1(); ++j)
        for (Long i = 0; i < v.n0(); ++i)
            v(i, j) /= v1(i, j);
}
//% else
//%     error('not implemented (12)!');
//% end
//%-------------------------

//% tem('plus_vvs', { 'Comp', 'Doub', 'Imag'; });
//%------------------------------
//% [T, T1, T2] = varargin{:};
//% if ~is_promo(T, T1) || ~is_promo(T, T2)
//%     error('illegal types');
//% end
inline void plus_vvs(@T@ *v, const @T1@ *v1, @T2@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[i] + s;
}

inline void plus_vvs(@T@ *v, const @T1@ *v1, @T2@_I s, Long_I N, Long_I step1, Long_I step2)
{
    for (Long i = 0; i < N; ++i) {
        *v = *v1 + s;
        v += step1; v1 += step2;
    }
}

inline void minus_vvs(@T@ *v, const @T1@ *v1, @T2@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[i] - s;
}

inline void minus_vvs(@T@ *v, const @T1@ *v1, @T2@_I s, Long_I N, Long_I step1, Long_I step2)
{
    for (Long i = 0; i < N; ++i) {
        *v = *v1 - s;
        v += step1; v1 += step2;
    }
}

inline void times_vvs(@T@ *v, const @T1@ *v1, @T2@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[i] * s;
}

inline void times_vvs(@T@ *v, const @T1@ *v1, @T2@_I s, Long_I N, Long_I step1, Long_I step2)
{
    for (Long i = 0; i < N; ++i) {
        *v = *v1 * s;
        v += step1; v1 += step2;
    }
}

//% if is_integral(T1) && is_integral(T2)
inline void divide_vvs(@T@ *v, const @T1@ *v1, @T2@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[i] / s;
}

inline void divide_vvs(@T@ *v, const @T1@ *v1, @T2@_I s, Long_I N, Long_I step1, Long_I step2)
{
    for (Long i = 0; i < N; ++i) {
        *v = *v1 / s;
        v += step1; v1 += step2;
    }
}
//% elseif is_fpt(T2) || is_comp(T2) || is_imag(T2)
inline void divide_vvs(@T@ *v, const @T1@ *v1, @T2@_I s, Long_I N)
{
    @T2@ inv_s = 1./s;
    times_vvs(v, v1, inv_s, N);
}

inline void divide_vvs(@T@ *v, const @T1@ *v1, @T2@_I s, Long_I N, Long_I step, Long_I step1)
{
    @T2@ inv_s = 1./s;
    times_vvs(v, v1, inv_s, N, step, step1);
}
//% else
//%     error(['divide_vvs: not implemented (13): ' T ' ' T1 ' ' T2]);
//% end
//%-------------------------

//% tem('minus_vsv', { 'Comp', 'Doub', 'Comp'; });
//%------------------------------
//% [T, T1, T2] = varargin{:};
//% if ~is_promo(T, T1) || ~is_promo(T, T2)
//%     error('illegal types');
//% end
inline void minus_vsv(@T@ *v, const @T1@ &s, const @T2@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = s - v1[i];
}

inline void minus_vsv(@T@ *v, const @T1@ &s, const @T2@ *v1, Long_I N, Long_I step, Long_I step1)
{
    for (Long i = 0; i < N; ++i) {
        *v = s - *v1;
        v += step; v1 += step1;
    }
}

inline void divide_vsv(@T@ *v, const @T1@ &s, const @T2@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = s / v1[i];
}

inline void divide_vsv(@T@ *v, const @T1@ &s, const @T2@ *v1, Long_I N, Long_I step, Long_I step1)
{
    for (Long i = 0; i < N; ++i) {
        *v = s / *v1;
        v += step; v1 += step1;
    }
}
//%-------------------------

//% tem('plus_vvv', { 'Comp', 'Doub', 'Comp'; });
//%------------------------------
//% [T, T1, T2] = varargin{:};
//% if ~is_promo(T, T1) || ~is_promo(T, T2)
//%     error('illegal type!');
//% end
inline void plus_vvv(@T@ *v, const @T1@ *v1, const @T2@ *v2, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[i] + v2[i];
}

inline void plus_vvv(@T@ *v, const @T1@ *v1, const @T2@ *v2, Long_I N, Long_I step, Long_I step1, Long_I step2)
{
    for (Long i = 0; i < N; ++i) {
        *v = *v1 + *v2;
        v += step; v1 += step1; v2 += step2;
    }
}

inline void minus_vvv(@T@ *v, const @T1@ *v1, const @T2@ *v2, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[i] - v2[i];
}

inline void minus_vvv(@T@ *v, const @T1@ *v1, const @T2@ *v2, Long_I N, Long_I step, Long_I step1, Long_I step2)
{
    for (Long i = 0; i < N; ++i) {
        *v = *v1 - *v2;
        v += step; v1 += step1; v2 += step2;
    }
}

inline void times_vvv(@T@ *v, const @T1@ *v1, const @T2@ *v2, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[i] * v2[i];
}

inline void times_vvv(@T@ *v, const @T1@ *v1, const @T2@ *v2, Long_I N, Long_I step, Long_I step1, Long_I step2)
{
    for (Long i = 0; i < N; ++i) {
        *v = *v1 * *v2;
        v += step; v1 += step1; v2 += step2;
    }
}

inline void divide_vvv(@T@ *v, const @T1@ *v1, const @T2@ *v2, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[i] / v2[i];
}

inline void divide_vvv(@T@ *v, const @T1@ *v1, const @T2@ *v2, Long_I N, Long_I step, Long_I step1, Long_I step2)
{
    for (Long i = 0; i < N; ++i) {
        *v = *v1 / *v2;
        v += step; v1 += step1; v2 += step2;
    }
}
//%-------------------------

//% tem('plus(v,v,s)', { 'VecComp', 'VecComp', 'Doub' });
//%------------------------------
//% [T, T1, Ts2] = varargin{:};
//% [Ts,Ts1] = val_t(T, T1);
//% if ~is_promo(Ts, Ts1) || ~is_promo(Ts, Ts2)
//%     error('illegal types');
//% end
//% if is_dense(T) && is_dense(T1) && is_same_major(T, T1)
inline void plus(@T@_O v, @T1@_I v1, @Ts2@_I s)
{
//% req('assert_same_shape', {T, T1});
//% req('plus_vvs', {Ts, Ts1, Ts2});
    assert_same_shape(v, v1);
    plus_vvs(v.p(), v1.p(), s, v1.size());
}

inline void plus(@T@_O v, @Ts2@_I s, @T1@_I v1)
{ plus(v, v1, s); }

inline void minus(@T@_O v, @T1@_I v1, @Ts2@_I s)
{
    assert_same_shape(v, v1);
    minus_vvs(v.p(), v1.p(), s, v1.size());
}

inline void minus(@T@_O v, @Ts2@_I s, @T1@_I v1)
{
    assert_same_shape(v, v1);
//% req('minus_vsv', {Ts, Ts1, Ts2});
    minus_vsv(v.p(), s, v1.p(), v1.size());
}

inline void times(@T@_O v, @T1@_I v1, @Ts2@_I s)
{
    assert_same_shape(v, v1);
    times_vvs(v.p(), v1.p(), s, v1.size());
}

inline void times(@T@_O v, @Ts2@_I s, @T1@_I v1)
{ times(v, v1, s); }

inline void divide(@T@_O v, @T1@_I v1, @Ts2@_I s)
{
    assert_same_shape(v, v1);
    divide_vvs(v.p(), v1.p(), s, v1.size());
}

inline void divide(@T@_O v, @Ts2@_I s, @T1@_I v1)
{
    assert_same_shape(v, v1);
    divide_vsv(v.p(), s, v1.p(), v1.size());
}
//% elseif ndim(T) == 1 && ndim(T1) == 1
//%     if is_Dvec(T)
//%         step = 'v.step()';
//%     else
//%         step = '1';
//%     end
//%     if is_Dvec(T1)
//%         step1 = 'v1.step()';
//%     else
//%         step1 = '1';
//%     end
inline void plus(@T@_O v, @T1@_I v1, @Ts2@_I s)
{
//% req('assert_same_shape', {T, T1});
    assert_same_shape(v, v1);
    plus_vvs(v.p(), v1.p(), s, v1.size(), @step@, @step1@);
}

inline void plus(@T@_O v, @Ts2@_I s, @T1@_I v1)
{ plus(v, v1, s); }

inline void minus(@T@_O v, @T1@_I v1, @Ts2@_I s)
{
    assert_same_shape(v, v1);
    minus_vvs(v.p(), v1.p(), s, v1.size(), @step@, @step1@);
}

inline void minus(@T@_O v, @Ts2@_I s, @T1@_I v1)
{
    assert_same_shape(v, v1);
    minus_vsv(v.p(), s, v1.p(), v1.size(), @step@, @step1@);
}

inline void times(@T@_O v, @T1@_I v1, @Ts2@_I s)
{
    assert_same_shape(v, v1);
    times_vvs(v.p(), v1.p(), s, v1.size(), @step@, @step1@);
}

inline void times(@T@_O v, @Ts2@_I s, @T1@_I v1)
{ times(v, v1, s); }

inline void divide(@T@_O v, @T1@_I v1, @Ts2@_I s)
{
    assert_same_shape(v, v1);
    divide_vvs(v.p(), v1.p(), s, v1.size(), @step@, @step1@);
}

inline void divide(@T@_O v, @Ts2@_I s, @T1@_I v1)
{
    assert_same_shape(v, v1);
    divide_vsv(v.p(), s, v1.p(), v1.size(), @step@, @step1@);
}
//% elseif is_Dcmat(T) && is_Dcmat(T1)
inline void plus(@T@_O v, @T1@_I v1, @Ts2@_I s)
{
//% req('assert_same_shape', {T, T1});
    assert_same_shape(v, v1);
    @Ts@ *p = v.p(); const @Ts1@ *p1 = v1.p();
    for (Long j = 0; j < v.n1(); ++j) {
        plus_vvs(p, p1, s, v.n0());
        p += v.lda(); p1 += v1.lda();
    }
}

inline void plus(@T@_O v, @Ts2@_I s, @T1@_I v1)
{ plus(v, v1, s); }

inline void minus(@T@_O v, @T1@_I v1, @Ts2@_I s)
{
    assert_same_shape(v, v1);
    @Ts@ *p = v.p(); const @Ts1@ *p1 = v1.p();
    for (Long j = 0; j < v.n1(); ++j) {
        minus_vvs(p, p1, s, v.n0());
        p += v.lda(); p1 += v1.lda();
    }
}

inline void minus(@T@_O v, @Ts2@_I s, @T1@_I v1)
{
    assert_same_shape(v, v1);
    @Ts@ *p = v.p(); const @Ts1@ *p1 = v1.p();
    for (Long j = 0; j < v.n1(); ++j) {
        minus_vsv(p, s, p1, v.n0());
        p += v.lda(); p1 += v1.lda();
    }
}

inline void times(@T@_O v, @T1@_I v1, @Ts2@_I s)
{
    assert_same_shape(v, v1);
    @Ts@ *p = v.p(); const @Ts1@ *p1 = v1.p();
    for (Long j = 0; j < v.n1(); ++j) {
        times_vvs(p, p1, s, v.n0());
        p += v.lda(); p1 += v1.lda();
    }
}

inline void times(@T@_O v, @Ts2@_I s, @T1@_I v1)
{ times(v, v1, s); }

inline void divide(@T@_O v, @T1@_I v1, @Ts2@_I s)
{
    assert_same_shape(v, v1);
    @Ts@ *p = v.p(); const @Ts1@ *p1 = v1.p();
    for (Long j = 0; j < v.n1(); ++j) {
        divide_vvs(p, p1, s, v.n0());
        p += v.lda(); p1 += v1.lda();
    }
}

inline void divide(@T@_O v, const @Ts2@_I s, @T1@_I v1)
{
    assert_same_shape(v, v1);
    @Ts@ *p = v.p(); const @Ts1@ *p1 = v1.p();
    for (Long j = 0; j < v.n1(); ++j) {
        divide_vsv(p, s, p1, v.n0());
        p += v.lda(); p1 += v1.lda();
    }
}
//% end
//%-------------------------

//% tem('plus(v,v,v)', { 'DvecComp', 'SvecComp', 'DvecComp' });
//%------------------------------
//% [T, T1, T2] = varargin{:};
//% Ts = val_t(T); Ts1 = val_t(T1); Ts2 = val_t(T2);
//% if ~is_promo(Ts, Ts1) || ~is_promo(Ts, Ts2)
//%     error('illegal types');
//% end
//% req('assert_same_shape3', {T, T1, T2});
//% req('plus_vvv', {Ts, Ts1, Ts2});
//% if is_dense(T) && is_dense(T1)
inline void plus(@T@_O v, @T1@_I v1, @T2@_I v2)
{
    assert_same_shape(v, v1, v2);
    plus_vvv(v.p(), v1.p(), v2.p(), v.size());
}

inline void minus(@T@_O v, @T1@_I v1, @T2@_I v2)
{
    assert_same_shape(v, v1, v2);
    minus_vvv(v.p(), v1.p(), v2.p(), v.size());
}

inline void times(@T@_O v, @T1@_I v1, @T2@_I v2)
{
    assert_same_shape(v, v1, v2);
    times_vvv(v.p(), v1.p(), v2.p(), v.size());
}

inline void divide(@T@_O v, @T1@_I v1, @T2@_I v2)
{
    assert_same_shape(v, v1, v2);
    divide_vvv(v.p(), v1.p(), v2.p(), v.size());
}
//% elseif ndim(T) == 1 && ndim(T1) == 1
//%     if is_Dvec(T)
//%         step = 'v.step()';
//%     else
//%         step = '1';
//%     end
//%     if is_Dvec(T1)
//%         step1 = 'v1.step()';
//%     else
//%         step1 = '1';
//%     end
//%     if is_Dvec(T2)
//%         step2 = 'v2.step()';
//%     else
//%         step2 = '1';
//%     end
inline void plus(@T@_O v, @T1@_I v1, @T2@_I v2)
{
    assert_same_shape(v, v1, v2);
    plus_vvv(v.p(), v1.p(), v2.p(), v.size(), @step@, @step1@, @step2@);
}

inline void minus(@T@_O v, @T1@_I v1, @T2@_I v2)
{
    assert_same_shape(v, v1, v2);
    minus_vvv(v.p(), v1.p(), v2.p(), v.size(), @step@, @step1@, @step2@);
}

inline void times(@T@_O v, @T1@_I v1, @T2@_I v2)
{
    assert_same_shape(v, v1, v2);
    minus_vvv(v.p(), v1.p(), v2.p(), v.size(), @step@, @step1@, @step2@);
}

inline void divide(@T@_O v, @T1@_I v1, @T2@_I v2)
{
    assert_same_shape(v, v1, v2);
    divide_vvv(v.p(), v1.p(), v2.p(), v.size(), @step@, @step1@, @step2@);
}
//% end
//%--------------------------

//% tem('minus_vv', { 'Comp', 'Doub' });
//%----------------------------------------------------------
//% [T, T1] = varargin{:};
inline void minus_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = -v1[i];
}
//%--------------------------

//% tem('minus(v,v)', {
//%     'VecLlong', 'VecLlong';
//%     'VecDoub', 'VecDoub';
//%     'VecComp', 'VecDoub';
//%     'VecComp', 'VecComp';
//%     'ScmatDoub', 'CmatDoub';
//% });
//%----------------------------------------------------------
//% [T, T1] = varargin{:}; [Ts,Ts1] = val_t(T,T1);
//% if is_dense(T) && is_dense(T1) && is_same_major(T, T1)
inline void minus(@T@_O v, @T1@_I v1)
{
//% req('assert_same_shape', {T, T1});
    assert_same_shape(v, v1);
//% req('minus_vv', {Ts,Ts1});
    minus_vv(v.p(), v1.p(), v1.size());
}
//% else
//%     error('not implemented (14)!');
//% end
//%--------------------------

//% tem('pow_vs', { 'Doub', 'Llong' });
//%----------------------------------------------------------
//% [T, Ts] = varargin{:};
inline void pow_vs(@T@ *v, @Ts@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = pow(v[i], s);
}
//%-------------------------

//% tem('pow(v,s)', { 'VecComp', 'Int' });
//%---------------------
//% [T, Ts] = varargin{:}; Tvs = val_t(T);
//% req('pow_vs', {Tvs, Ts});
inline void pow(@T@_IO v, @Ts@_I s)
{ pow_vs(v.p(), s, v.size()); }
//%-------------------------

//% tem('pow_vvs', { 'Doub', 'Doub', 'Int' });
//%----------------------------------------------------------
//% [T, T1, Ts] = varargin{:};
inline void pow_vvs(@T@ *v, const @T1@ *v1, @Ts@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = pow(v1[i], s);
}
//%-------------------------

//% tem('pow(v,v,s)', { 'VecDoub', 'VecDoub', 'Int' });
//%---------------------
//% [T, T1, Ts] = varargin{:};
inline void pow(@T@_O v, @T1@_I v1, @Ts@_I s)
{
//% req('assert_same_shape', {T, T1});
    assert_same_shape(v, v1);
    pow_vvs(v.p(), v1.p(), s, v1.size());
}
//%-------------------------

//% tem('dot_vv', { 'Doub', 'Comp' });
//%----------------------------------------------------------
//% [T1, T2] = varargin{:};
//% T = promo_type(T1, T2);
inline @T@ dot_vv(const @T1@ *v1, const @T2@ *v2, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
//% if is_comp(T1)
    @T@ s = conj(v1[0]) * v2[0];
//% else
    @T@ s = v1[0] * v2[0];
//% end
    for (Long i = 1; i < N; ++i) {
//% if is_comp(T1)
        s += conj(v1[i]) * v2[i];
//% else
        s += v1[i] * v2[i];
//% end
    }
    return s;
}
//%-------------------------

//% tem('dot', { 'Cmat3Comp', 'Cmat3Doub' });
//%---------------------
//% [T1, T2] = varargin{:};
//% [Ts1,Ts2] = val_t(T1,T2);
//% T = promo_type(Ts1, Ts2);
inline @T@ dot(@T1@_I v1, @T2@_I v2)
{
//% req('assert_same_shape', {T1, T2});
    assert_same_shape(v1, v2);
//% if is_dense(T1) && is_dense(T2)
//%     req('dot_vv', {Ts1,Ts2});
    return dot_vv(v1.p(), v2.p(), v2.size());
//% elseif ndim(T1) == 1
    @T@ sum = 0;
    for (Long i = 0; i < v1.size(); ++i)
        sum += conj(v1[i]) * v2[i];
    return sum;
//% elseif ndim(T1) == 2
    @T@ sum = 0;
    for (Long i = 0; i < v1.n0(); ++i)
        for (Long j = 0; j < v1.n1(); ++j)
                sum += conj(v1(i,j)) * v2(i,j);
    return sum;
//% elseif ndim(T1) == 3
    @T@ sum = 0;
    for (Long i = 0; i < v1.n0(); ++i)
        for (Long j = 0; j < v1.n1(); ++j)
            for (Long k = 0; k < v1.n2(); ++k)
                sum += conj(v1(i,j,k)) * v2(i,j,k);
    return sum;
//% else
//%   error('not implemented (15)!');
//% end
}
//%-------------------------

//% tem('cumsum_vv', { 'Doub', 'Doub' });
//%---------------------
//% [T, T1] = varargin{:};
inline void cumsum_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    v[0] = v1[0];
    for (Long i = 1; i < N; ++i)
        v[i] = v[i - 1] + v1[i];
}
//%-------------------------

//% tem('cumsum', { 'VecDoub', 'VecDoub' });
//%---------------------
//% [T, T1] = varargin{:};
//% req('cumsum_vv', {val_t(T), val_t(T1)});
inline void cumsum(@T@_O v, @T1@_I v1)
{
//% req('assert_same_shape', {T, T1});
    assert_same_shape(v, v1);
    cumsum_vv(v.p(), v1.p(), v1.size());
}
//%-------------------------

// matrix-vector multiplication, not optimized
//% tem('mul(v,m,v)', { 'DvecComp' 'ScmatDoub' 'DvecComp';
//% 'VecQdoub' 'CmatQdoub' 'VecQdoub' });
//%-------------------------------
//% [T,T1,T2] = varargin{:};
//% [Ts,Ts1,Ts2] = val_t(T,T1,T2);
//% if ~(is_promo(Ts, Ts1) && is_promo(Ts, Ts2));
//%     error('illegal type!');
//% end
//% if ndim(T) ~= 1 || ndim(T1) ~= 2 || ndim(T2) ~= 1
//%     error('illegal dim!');
//% end
inline void mul(@T@_O y, @T1@_I a, @T2@_I x)
{
    Long Nr = a.n0(), Nc = a.n1();
#ifdef SLS_CHECK_SHAPES
    if (Nc != x.size() || y.size() != Nr)
        SLS_ERR("illegal shape!");
#endif
//% if is_rmajor(T1)
    for (Long i = 0; i < Nr; ++i) {
        y[i] = a(i, 0) * x[0];
        for (Long j = 1; j < Nc; ++j)
            y[i] += a(i, j) * x[j];
    }
//% else
    for (Long i = 0; i < Nr; ++i)
        y[i] = a(i, 0) * x[0];
    for (Long j = 1; j < Nc; ++j) {
        for (Long i = 0; i < Nr; ++i)
            y[i] += a(i, j) * x[j];
    }
//% end
}

// y = alpha*A*x + beta*y
// algorithm: y = alpha*(A*x + beta/alpha *y)
inline void mul(@T@_IO y, @T1@_I a, @T2@_I x, @Ts1@_I alpha, @Ts@_I beta)
{
    Long Nr = a.n0(), Nc = a.n1();
#ifdef SLS_CHECK_SHAPES
    if (Nc != x.size() || y.size() != Nr)
        SLS_ERR("illegal shape!");
#endif
    // y = beta/alpha *y
    if (beta == 0) {
        for (Long i = 0; i < Nr; ++i)
            y[i] = 0;
    }
    else {
        @Ts@ b_a = beta/alpha;
        if (b_a != 1) {
            for (Long i = 0; i < Nr; ++i)
                y[i] *= b_a;
        }
    }
    // y += A*x
//% if is_rmajor(T1)
    for (Long i = 0; i < Nr; ++i) {
        for (Long j = 0; j < Nc; ++j)
            y[i] += a(i, j) * x[j];
    }
//% else
    for (Long j = 0; j < Nc; ++j) {
        for (Long i = 0; i < Nr; ++i)
            y[i] += a(i, j) * x[j];
    }
//% end
    // y *= alpha
    if (alpha != 1) {
        for (Long i = 0; i < Nr; ++i)
            y[i] *= alpha;
    }
}
//%-------------------------

//% tem('mul(v,v,m)', { 'VecComp', 'VecDoub', 'MatComp' });
//%-------------------------------
//% [T,T1,T2] = varargin{:};
//% [Ts,Ts1,Ts2] = val_t(T,T1,T2);
//% if ~(is_promo(Ts, Ts1) && is_promo(Ts, Ts2));
//%     error('illegal type!');
//% end
//% if ndim(T) ~= 1 || ndim(T1) ~= 1 || ndim(T2) ~= 2
//%     error('illegal dim!');
//% end
inline void mul(@T@_O &y, @T1@_I x, @T2@_I a)
{
    Long Nr_a = a.n0(), Nc_a = a.n1();
#ifdef SLS_CHECK_SHAPES
    if (x.size() != a.n0() || y.size() != Nc_a)
        SLS_ERR("illegal shape!");
#endif
//% req('vecset', {Ts});
    vecset(y.p(), 0, Nc_a);
    for (Long j = 0; j < Nc_a; ++j) {
        for (Long i = 0; i < Nr_a; ++i)
            y[j] += x[i] * a(i, j);
    }
}
//%-----------------------------

//% tem('mul(m,m,m)', { 'CmatComp', 'CmatComp', 'CmatDoub' });
//%-------------------------------
//% [T,T1,T2] = varargin{:};
//% if ndim(T) == 2 && ndim(T1) == 2 && ndim(T2) == 2
inline void mul(@T@_O y, @T1@_I a, @T2@_I x)
{
    Long Nr_a = a.n0(), Nc_a = a.n1(), Nc_x = x.n1();
#ifdef SLS_CHECK_SHAPES
    if (a.n1() != x.n0() || y.n0() != Nr_a || y.n1() != Nc_x)
        SLS_ERR("illegal shape!");
#endif
//% req('vecset', {val_t(T)});
    vecset(y.p(), 0, Nr_a*Nc_x);
    for (Long i = 0; i < Nr_a; ++i) {
        for (Long j = 0; j < Nc_x; ++j) {
            for (Long k = 0; k < Nc_a; ++k)
                y(i, j) += a(i, k) * x(k, j);
        }
    }
}
//% else
//%     error('not implemented (16)');
//% end
//%-------------------------

// matrix-vector multiplication
//% tem('mul_gen', { 'VecDoub', 'CmatDoub', 'SvecDoub';
//%    'VecDoub', 'CmatDoub', 'VecDoub' });
//%------------------------------------
//% [Ty, Ta, Tx] = varargin{:};
//% Tsy = val_t(Ty); Tsa = val_t(Ta); Tsx = val_t(Tx);
//% if is_dense_vec(Ty)
//%     incy =  '1';
//% else
//%     incy = 'y.step()';
//% end
//% if is_dense_mat(Ta)
//%     lda = 'a.n0()';
//% else
//%     lda = 'a.lda()';
//% end
//% if is_dense_vec(Tx)
//%     incx = '1';
//% else
//%     incx = 'x.step()';
//% end
//% if is_cmajor(Ta)
//%     layout = 'CblasColMajor';
//% else
//%     layout = 'CblasRowMajor';
//% end
// y = alpha*A*x + beta*y
inline void mul_gen(@Ty@_O &y, @Ta@_I a, @Tx@_I x, @Tsa@_I alpha = 1, @Tsa@_I beta = 0)
{
#ifdef SLS_CHECK_SHAPES
    if (x.size() != a.n1() || y.size() != a.n0())
        SLS_ERR("wrong shape!");
#endif
#ifdef SLS_USE_CBLAS
//% if is_Float(Tsy) && is_Float(Tsa) && is_Float(Tsx)
    cblas_sgemv(@layout@, CblasNoTrans, a.n0(), a.n1(), alpha, a.p(),
        @lda@, x.p(), @incx@, beta, y.p(), @incy@);
//% elseif is_Doub(Tsy) && is_Doub(Tsa) && is_Doub(Tsx)
    cblas_dgemv(@layout@, CblasNoTrans, a.n0(), a.n1(), alpha, a.p(),
        @lda@, x.p(), @incx@, beta, y.p(), @incy@);
//% elseif is_Comp(Tsy) && is_Comp(Tsa) && is_Comp(Tsx)
    cblas_zgemv(@layout@, CblasNoTrans, a.n0(), a.n1(), &alpha, a.p(),
        @lda@, x.p(), @incx@, &beta, y.p(), @incy@);
//% elseif is_Comp(Tsy) && is_Doub(Tsa) && is_Comp(Tsx)
    // do real part
    cblas_dgemv(@layout@, CblasNoTrans, a.n0(), a.n1(), alpha, a.p(),
        @lda@, (@Tsa@*)x.p(), 2*@incx@, beta, (@Tsa@*)y.p(), 2*@incy@);
    // do imag part
    cblas_dgemv(@layout@, CblasNoTrans, a.n0(), a.n1(), alpha, a.p(),
        @lda@, (@Tsa@*)x.p()+1, 2*@incx@, beta, (@Tsa@*)y.p()+1, 2*@incy@);
//% else
//%     error('not implemented (17)!');
//% end
#else
//% req('mul(v,m,v)', {Ty, Ta, Tx});
    mul(y, a, x, alpha, beta);
#endif
}
//%-------------------------

//% tem('mul_sym', { 'VecComp', 'CmatDoub', 'VecComp' });
//%--------------------------------
//% [Ty, Ta, Tx] = varargin{:};
//% Tsy = val_t(Ty); Tsa = val_t(Ta); Tsx = val_t(Tx);
//% if is_dense_vec(Ty)
//%     incy =  '1';
//% else
//%     incy = 'y.step()';
//% end
//% if is_dense_mat(Ta)
//%     lda = 'a.n0()';
//% else
//%     lda = 'a.lda()';
//% end
//% if is_dense_vec(Tx)
//%     incx = '1';
//% else
//%     incx = 'x.step()';
//% end
//% if is_cmajor(Ta)
//%     layout = 'CblasColMajor';
//% else
//%     layout = 'CblasRowMajor';
//% end
// y = alpha*A*x + beta*y
inline void mul_sym(@Ty@_IO &y, @Ta@_I a, @Tx@_I x, @Tsa@_I alpha = 1, @Tsa@_I beta = 0)
{
#ifdef SLS_CHECK_SHAPES
    if (x.size() != a.n1() || y.size() != a.n0() || x.size() != y.size())
        SLS_ERR("wrong shape!");
#endif
#ifdef SLS_USE_CBLAS
//% if is_Float(Tsy) && is_Float(Tsa) && is_Float(Tsx)
    cblas_ssymv(@layout@, CblasUpper, a.n0(), alpha, a.p(),
        @lda@, x.p(), @incx@, beta, y.p(), @incy@);
//% elseif is_Doub(Tsy) && is_Doub(Tsa) && is_Doub(Tsx)
    cblas_dsymv(@layout@, CblasUpper, a.n0(), alpha, a.p(),
        @lda@, x.p(), @incx@, beta, y.p(), @incy@);
//% elseif is_Comp(Tsy) && is_Comp(Tsa) && is_Comp(Tsx)
    cblas_zsymv(@layout@, CblasUpper, a.n0(), &alpha, a.p(),
        @lda@, x.p(), @incx@, &beta, y.p(), @incy@);
//% elseif is_Comp(Tsy) && is_Doub(Tsa) && is_Comp(Tsx)
    // do real part
    cblas_dsymv(@layout@, CblasUpper, a.n0(), alpha, a.p(),
        @lda@, (@Tsa@*)x.p(), 2*@incx@, beta, (@Tsa@*)y.p(), 2*@incy@);
    // do imag part
    cblas_dsymv(@layout@, CblasUpper, a.n0(), alpha, a.p(),
        @lda@, (@Tsa@*)x.p()+1, 2*@incx@, beta, (@Tsa@*)y.p()+1, 2*@incy@);
//% else
//%     error('not implemented (18)!');
//% end
#else
//% req('mul(v,m,v)', {Ty, Ta, Tx});
    mul(y, a, x, alpha, beta);
#endif
}
//%--------------------------------

//% tem('mul_gen(m,m,m)', { 'ScmatComp', 'ScmatDoub', 'CmatComp' });
//%--------------------------------
//% [Ty, Ta, Tx] = varargin{:};
//% Tsy = val_t(Ty); Tsa = val_t(Ta); Tsx = val_t(Tx);
inline void mul_gen(@Ty@_O y, @Ta@_I a, @Tx@_I &x)
{
#ifdef SLS_CHECK_SHAPES
    if (a.n1() != x.n0() || y.n0() != a.n0() || y.n1() != x.n1())
        SLS_ERR("illegal shape!");
#endif
#ifdef SLS_USE_CBLAS
//% if is_Doub(Tsy) && is_Doub(Tsa) && is_Doub(Tsx)
    cblas_dgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, a.n0(), x.n1(), a.n1(), 1, (Doub*)a.p(), a.n0(), (Doub*)x.p(), a.n1(), 0, (Doub*)y.p(), a.n0());
//% elseif is_Comp(Tsy) && is_Comp(Tsa) && is_Comp(Tsx)
        Comp alpha(1,0), beta(0,0);
        cblas_zgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, a.n0(), x.n1(), a.n1(), &alpha, a.p(), a.n0(), x.p(), a.n1(), &beta, y.p(), a.n0());
//% else
        SLS_WARN("not implemented with cBLAS, using slow version");
        mul(y, a, x);
//% end
#else
//% req('mul(m,m,m)', {Ty, Ta, Tx});
    mul(y, a, x);
#endif
}
//%--------------------------------

// concatinate std::vector
//% tem('cat_vec', {'vecInt'; 'vecLong'; 'vecStr'; 'vecStr32';});
//%---------------------
//% T = varargin{:};
inline void cat(@T@_IO v, @T@_I v1)
{ v.insert(v.end(), v1.begin(), v1.end()); }
//%---------------------

// get unique elements from a vector
//% tem('uniq_elm', { 'vecInt' });
//%---------------------
//% T = varargin{:};
inline void uniq_elm(@T@_IO v)
{
    Long N = v.size(), n = 0; // already done
    for (Long i = 0; i < N; ++i) {
        Bool repeat = false;
        for (Long j = 0; j < n; ++j) {
            if (v[i] == v[j]) {
                repeat = true; break;
            }
        }
        if (!repeat) {
            v[n] = v[i];
            ++n;
        }
    }
    v.resize(n);
}
//%---------------------

// get all unique rows from a matrix
//% tem('uniq_rows', { 'CmatDoub', 'CmatDoub' });
//%--------------------
//% [T, T1] = varargin{:};
//% Tcut = cut1_type(T); Tcut1 = cut1_type(T1);
inline void uniq_rows(@T@_O a, @T1@_I a1)
{
    Long k = 0;
    a.resize(a1.n0(), a1.n1());
    for (Long i = 0; i < a1.n0(); ++i) {
        // check repeat
        Bool repeat = false;
//% req('cut1', {T;T1});
        @Tcut1@_c s1 = cut1(a1, i);
        for (Long j = 0; j < k; ++j) {
//% req('v==v', {Tcut,Tcut1});
            if (cut1(a, j) == s1) {
                repeat = true; break;
            }
        }
        if (repeat)
            continue;
//% req('copy(v,v)', {Tcut,Tcut1});
        copy(cut1(a, k), s1);
        ++k;
    }
//% req('resize_cpy', {T});
    resize_cpy(a, k, a1.n1());
}
//%---------------------------

} // namespace slisc
