#pragma once
#include "copy.h"
#include "scalar_arith.h"
#include "cut.h"

namespace slisc {
// return signed size instead of unsigned
//% types = {'vecBool'; 'vecChar'; 'vecInt'; 'vecLlong'; 'vecDoub';
//%  'Str'; 'Str32'; 'vecStr'; 'vecStr32';};
//%--------------------------
//% T = varargin{:};
inline Long size(@T@_I v)
{
    return v.size();
}
//%-------------------------

// sum of absolute values
//% types = {'Char'; 'Int'; 'Llong'; 'Float'; 'Doub'; 'Ldoub';
//%          'Fcomp'; 'Comp'; 'Lcomp'};
//%--------------------------
//% T = varargin{:};
//% % decide return type
//% if is_integral(T)
//%     Tr = 'Llong';
//% elseif is_fpt(T) || is_comp(T)
//%     Tr = rm_comp(T);
//% else
//%     error('not implemented!');
//% end
inline @Tr@ sum_abs_v(const @T@ *v, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @Tr@ s = abs(v[0]);
    for (Long i = 1; i < N; ++i)
        s += abs(v[i]);
    return s;
}
//%---------------------------

// sum of absolute values
//% types = list_dense_contain();
//%--------------------------
//% T = varargin{:}; Ts = value_type(T);
//% if is_integral(Ts)
//%     Tr = 'Llong';
//% elseif is_fpt(Ts) || is_comp(Ts)
//%     Tr = rm_comp(Ts);
//% else
//%     error(['sum_abs: not implemented: ' T]);
//% end
//% if is_dense(T)
inline @Tr@ sum_abs(@T@_I v)
{
    return sum_abs_v(v.p(), v.size());
}
//% else
//%     error('sum_abs: not implemented!');
//% end
//%---------------------------

//% types = {'VecBool';};
//%--------------------------
//% T = varargin{:};
inline Long sum_abs(@T@_I v)
{
    Long N = v.size();
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    Long s = v[0];
    for (Long i = 1; i < N; ++i)
        s += v[i];
    return s;
}
//%--------------------------

// maximum/minimum element (pointer version)
// max_v(), min_v()
//% types = {
//%     'max', 'Char', '<';   'min', 'Char', '>';
//%     'max', 'Int', '<';    'min', 'Int', '>';
//%     'max', 'Llong', '<';  'min', 'Llong', '>';
//%     'max', 'Float', '<';   'min', 'Float', '>';
//%     'max', 'Doub', '<';   'min', 'Doub', '>';
//%     'max', 'Ldoub', '<';  'min', 'Ldoub', '>';
//% };
//%--------------------------
//% [fun, T, oper] = varargin{:};
//% if is_real(T) && ~is_Bool(T)
inline @T@ @fun@_v(const @T@ *v, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @T@ s = v[0];
    for (Long i = 1; i < N; ++i) {
        if (s @oper@ v[i])
            s = v[i];
    }
    return s;
}

inline @T@ @fun@_v(const @T@ *v, Long_I N, Long_I step)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @T@ s = v[0];
    for (Long i = step; i < N*step; i += step) {
        if (s @oper@ v[i])
            s = v[i];
    }
    return s;
}

inline @T@ @fun@_v(Long_O ind, const @T@ *v, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @T@ s = v[0];
    for (Long i = 1; i < N; ++i) {
        if (s @oper@ v[i]) {
            s = v[i];  ind = i;
        }
    }
    return s;
}

inline @T@ @fun@_v(Long_O ind, const @T@ *v, Long_I N, Long_I step)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @T@ s = v[0];
    for (Long i = step; i < N*step; i += step) {
        if (s @oper@ v[i]) {
            s = v[i];  ind = i;
        }
    }
    return s;
}
//% else
//%     error(['max_v: not implemented: ' T]);
//% end
//%-------------------------

//% types = list_contain_dense_real();
//%--------------------------
//% T = varargin{:}; Ts = value_type(T);
//% if is_dense(T) && is_real(Ts) && ~is_Bool(Ts)
inline @Ts@ max(@T@_I v)
{ return max_v(v.p(), v.size()); }

inline @Ts@ max(Long_O ind, @T@_I v)
{ return max_v(ind, v.p(), v.size()); }

inline @Ts@ min(@T@_I v)
{ return min_v(v.p(), v.size()); }

inline @Ts@ min(Long_O ind, @T@_I v)
{ return min_v(ind, v.p(), v.size()); }
//% elseif is_Dvec(T) && is_real(Ts) && ~is_Bool(Ts)
inline @Ts@ max(@T@_I v)
{ return max_v(v.p(), v.size(), v.step()); }

inline @Ts@ max(Long_O ind, @T@_I v)
{ return max_v(v.p(), v.size(), v.step()); }

inline @Ts@ min(@T@_I v)
{ return min_v(v.p(), v.size(), v.step()); }

inline @Ts@ min(Long_O ind, @T@_I v)
{ return min_v(v.p(), v.size(), v.step()); }
//% else
//%     error(['max: not implemented: ' T]);
//% end
//%-------------------------

//% types = {
//%     'Int'; 'Llong'; 'Float'; 'Doub'; 'Comp';
//% };
//%------------------------------
//% T = varargin{:};
//% Tr = rm_comp(T);
inline @Tr@ max_abs_v(const @T@ *v, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @Tr@ s = abs(v[0]), val;
    for (Long i = 1; i < N; ++i) {
        val = abs(v[i]);
        if (s < val)
            s = val;
    }
    return s;
}

inline @Tr@ max_abs_v(const @T@ *v, Long_I N, Long_I step)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @Tr@ s = abs(v[0]), val;
    for (Long i = step; i < N*step; i += step) {
        val = abs(v[i]);
        if (s < val)
            s = val;
    }
    return s;
}
//%-------------------------

//% types = {
//%     'VecInt'; 'VecLlong'; 'VecFloat'; 'VecDoub'; 'VecComp';
//%     'MatComp'; 'CmatDoub'; 'CmatComp'; 'Cmat3Doub'; 'Cmat3Comp';
//%     'DvecDoub'; 'DvecComp'; 'SvecComp';
//% };
//%------------------------------
//% T = varargin{:}; Tr = rm_comp(value_type(T));
//% if is_dense(T)
inline @Tr@ max_abs(@T@_I v)
{
    return max_abs_v(v.p(), v.size());
}
//% elseif is_Dvec(T)
inline @Tr@ max_abs(@T@_I v)
{
    return max_abs_v(v.p(), v.size(), v.step());
}
//% else
//%     error('Not implemented!');
//% end
//%--------------------------

//% types = {
//%     'Char', 'Char';
//%     'Int', 'Int';
//%     'Llong', 'Llong';
//%     'Doub', 'Doub';
//% };
//%--------------------------
//% [T, T1] = varargin{:};
//% Ts1 = value_type(T1);
inline void mod_vvs(@T@ *v, const @T1@ *v1, @Ts1@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = mod(v1[i], s);
}

inline void mod_vs(@T1@ *v, @Ts1@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = mod(v[i], s);
}
//%-------------------------

//% types = {
//%     'VecInt', 'VecInt', 'Int';
//%     'VecLlong', 'VecLlong', 'Llong';
//% };
//%--------------------------
//% [T, T1] = varargin{:};
//% Ts = value_type(T);
//% Ts1 = value_type(T1);
//% if ~(is_dense(T) && is_dense(T1) && is_same_major(T, T1) && is_promo(Ts, Ts1))
//%     error('error types!');
//% end
inline void mod(@T@_O v, @T1@_I v1, @Ts1@_I s)
{
@same_shape('v', 'v1')@
    mod_vvs(v.p(), v1.p(), s, v.size());
}

inline void mod(@T1@_O v, @Ts1@_I s)
{
    mod_vs(v.p(), s, v.size());
}
//%-------------------------

//% types = {
//%     'Fcomp'; 'Comp'; 'Lcomp';
//% };
//%---------------------
//% T = varargin{:}; Tr = rm_comp(T);
inline void real_v(@T@ *v, Long_I N)
{
    @Tr@ *pr = (@Tr@ *)v;
    for (Long i = 1; i < 2*N; i += 2)
        pr[i] = 0;
}

inline void imag_v(@T@ *v, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = imag(v[i]);
}
//%---------------------

//% types = {
//%     'Doub', 'Comp';
//%     'Comp', 'Comp';
//% };
//%---------------------
//% [T, T1] = varargin{:};
inline void real_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = real(v1[i]); 
}

inline void imag_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = imag(v1[i]); 
}
//%---------------------

//% types = {
//%     'VecComp';
//% };
//%---------------------
//% T = varargin{:};
inline void real(@T@_IO v)
{
    real_v(v.p(), v.size());
}

inline void imag(@T@_IO v)
{
    imag_v(v.p(), v.size());
}
//%---------------------

//% types = {
//%     'VecDoub', 'VecComp';
//%     'VecComp', 'VecComp';
//% };
//%---------------------
//% [T, T1] = varargin{:};
inline void real(@T@_O v, @T1@_I v1)
{
@same_shape('v', 'v1')@
    real_vv(v.p(), v1.p(), v1.size());
}

inline void imag(@T@_O v, @T1@_I v1)
{
@same_shape('v', 'v1')@
    imag_vv(v.p(), v1.p(), v1.size());
}
//%--------------------

//% types = {
//%     'Int'; 'Llong'; 'Doub'; 'Fcomp'; 'Comp'; 'Lcomp';
//% };
//%---------------------
//% T = varargin{:}; Tr = rm_comp(T);
inline void abs_v(@T@ *v, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = abs(v[i]);
}
//%---------------------

//% types = {
//%     'Llong', 'Llong'; 
//%     'Doub', 'Doub'; 
//%     'Doub', 'Comp';
//%     'Comp', 'Comp';
//% };
//%---------------------
//% [T, T1] = varargin{:};
inline void abs_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = abs(v1[i]); 
}
//%---------------------

//% types = {
//%     'VecDoub'; 'VecComp';
//% };
//%---------------------
//% T = varargin{:};
inline void abs(@T@_IO v)
{
    abs_v(v.p(), v.size());
}
//%---------------------

//% types = {
//%     'VecDoub', 'VecDoub';
//%     'VecDoub', 'VecComp';
//%     'VecComp', 'VecComp';
//% };
//%---------------------
//% [T, T1] = varargin{:};
inline void abs(@T@_O v, @T1@_I v1)
{
@same_shape('v', 'v1')@
    abs_vv(v.p(), v1.p(), v1.size());
}
//%--------------------

//% types = {'Bool'; 'Char'; 'Int'; 'Llong'; 'Doub'; 'Comp';};
//%--------------------
//% T = varargin{:};
//% if is_integral(T)
//%     Tret = 'Llong';
//% else
//%     Tret = T;
//% end
inline @Tret@ sum_v(const @T@ *v, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @Tret@ s = v[0];
    for (Long i = 1; i < N; ++i)
        s += v[i];
    return s;
}
//%------------------------

//% types = {'Char'; 'Int'; 'Llong'; 'Doub'; 'Comp';};
//%--------------------
//% T = varargin{:};
//% if is_integral(T)
//%     Tret = 'Llong';
//% else
//%     Tret = T;
//% end
inline @Tret@ prod_v(const @T@ *v, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @Tret@ s = v[0];
    for (Long i = 1; i < N; ++i)
        s *= v[i];
    return s;
}
//%------------------------

//% types = {'VecChar'; 'VecInt'; 'VecLlong';
//%     'VecDoub'; 'SvecDoub'; 'MatComp';
//%     'CmatDoub'; 'CmatComp';};
//%----------------
//% T = varargin{:};
//% Ts = value_type(T);
//% if is_integral(Ts)
//%     Tret = 'Llong';
//% else
//%     Tret = Ts;
//% end
inline @Tret@ sum(@T@_I v)
{
    return sum_v(v.p(), v.size());
}

inline @Tret@ prod(@T@_I v)
{
    return prod_v(v.p(), v.size());
}
//%-----------------

//% types = {'VecDoub'; 'VecComp'; 'MatDoub'; 'MatComp';
//%     'CmatDoub'; 'CmatComp'; 'Cmat3Doub';
//%     'Cmat3Comp'; 'SvecDoub'; 'SvecComp'; 'DvecDoub'; 'DvecComp'; 'ScmatDoub'; 'DcmatComp';
//% };
//%-------------------------------
//% T = varargin{:};
//% Ts = value_type(T);
//% Tr = rm_comp(Ts);
//% if is_dense(T) || is_Dvec(T)
inline @Tr@ norm2(@T@_I v)
{
    Long N = v.size();
    @Tr@ s2 = abs2(v[0]);
    for (Long i = 1; i < N; ++i)
        s2 += abs2(v[i]);
    return s2;
}
//% elseif is_Dcmat(T)
inline @Tr@ norm2(@T@_I a)
{
    const @Ts@ *p = a.p();
    Long Nr = a.n1(), lda = a.lda();
    @Tr@ s2 = 0;
    for (Long j = 0; j < a.n2(); ++j) {
        for (Long i = 0; i < Nr; ++i)
            s2 += abs2(p[i]);
        p += lda;
    }
    return s2;
}
//% else
//%     error('not implemented!');
//% end
inline @Tr@ norm(@T@_I v)
{
    return sqrt(norm2(v));
}
//%-------------------------

//% types = {
//%     'VecChar'; 'VecInt'; 'VecLlong';
//%     'VecFloat'; 'VecDoub'; 'VecLdoub';
//%     'VecFcomp'; 'VecComp'; 'VecLcomp';
//%     'CmatChar'; 'CmatInt'; 'CmatLlong';
//%     'CmatFloat'; 'CmatDoub'; 'CmatLdoub';
//%     'Cmat3Float'; 'Cmat3Doub'; 'Cmat3Ldoub';
//%     'Cmat3Fcomp'; 'Cmat3Comp'; 'Cmat3Lcomp';
//% };
//%--------------------------------
//% Tv = varargin{:};
//% T = value_type(Tv);
//% if is_Vec(Tv)
inline void resize_cpy(@Tv@_IO v, Long_I N, @T@_I val = 0)
{
    Long N0 = v.size();
    if (N != N0) {
        if (N0 == 0) {
            v.resize(N); copy(v, val);
        }
        else if (N == 0)
            v.resize(0);
        else {
            @Tv@ v1(N);
            if (N > N0) {
                veccpy(v1.p(), v.p(), N0);
                vecset(v1.p() + N0, val, N - N0);
            }
            else // N < N0
                veccpy(v1.p(), v.p(), N);
            v << v1;
        }
    }
}
//% elseif is_Cmat(Tv) || is_Mat(Tv)
//%     Tsli = cut_type(Tv);
inline void resize_cpy(@Tv@_IO v, Long_I N1, Long_I N2, @T@_I val = 0)
{
    Long N10 = v.n1(), N20 = v.n2(), N0 = N1*N2;
    Long N = N1 * N2;
    if (N1 != N10 || N2 != N20) {
        if (N0 == 0) {
            v.resize(N1, N2); copy(v, val);
        }
        else if (N == 0)
            v.resize(0, 0);
        else {
            @Tv@ v1(N1, N2); copy(v1, val);
            Long N1min = min(N1, N10), N2min = min(N2, N20);
            copy(cut(v1, 0, N1min, 0, N2min),
                cut(v, 0, N1min, 0, N2min));
            v << v1;
        }
    }
}
//% elseif is_Cmat3(Tv) || is_Mat3(Tv)
inline void resize_cpy(@Tv@_IO v, Long_I N1, Long_I N2, Long_I N3, @T@_I val = 0)
{
    Long N10 = v.n1(), N20 = v.n2(), N30 = v.n3(), N0 = N1*N2;
    Long N = N1 * N2 * N3;
    if (N1 != N10 || N2 != N20 || N3 != N30) {
        if (N0 == 0) {
            v.resize(N1, N2, N3); copy(v, val);
        }
        else if (N == 0)
            v.resize(0, 0, 0);
        else {
            @Tv@ v1(N1, N2, N3); copy(v1, val);
            Long N1min = min(N1, N10), N2min = min(N2, N20), N3min = min(N3, N30);
            copy(cut(v1, 0, N1min, 0, N2min, 0, N3min),
                cut(v, 0, N1min, 0, N2min, 0, N3min));
            v << v1;
        }
    }
}
//% else
//%     error('not implemented');
//% end
//%-------------------------

//% types = {'Char'; 'Int'; 'Llong'; 'Doub'; 'Comp';};
//%-----------------------
//% T = varargin{:};
inline void linspace_vss(@T@ *v, @T@_I first, @T@_I last, Long N)
{
//% if is_integral(T)
    @T@ delta = (last - first), Nm1 = N-1;
    for (Long i = 0; i < N; ++i)
        v[i] = first + delta * i / Nm1;
//% else
    @T@ delta = (last - first) / (N - 1);
    for (Long i = 0; i < N; ++i)
        v[i] = first + delta * i;
//% end
}
//%-------------------------

//% types = {'VecChar'; 'VecInt'; 'VecLlong'; 'VecDoub'; 'VecComp'; 'MatInt';
//%     'MatComp'; 'CmatInt'; 'CmatLlong'; 'CmatDoub'; 'CmatComp';
//%     'Cmat3Int'; 'Cmat3Doub'; 'Cmat3Comp'; 'Cmat4Int'; 'Cmat4Doub'; 'Cmat4Comp'; 'ScmatInt';
//% };
//%---------------------------------
//% Tv = varargin{:};
//% Ts = value_type(Tv);
//% if ~is_dense(Tv)
//%     error('illegal types');
//% end
inline void linspace(@Tv@_O v, @Ts@_I first, @Ts@_I last)
{
    linspace_vss(v.p(), first, last, v.size());
}
//%-------------------------

//% types = {
//%     'Char'; 'Int'; 'Llong'; 'Doub'; 'Comp';
//% };
//%---------------------------------
//% T = varargin{:};
inline void flip_v(@T@ *v, Long_I N)
{
    for (Long i = 0; i < N / 2; ++i)
        swap(v[i], v[N - i - 1]);
}
//%---------------------

//% types = {
//%     'Char', 'Char';
//%     'Int', 'Int';
//%     'Llong', 'Llong';
//%     'Doub', 'Doub';
//%     'Comp', 'Comp';
//% };
//%---------------------------------
//% [T, T1] = varargin{:};
inline void flip_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[N - i - 1];
}
//%----------------------------

//% types = {
//%     'VecChar'; 'VecInt'; 'VecLlong'; 'VecDoub'; 'VecComp';
//% };
//%---------------------------------
//% Tv = varargin{:};
//% Ts = value_type(Tv);
//% if is_dense(Tv)
inline void flip(@Tv@_IO v)
{
    flip_v(v.p(), v.size());
}
//% else
//%     error('not implemented!');
//% end
//%---------------------------

//% types = {
//%     'VecChar', 'VecChar';
//%     'VecInt', 'VecInt';
//%     'VecLlong', 'VecLlong';
//%     'VecDoub', 'VecDoub';
//%     'VecComp', 'VecComp';
//% };
//%---------------------------------
//% [T, T1] = varargin{:};
//% if is_dense(T) && is_dense(T1)
inline void flip(@T@_O v, @T1@_I v1)
{
@same_shape('v', 'v1')@
    flip_vv(v.p(), v1.p(), v1.size());
}
//% else
//%     error('not implemented!');
//% end
//%---------------------------

//% types = {
//%     'VecInt', 'VecLlong';
//%     'VecLlong', 'VecLlong';
//%     'VecDoub', 'VecLlong';
//%     'SvecChar', 'VecLlong';
//%     'SvecInt', 'VecLlong';
//%     'SvecLlong', 'VecLlong';
//%     'SvecDoub', 'VecLlong';
//%     'SvecComp', 'VecLlong';
//%     'vecLlong', 'VecLlong';
//%     'vecStr', 'VecLlong';
//%     'vecStr', 'vecLlong';
//%     'vecStr32', 'VecLlong';
//%     'vecStr32', 'vecLlong';
//%     };
//%---------------------
//% [Tv, To] = varargin{:};
//% if ~is_vecStr(Tv) && ~is_vecStr32(Tv)
//%     Tu = ['Vec' value_type(Tv)];
//% else
//%     Tu = Tv;
//% end
inline void reorder(@Tv@_O v, @To@_I order)
{
#ifdef SLS_CHECK_SHAPES
    if ((Long)order.size() != (Long)v.size())
        SLS_ERR("wrong shape!");
#endif
    Long N = v.size();
    static @Tu@ u; u.resize(N);
    if (N > (Long)u.size())
        u.resize(max(N, Long(2*u.size())));
    for (Long i = 0; i < N; ++i)
        u[i] = v[order[i]];
    for (Long i = 0; i < N; ++i)
        v[i] = u[i];
}
//%-------------------------

//% types = {'CmatDoub'; 'CmatComp';
//%     'MatComp'; 'DcmatDoub'; 'DcmatComp'};
//%--------------------------
//% T = varargin{:};
inline void trans(@T@_IO v)
{
#ifdef SLS_CHECK_SHAPES
    if (v.n1() != v.n2())
        SLS_ERR("illegal shape!");
#endif
    for (Long i = 0; i < v.n1(); ++i)
        for (Long j = 0; j < i; ++j)
            swap(v(i, j), v(j, i));
}
//%-------------------------

//% types = {
//%        'CmatLlong' 'CmatLlong';
//%        'CmatDoub' 'CmatDoub';
//%        'MatComp' 'CmatComp';
//%        'CmatComp' 'CmatComp';
//%        'CmatComp' 'MatComp';
//%     'ScmatDoub' 'ScmatDoub';
//%     'ScmatComp' 'ScmatComp';
//%        'DcmatLlong' 'DcmatLlong';
//%        'DcmatDoub' 'DcmatDoub';
//%        'DcmatComp' 'DcmatComp';
//% };
//%--------------------------
//% [T, T1] = varargin{:};
inline void trans(@T@_O v, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPES
    if (v.n1() != v1.n2() || v.n2() != v1.n1())
        SLS_ERR("wrong shape!");
#endif
    for (Long i = 0; i < v.n1(); ++i)
        for (Long j = 0; j < v.n2(); ++j)
            v(i, j) = v1(j, i);
}
//%-------------------------

//% types = {
//%        'Comp';
//% };
//%--------------------------
//% T = varargin{:}; Tr = rm_comp(T);
inline void conj_v(@T@ *v, Long_I N)
{
    @Tr@ *p = (@Tr@ *)v;
    for (Long i = 1; i < 2*N; i += 2)
        p[i] = -p[i];
}
//%--------------------------

//% types = {
//%        'Comp', 'Comp';
//% };
//%--------------------------
//% [T, T1] = varargin{:};
inline void conj_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = conj(v1[i]);
}
//%-------------------------------

//% types = {
//%        'VecComp'; 'CmatComp'; 'MatComp'; 'DcmatComp';
//% };
//%--------------------------
//% T = varargin{:}; Ts = value_type(T);
//% if ~(is_comp(Ts))
//%     error('error types!');
//% end
//% if is_dense(T)
inline void conj(@T@_IO v)
{
    conj_v(v.p(), v.size());
}
//% elseif is_Dcmat(T)
inline void conj(@T@_IO v)
{
    for (Long j = 0; j < v.n2(); ++j)
        conj_v(v.p(), v.n1());
}
//% end
//%----------------------------

//% types = {
//%        'CmatComp', 'CmatComp';
//%        'MatComp', 'MatComp';
//% };
//%--------------------------
//% [T, T1] = varargin{:};
inline void conj(@T@_O v, @T1@_I v1)
{
@same_shape('v', 'v1')@
    conj_vv(v.p(), v1.p(), v.size());
}
//%----------------------------

//% types = {
//%        'CmatComp'; 'MatComp';
//% };
//%--------------------------
//% T = varargin{:}; Ts = value_type(T);
//% if ~(is_comp(Ts) && ndim(T) == 2)
//%     error('error types!');
//% end
inline void her(@T@_IO v)
{
#ifdef SLS_CHECK_SHAPES
    if (v.n1() != v.n2()) SLS_ERR("illegal shape!");
#endif
    trans(v); conj(v);
}
//%---------------------------

//% types = {
//%        'MatComp' 'CmatComp';
//%        'CmatComp' 'MatComp';
//%        'CmatComp' 'CmatComp';
//%        'DcmatComp' 'DcmatComp';
//% };
//%--------------------------
//% [T, T1] = varargin{:};
inline void her(@T@_O v, @T1@_I v1)
{
    trans(v, v1); conj(v);
}
//%-------------------------

//% types = {
//%     'Char', 'Char';
//%     'Int', 'Int';
//%     'Doub', 'Doub';
//%     'Comp', 'Comp';
//%     };
//%-------------------
//% [T, Ts] = varargin{:};
//% if ~is_promo(T, Ts)
//%     error('illegal types');
//% end
inline void plus_equals_vs(@T@ *v, @Ts@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] += s;
}

inline void plus_equals_vs(@T@ *v, @Ts@_I s, Long_I N, Long step)
{
    for (Long i = 0; i < N*step; i += step)
        v[i] += s;
}

inline void minus_equals_vs(@T@ *v, @Ts@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] -= s;
}

inline void minus_equals_vs(@T@ *v, @Ts@_I s, Long_I N, Long step)
{
    for (Long i = 0; i < N*step; i += step)
        v[i] -= s;
}

inline void times_equals_vs(@T@ *v, @Ts@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] *= s;
}

inline void times_equals_vs(@T@ *v, @Ts@_I s, Long_I N, Long step)
{
    for (Long i = 0; i < N*step; i += step)
        v[i] *= s;
}

//% if is_integral(T)
inline void divide_equals_vs(@T@ *v, @Ts@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] /= s;
}

inline void divide_equals_vs(@T@ *v, @Ts@_I s, Long_I N, Long_I step)
{
    for (Long i = 0; i < N*step; i += step)
        v[i] /= s;
}
//% elseif is_fpt(Ts) || is_comp(Ts)
inline void divide_equals_vs(@T@ *v, @Ts@_I s, Long_I N)
{
    times_equals_vs(v, 1/s, N);
}

inline void divide_equals_vs(@T@ *v, @Ts@_I s, Long_I N, Long_I step)
{
    times_equals_vs(v, 1/s, N, step);
}
//% else
//%     disp(T); disp(Ts);
//%     error('not implemented');
//% end
//%-------------------------

//% types = {
//%     'VecChar', 'Char';
//%     'VecInt', 'Int';
//%     'VecDoub', 'Doub';
//%     'VecComp', 'Comp';
//%     'CmatChar', 'Char';
//%     'CmatInt', 'Int';
//%     'CmatDoub', 'Doub';
//%     'CmatComp', 'Doub';
//%     'CmatComp', 'Comp';
//%     'ScmatComp', 'Doub';
//%     'ScmatComp', 'Comp';
//%     'SvecDoub', 'Doub';
//%     'SvecComp', 'Doub';
//%     'DvecComp', 'Doub';
//%     'DvecComp', 'Comp';
//%     'DcmatDoub', 'Doub';
//%     'DcmatComp', 'Doub';
//%     'DcmatComp', 'Comp';
//%     'Cmat3Doub', 'Doub';
//%     'Cmat3Comp', 'Doub';
//%     'Cmat3Comp', 'Comp';
//% };
//%-------------------
//% [T, Ts] = varargin{:};
//% if is_dense(T) && is_scalar(Ts)
inline void operator+=(@T@_IO v, @Ts@_I s)
{
    plus_equals_vs(v.p(), s, v.size());
}

inline void operator-=(@T@_IO v, @Ts@_I s)
{
    minus_equals_vs(v.p(), s, v.size());
}

inline void operator*=(@T@_IO v, @Ts@_I s)
{
    times_equals_vs(v.p(), s, v.size());
}

inline void operator/=(@T@_IO v, @Ts@_I s)
{
    divide_equals_vs(v.p(), s, v.size());
}
//% elseif is_Dvec(T) && is_scalar(Ts)
inline void operator+=(@T@_IO v, @Ts@_I s)
{
    plus_equals_vs(v.p(), s, v.size(), v.step());
}

inline void operator-=(@T@_IO v, @Ts@_I s)
{
    minus_equals_vs(v.p(), s, v.size(), v.step());
}

inline void operator*=(@T@_IO v, @Ts@_I s)
{
    times_equals_vs(v.p(), s, v.size(), v.step());
}

inline void operator/=(@T@_IO v, @Ts@_I s)
{
    divide_equals_vs(v.p(), s, v.size(), v.step());
}
//% elseif is_Dcmat(T) && is_scalar(Ts)
inline void operator+=(@T@_IO v, @Ts@_I s)
{
    for (Long j = 0; j < v.n2(); ++j)
        plus_equals_vs(&v(0,j), s, v.n1());
}

inline void operator-=(@T@_IO v, @Ts@_I s)
{
    for (Long j = 0; j < v.n2(); ++j)
        minus_equals_vs(&v(0,j), s, v.n1());
}

inline void operator*=(@T@_IO v, @Ts@_I s)
{
    for (Long j = 0; j < v.n2(); ++j)
        times_equals_vs(&v(0,j), s, v.n1());
}

inline void operator/=(@T@_IO v, @Ts@_I s)
{
    for (Long j = 0; j < v.n2(); ++j)
        divide_equals_vs(&v(0,j), s, v.n1());
}
//% elseif is_Dvec(T) && is_scalar(Ts)
inline void operator*=(@T@_IO v, @Ts@_I s)
{
    times_equals_vs(v.p(), s, v.size(), v.step());
}

inline void operator/=(@T@_IO v, @Ts@_I s)
{
    divide_equals_vs(v.p(), s, v.size(), v.step());
}
//% else
//%     disp(T); disp(Ts);
//%     error('not implemented');
//% end
//%-------------------------

//% types = {
//%     'Char', 'Char';
//%     'Int', 'Int';
//%     'Doub', 'Doub';
//%     'Comp', 'Doub';
//%     'Comp', 'Comp';
//%     };
//%-------------------
//% [T, T1] = varargin{:};
//% if ~is_promo(T, T1)
//%     error('illegal types');
//% end
inline void plus_equals_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] += v1[i];
}

inline void minus_equals_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] -= v1[i];
}

inline void times_equals_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] *= v1[i];
}

inline void divide_equals_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] /= v1[i];
}
//%-------------------------

//% types = {
//%     'VecChar', 'VecChar';
//%     'VecInt', 'VecInt';
//%     'VecDoub', 'VecDoub';
//%     'VecDoub', 'SvecDoub';
//%     'VecComp', 'VecComp';
//%     'VecComp', 'VecDoub';
//%     'MatDoub', 'MatDoub';
//%     'MatComp', 'MatComp';
//%     'CmatDoub', 'CmatDoub';
//%     'CmatComp', 'CmatComp';
//%     'Cmat3Doub', 'Cmat3Doub';
//%     'Cmat3Comp', 'Cmat3Comp';
//%     'SvecDoub', 'VecDoub';
//%     'SvecDoub', 'SvecDoub';
//%     'SvecComp', 'VecDoub';
//%     'SvecComp', 'SvecComp';
//%     'SvecComp', 'DvecComp';
//%     'ScmatDoub', 'ScmatDoub';
//%     'ScmatComp', 'CmatDoub';
//%     'ScmatComp', 'ScmatDoub';
//%     'ScmatComp', 'ScmatComp';
//%     'DcmatComp', 'DcmatDoub';
//% };
//%-------------------
//% [T, T1] = varargin{:};
//% if is_dense(T) && is_dense(T1) && is_same_major(T, T1)
inline void operator+=(@T@_O &v, @T1@_I v1)
{
@same_shape('v', 'v1')@
    plus_equals_vv(v.p(), v1.p(), v1.size());
}

inline void operator-=(@T@_O &v, @T1@_I v1)
{
@same_shape('v', 'v1')@
    minus_equals_vv(v.p(), v1.p(), v1.size());
}

inline void operator*=(@T@_O &v, @T1@_I v1)
{
@same_shape('v', 'v1')@
    times_equals_vv(v.p(), v1.p(), v1.size());
}

inline void operator/=(@T@_O &v, @T1@_I v1)
{
@same_shape('v', 'v1')@
    divide_equals_vv(v.p(), v1.p(), v1.size());
}
//% elseif ndim(T) == 1 && ndim(T1) == 1
// v += v
inline void operator+=(@T@_O &v, @T1@_I v1)
{
@same_shape('v', 'v1')@
    for (Long i = 0; i < v.size(); ++i)
        v[i] += v1[i];
}

// v -= v
inline void operator-=(@T@_O &v, @T1@_I v1)
{
@same_shape('v', 'v1')@
    for (Long i = 0; i < v.size(); ++i)
        v[i] -= v1[i];
}

// v *= v
inline void operator*=(@T@_O &v, @T1@_I v1)
{
@same_shape('v', 'v1')@
    for (Long i = 0; i < v.size(); ++i)
        v[i] *= v1[i];
}

// v /= v
inline void operator/=(@T@_O &v, @T1@_I v1)
{
@same_shape('v', 'v1')@
    for (Long i = 0; i < v.size(); ++i)
        v[i] /= v1[i];
}
//% elseif ndim(T) == 2 && ndim(T1) == 2
// v += v (slow!)
inline void operator+=(@T@_O &v, @T1@_I v1)
{
@same_shape('v', 'v1')@
    for (Long j = 0; j < v.n2(); ++j)
        for (Long i = 0; i < v.n1(); ++i)
            v(i, j) += v1(i, j);
}

// v -= v (slow!)
inline void operator-=(@T@_O &v, @T1@_I v1)
{
@same_shape('v', 'v1')@
    for (Long j = 0; j < v.n2(); ++j)
        for (Long i = 0; i < v.n1(); ++i)
            v(i, j) -= v1(i, j);
}

// v *= v (slow!)
inline void operator*=(@T@_O &v, @T1@_I v1)
{
@same_shape('v', 'v1')@
    for (Long j = 0; j < v.n2(); ++j)
        for (Long i = 0; i < v.n1(); ++i)
            v(i, j) *= v1(i, j);
}

// v /= v (slow!)
inline void operator/=(@T@_O &v, @T1@_I v1)
{
@same_shape('v', 'v1')@
    for (Long j = 0; j < v.n2(); ++j)
        for (Long i = 0; i < v.n1(); ++i)
            v(i, j) /= v1(i, j);
}
//% else
//%     error('not implemented!');
//% end
//%-------------------------

//% types = {
//%        'Char', 'Char', 'Char';
//%        'Int', 'Int', 'Int';
//%        'Llong', 'Llong', 'Llong';
//%     'Float', 'Float', 'Float';
//%        'Doub', 'Doub', 'Doub';
//%        'Comp', 'Comp', 'Doub';
//%        'Comp', 'Doub', 'Imag';
//%        'Comp', 'Doub', 'Comp';
//%        'Comp', 'Comp', 'Comp';
//% };
//%------------------------------
//% [T, T1, T2] = varargin{:};
//% if ~is_promo(T, T1) || ~is_promo(T, T2)
//%     error('illegal types');
//% end
inline void plus_vvs(@T@ *v, const @T1@ *v1, @T2@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[i] + s;
}

inline void minus_vvs(@T@ *v, const @T1@ *v1, @T2@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[i] - s;
}

inline void times_vvs(@T@ *v, const @T1@ *v1, @T2@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[i] * s;
}

inline void divide_vvs(@T@ *v, const @T1@ *v1, @T2@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[i] / s;
}
//%-------------------------

//% types = {
//%        'Char', 'Char', 'Char';
//%        'Int', 'Int', 'Int';
//%        'Llong', 'Llong', 'Llong';
//%     'Float', 'Float', 'Float';
//%        'Doub', 'Doub', 'Doub';
//%        'Comp', 'Comp', 'Doub';
//%        'Comp', 'Doub', 'Comp';
//%        'Comp', 'Comp', 'Comp';
//% };
//%------------------------------
//% [T, T1, T2] = varargin{:};
//% if ~is_promo(T, T1) || ~is_promo(T, T2)
//%     error('illegal types');
//% end
inline void minus_vsv(@T@ *v, const @T1@ &s, const @T2@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = s - v1[i];
}

inline void divide_vsv(@T@ *v, const @T1@ &s, const @T2@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = s / v1[i];
}
//%-------------------------

//% types = {
//%     'Char', 'Char', 'Char';
//%     'Int', 'Int', 'Int';
//%     'Llong', 'Llong', 'Llong';
//%     'Float', 'Float', 'Float';
//%     'Doub', 'Doub', 'Doub';
//%     'Comp', 'Doub', 'Doub';
//%     'Comp', 'Comp', 'Doub';
//%     'Comp', 'Doub', 'Comp';
//%     'Comp', 'Comp', 'Comp';
//% };
//%------------------------------
//% [T, T1, T2] = varargin{:};
//% if ~is_promo(T, T1) || ~is_promo(T, T2)
//%     error('illegal type!');
//% end
inline void plus_vvv(@T@ *v, const @T1@ *v1, const @T2@ *v2, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[i] + v2[i];
}

inline void minus_vvv(@T@ *v, const @T1@ *v1, const @T2@ *v2, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[i] - v2[i];
}

inline void times_vvv(@T@ *v, const @T1@ *v1, const @T2@ *v2, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[i] * v2[i];
}

inline void divide_vvv(@T@ *v, const @T1@ *v1, const @T2@ *v2, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[i] / v2[i];
}
//%-------------------------

//% types = {
//%        'VecChar', 'VecChar', 'Char';
//%        'VecInt', 'VecInt', 'Int';
//%        'VecLlong', 'VecLlong', 'Llong';
//%        'VecDoub', 'VecDoub', 'Doub';
//%        'VecDoub', 'SvecDoub', 'Doub';
//%        'VecComp', 'VecComp', 'Doub';
//%        'VecComp', 'VecDoub', 'Doub';
//%        'VecComp', 'SvecDoub', 'Doub';
//%        'VecComp', 'SvecDoub', 'Imag';
//%        'SvecDoub', 'SvecDoub', 'Doub';
//%        'SvecDoub', 'VecDoub', 'Doub';
//%        'SvecComp', 'VecComp', 'Doub';
//%        'VecComp', 'VecDoub', 'Comp';
//%        'VecComp', 'VecComp', 'Comp';
//%        'CmatInt', 'CmatInt', 'Int';
//%        'CmatLlong', 'CmatLlong', 'Llong';
//%        'CmatDoub', 'CmatDoub', 'Doub';
//%        'CmatComp', 'CmatComp', 'Doub';
//%        'CmatComp', 'CmatDoub', 'Comp';
//%        'CmatComp', 'CmatComp', 'Comp';
//%        'DcmatComp', 'DcmatComp', 'Doub';
//%        'Cmat3Comp', 'Cmat3Comp', 'Comp';
//%        'Cmat3Comp', 'Cmat3Doub', 'Comp';
//% };
//%------------------------------
//% [T, T1, Ts2] = varargin{:};
//% Ts = value_type(T); Ts1 = value_type(T1);
//% if ~is_promo(Ts, Ts1) || ~is_promo(Ts, Ts2)
//%     error('illegal types');
//% end
//% if is_dense(T) && is_dense(T1) && is_same_major(T, T1)
inline void plus(@T@_O v, @T1@_I v1, @Ts2@_I s)
{
@same_shape('v', 'v1')@
    plus_vvs(v.p(), v1.p(), s, v1.size());
}

inline void plus(@T@_O v, @Ts2@_I s, @T1@_I v1)
{
    plus(v, v1, s);
}

inline void minus(@T@_O v, @T1@_I v1, @Ts2@_I s)
{
@same_shape('v', 'v1')@
    minus_vvs(v.p(), v1.p(), s, v1.size());
}

inline void minus(@T@_O v, @Ts2@_I s, @T1@_I v1)
{
@same_shape('v', 'v1')@
    minus_vsv(v.p(), s, v1.p(), v1.size());
}

inline void times(@T@_O v, @T1@_I v1, @Ts2@_I s)
{
@same_shape('v', 'v1')@
    times_vvs(v.p(), v1.p(), s, v1.size());
}

inline void times(@T@_O v, @Ts2@_I s, @T1@_I v1)
{
    times(v, v1, s);
}

inline void divide(@T@_O v, @T1@_I v1, @Ts2@_I s)
{
@same_shape('v', 'v1')@
    divide_vvs(v.p(), v1.p(), s, v1.size());
}

inline void divide(@T@_O v, @Ts2@_I s, @T1@_I v1)
{
@same_shape('v', 'v1')@
    divide_vsv(v.p(), s, v1.p(), v1.size());
}
//% elseif is_Dcmat(T) && is_Dcmat(T1)
inline void plus(@T@_O v, @T1@_I v1, @Ts2@_I s)
{
@same_shape('v', 'v1')@
    @Ts@ *p = v.p(); const @Ts1@ *p1 = v1.p();
    for (Long j = 0; j < v.n2(); ++j) {
        plus_vvs(p, p1, s, v.n1());
        p += v.lda(); p1 += v1.lda();
    }
}

inline void plus(@T@_O v, @Ts2@_I s, @T1@_I v1)
{
    plus(v, v1, s);
}

inline void minus(@T@_O v, @T1@_I v1, @Ts2@_I s)
{
@same_shape('v', 'v1')@
    @Ts@ *p = v.p(); const @Ts1@ *p1 = v1.p();
    for (Long j = 0; j < v.n2(); ++j) {
        minus_vvs(p, p1, s, v.n1());
        p += v.lda(); p1 += v1.lda();
    }
}

inline void minus(@T@_O v, @Ts2@_I s, @T1@_I v1)
{
@same_shape('v', 'v1')@
    @Ts@ *p = v.p(); const @Ts1@ *p1 = v1.p();
    for (Long j = 0; j < v.n2(); ++j) {
        minus_vsv(p, s, p1, v.n1());
        p += v.lda(); p1 += v1.lda();
    }
}

inline void times(@T@_O v, @T1@_I v1, @Ts2@_I s)
{
@same_shape('v', 'v1')@
    @Ts@ *p = v.p(); const @Ts1@ *p1 = v1.p();
    for (Long j = 0; j < v.n2(); ++j) {
        times_vvs(p, p1, s, v.n1());
        p += v.lda(); p1 += v1.lda();
    }
}

inline void times(@T@_O v, @Ts2@_I s, @T1@_I v1)
{
    times(v, v1, s);
}

inline void divide(@T@_O v, @T1@_I v1, @Ts2@_I s)
{
@same_shape('v', 'v1')@
    @Ts@ *p = v.p(); const @Ts1@ *p1 = v1.p();
    for (Long j = 0; j < v.n2(); ++j) {
        divide_vvs(p, p1, s, v.n1());
        p += v.lda(); p1 += v1.lda();
    }
}

inline void divide(@T@_O v, const @Ts2@_I s, @T1@_I v1)
{
@same_shape('v', 'v1')@
    @Ts@ *p = v.p(); const @Ts1@ *p1 = v1.p();
    for (Long j = 0; j < v.n2(); ++j) {
        divide_vsv(p, s, p1, v.n1());
        p += v.lda(); p1 += v1.lda();
    }
}
//% else
//%     error('not implemented!');
//% end
//%-------------------------

//% types = {
//%        'VecChar', 'VecChar', 'VecChar';
//%        'VecInt', 'VecInt', 'VecInt';
//%        'VecLlong', 'VecLlong', 'VecLlong';
//%        'VecDoub', 'VecDoub', 'VecDoub';
//%        'VecComp', 'VecDoub', 'VecDoub';
//%        'VecComp', 'VecComp', 'VecComp';
//%        'DvecComp', 'SvecComp', 'DvecComp';
//%        'CmatInt', 'CmatInt', 'CmatInt';
//%        'CmatLlong', 'CmatLlong', 'CmatLlong';
//%        'CmatDoub', 'CmatDoub', 'CmatDoub';
//%        'CmatComp', 'CmatDoub', 'CmatDoub';
//%        'CmatComp', 'CmatComp', 'CmatComp';
//% };
//%------------------------------
//% [T, T1, T2] = varargin{:};
//% Ts = value_type(T); Ts1 = value_type(T1); Ts2 = value_type(T2);
//% if ~is_promo(Ts, Ts1) || ~is_promo(Ts, Ts2)
//%     error('illegal types');
//% end
//% if is_dense(T) && is_dense(T1)
inline void plus(@T@_O v, @T1@_I v1, @T2@_I v2)
{
@same_shape('v', 'v1', 'v2')@
    plus_vvv(v.p(), v1.p(), v2.p(), v.size());
}

inline void minus(@T@_O v, @T1@_I v1, @T2@_I v2)
{
@same_shape('v', 'v1', 'v2')@
    minus_vvv(v.p(), v1.p(), v2.p(), v.size());
}

inline void times(@T@_O v, @T1@_I v1, @T2@_I v2)
{
@same_shape('v', 'v1', 'v2')@
    times_vvv(v.p(), v1.p(), v2.p(), v.size());
}

inline void divide(@T@_O v, @T1@_I v1, @T2@_I v2)
{
@same_shape('v', 'v1', 'v2')@
    divide_vvv(v.p(), v1.p(), v2.p(), v.size());
}
//% else
inline void plus(@T@_O v, @T1@_I v1, @T2@_I v2)
{
@same_shape('v', 'v1', 'v2')@
    for (Long i = 0; i < v1.size(); ++i)
        v[i] = v1[i] + v2[i];
}

inline void minus(@T@_O v, @T1@_I v1, @T2@_I v2)
{
@same_shape('v', 'v1', 'v2')@
    for (Long i = 0; i < v1.size(); ++i)
        v[i] = v1[i] - v2[i];
}

inline void times(@T@_O v, @T1@_I v1, @T2@_I v2)
{
@same_shape('v', 'v1', 'v2')@
    for (Long i = 0; i < v1.size(); ++i)
        v[i] = v1[i] * v2[i];
}

inline void divide(@T@_O v, @T1@_I v1, @T2@_I v2)
{
@same_shape('v', 'v1', 'v2')@
    for (Long i = 0; i < v1.size(); ++i)
        v[i] = v1[i] / v2[i];
}
//% end
//%--------------------------

//% types = {
//%     'Int', 'Int';
//%     'Llong', 'Llong';
//%     'Doub', 'Doub';
//%     'Comp', 'Doub';
//%     'Comp', 'Comp';
//% };
//%----------------------------------------------------------
//% [T, T1] = varargin{:};
inline void minus_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = -v1[i];
}
//%--------------------------

//% types = {
//%     'VecInt', 'VecInt';
//%     'VecLlong', 'VecLlong';
//%     'VecDoub', 'VecDoub';
//%     'VecComp', 'VecDoub';
//%     'VecComp', 'VecComp';
//%     'ScmatDoub', 'CmatDoub';
//% };
//%----------------------------------------------------------
//% [T, T1] = varargin{:};
//% if is_dense(T) && is_dense(T1) && is_same_major(T, T1)
inline void minus(@T@_O v, @T1@_I v1)
{
@same_shape('v', 'v1')@
    minus_vv(v.p(), v1.p(), v1.size());
}
//% else
//%     error('not implemented!');
//% end
//%--------------------------

//% types = {
//%     'Int', 'Int';
//%     'Llong', 'Llong';
//%     'Float', 'Float';
//%     'Doub', 'Int';
//%     'Doub', 'Llong';
//%     'Doub', 'Doub';
//%     'Comp', 'Int';
//%     'Comp', 'Llong';
//%     'Comp', 'Doub';
//%     'Comp', 'Comp';  
//% };
//%----------------------------------------------------------
//% [T, Ts] = varargin{:};
inline void pow_vs(@T@ *v, @Ts@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = pow(v[i], s);
}
//%-------------------------

//% types = {
//%     'VecLlong', 'Llong';
//%     'VecDoub', 'Int';
//%     'VecDoub', 'Doub';
//%     'VecComp', 'Int';
//%     'VecComp', 'Doub';
//%     'VecComp', 'Comp';
//% };
//%---------------------
//% [T, Ts] = varargin{:};
inline void pow(@T@_IO v, @Ts@_I s)
{
    pow_vs(v.p(), s, v.size());
}
//%-------------------------

//% types = {
//%     'Int', 'Int', 'Int';
//%     'Llong', 'Llong', 'Llong';
//%     'Float', 'Float', 'Float';
//%     'Doub', 'Doub', 'Int';
//%     'Doub', 'Doub', 'Llong';
//%     'Doub', 'Doub', 'Doub';
//%     'Comp', 'Comp', 'Int';
//%     'Comp', 'Comp', 'Llong';
//%     'Comp', 'Comp', 'Doub';
//%     'Comp', 'Comp', 'Comp';  
//% };
//%----------------------------------------------------------
//% [T, T1, Ts] = varargin{:};
inline void pow_vvs(@T@ *v, const @T1@ *v1, @Ts@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = pow(v1[i], s);
}
//%-------------------------

//% types = {
//%     'VecLlong', 'VecLlong', 'Llong';
//%     'VecDoub', 'VecDoub', 'Int';
//%     'VecDoub', 'VecDoub', 'Llong';
//%     'VecDoub', 'VecDoub', 'Doub';
//%     'VecComp', 'VecComp', 'Int';
//%     'VecComp', 'VecComp', 'Doub';
//%     'VecComp', 'VecComp', 'Comp';
//% };
//%---------------------
//% [T, T1, Ts] = varargin{:};
inline void pow(@T@_O v, @T1@_I v1, @Ts@_I s)
{
@same_shape('v', 'v1')@
    pow_vvs(v.p(), v1.p(), s, v1.size());
}
//%-------------------------

//% types = {
//%     'Int', 'Int';
//%     'Llong', 'Llong';
//%     'Float', 'Float';
//%     'Doub', 'Int';
//%     'Doub', 'Comp';
//%     'Doub', 'Llong';
//%     'Doub', 'Char';
//%     'Doub', 'Doub';
//%     'Comp', 'Int';
//%     'Comp', 'Llong';
//%     'Comp', 'Doub';
//%     'Comp', 'Comp';
//% };
//%----------------------------------------------------------
//% [T1, T2] = varargin{:};
//% T = promo_type(T1, T2);
inline @T@ dot_vv(const @T1@ *v1, const @T2@ *v2, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
//% if is_comp(T1)
    @T@ s = conj(v1[0]) * v2[0];
//% else
    @T@ s = v1[0] * v2[0];
//% end
    for (Long i = 1; i < N; ++i) {
//% if is_comp(T1)
        s += conj(v1[i]) * v2[i];
//% else
        s += v1[i] * v2[i];
//% end
    }
    return s;
}
//%-------------------------

//% types = {
//%     'VecLlong', 'VecLlong';
//%     'VecDoub', 'VecChar';
//%     'VecDoub', 'VecDoub';
//%     'VecDoub', 'SvecComp';
//%     'VecComp', 'VecDoub';
//%     'VecComp', 'VecComp';
//%     'SvecDoub', 'VecDoub';
//%     'SvecDoub', 'SvecDoub';
//%     'SvecDoub', 'SvecComp';
//%     'SvecComp', 'VecComp';
//%     'DvecComp', 'SvecDoub';
//%     'Cmat3Comp', 'Cmat3Comp';
//%     'Cmat3Comp', 'Jcmat3Comp';
//% };
//%---------------------
//% [T1, T2] = varargin{:};
//% Ts1 = value_type(T1); Ts2 = value_type(T2);
//% T = promo_type(Ts1, Ts2);
inline @T@ dot(@T1@_I v1, @T2@_I v2)
{
@same_shape('v1', 'v2')@
//% if is_dense(T1) && is_dense(T2)
    return dot_vv(v1.p(), v2.p(), v2.size());
//% elseif ndim(T1) == 1
    @T@ sum = 0;
    for (Long i = 0; i < v1.size(); ++i)
        sum += conj(v1[i]) * v2[i];
    return sum;
//% elseif ndim(T1) == 2
    @T@ sum = 0;
    for (Long i = 0; i < v1.n1(); ++i)
        for (Long j = 0; j < v1.n2(); ++j)
                sum += conj(v1(i,j)) * v2(i,j);
    return sum;
//% elseif ndim(T1) == 3
    @T@ sum = 0;
    for (Long i = 0; i < v1.n1(); ++i)
        for (Long j = 0; j < v1.n2(); ++j)
            for (Long k = 0; k < v1.n3(); ++k)
                sum += conj(v1(i,j,k)) * v2(i,j,k);
    return sum;
//% else
//%   error('not implemented!');
//% end
}
//%-------------------------

//% types = {
//%     'Int', 'Int';
//%     'Llong', 'Int';
//%     'Llong', 'Llong';
//%     'Doub', 'Doub';
//% };
//%---------------------
//% [T, T1] = varargin{:};
inline void cumsum_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    v[0] = v1[0];
    for (Long i = 1; i < N; ++i)
        v[i] = v[i - 1] + v1[i];
}
//%-------------------------

//% types = {
//%     'VecInt', 'VecInt';
//%     'VecLlong', 'VecInt';
//%     'VecLlong', 'VecLlong';
//%     'VecDoub', 'VecDoub';
//% };
//%---------------------
//% [T, T1] = varargin{:};
inline void cumsum(@T@_O v, @T1@_I v1)
{
@same_shape('v', 'v1')@
    cumsum_vv(v.p(), v1.p(), v1.size());
}
//%-------------------------

//% types = {
//%     'VecDoub' 'CmatDoub' 'VecDoub';
//%     'VecDoub' 'CmatDoub' 'SvecDoub';
//%     'VecInt' 'CmatInt' 'VecInt';
//%     'VecComp' 'CmatComp' 'VecComp';
//%     'VecComp' 'CmatDoub' 'VecComp';
//%     'DvecComp' 'DcmatDoub' 'DvecComp';
//%     'SvecComp' 'ScmatDoub' 'SvecComp';
//%     'SvecComp' 'ScmatDoub' 'DvecComp';
//%     'DvecComp' 'CmatDoub' 'DvecComp';
//%     'DvecComp' 'ScmatDoub' 'SvecComp';
//%     'VecComp' 'MatComp' 'VecDoub';
//%     'VecComp' 'MatComp' 'VecComp';
//%     'VecComp' 'CmatImag' 'VecComp';
//%     'VecComp' 'MatDoub' 'VecComp';
//%     'VecComp' 'ScmatDoub' 'VecComp';
//%     'SvecComp' 'MatDoub' 'VecComp';
//%     'SvecComp' 'ScmatComp' 'SvecComp';
//%     'SvecComp' 'ScmatComp' 'DvecComp';
//%     'SvecComp' 'DcmatComp' 'SvecComp';
//%     'SvecComp' 'DcmatDoub' 'SvecComp';
//%     };
//%-------------------------------
//% [T,T1,T2] = varargin{:};
//% Ts = value_type(T); Ts1 = value_type(T1); Ts2 = value_type(T2);
//% if ~(is_promo(Ts, Ts1) && is_promo(Ts, Ts2));
//%     error('illegal type!');
//% end
//% if ndim(T) ~= 1 || ndim(T1) ~= 2 || ndim(T2) ~= 1
//%     error('illegal dim!');
//% end
inline void mul(@T@_O y, @T1@_I a, @T2@_I x)
{
    Long Nr = a.n1(), Nc = a.n2();
#ifdef SLS_CHECK_SHAPES
    if (Nc != x.size() || y.size() != Nr)
        SLS_ERR("illegal shape!");
#endif
    for (Long i = 0; i < Nr; ++i) {
        y[i] = 0;
        for (Long j = 0; j < Nc; ++j)
            y[i] += a(i, j) * x[j];
    }
}
//%-------------------------

//% types = {
//%     'VecDoub', 'VecDoub', 'MatDoub';
//%     'VecComp', 'VecDoub', 'MatComp';
//%     'VecComp', 'VecComp', 'MatComp';
//% };
//%-------------------------------
//% [T,T1,T2] = varargin{:};
//% Ts = value_type(T); Ts1 = value_type(T1); Ts2 = value_type(T2);
//% if ~(is_promo(Ts, Ts1) && is_promo(Ts, Ts2));
//%     error('illegal type!');
//% end
//% if ndim(T) ~= 1 || ndim(T1) ~= 1 || ndim(T2) ~= 2
//%     error('illegal dim!');
//% end
inline void mul(@T@_O &y, @T1@_I x, @T2@_I a)
{
    Long Nr_a = a.n1(), Nc_a = a.n2();
#ifdef SLS_CHECK_SHAPES
    if (x.size() != a.n1() || y.size() != Nc_a)
        SLS_ERR("illegal shape!");
#endif
    vecset(y.p(), 0, Nc_a);
    for (Long j = 0; j < Nc_a; ++j) {
        for (Long i = 0; i < Nr_a; ++i)
            y[j] += x[i] * a(i, j);
    }
}
//%-----------------------------

//% types = {
//%     'CmatDoub', 'CmatDoub', 'CmatDoub';
//%     'CmatComp', 'CmatComp', 'CmatDoub';
//%     'CmatComp', 'CmatComp', 'CmatComp';
//%     'CmatComp', 'CmatComp', 'MatComp';
//%     'ScmatComp', 'ScmatDoub', 'CmatComp';
//% };
//%-------------------------------
//% [T,T1,T2] = varargin{:};
//% if ndim(T) == 2 && ndim(T1) == 2 && ndim(T2) == 2
inline void mul(@T@_O y, @T1@_I a, @T2@_I x)
{
    Long Nr_a = a.n1(), Nc_a = a.n2(), Nc_x = x.n2();
#ifdef SLS_CHECK_SHAPES
    if (a.n2() != x.n1() || y.n1() != Nr_a || y.n2() != Nc_x)
        SLS_ERR("illegal shape!");
#endif
    vecset(y.p(), 0, Nr_a*Nc_x);
    for (Long i = 0; i < Nr_a; ++i) {
        for (Long j = 0; j < Nc_x; ++j) {
            for (Long k = 0; k < Nc_a; ++k)
                y(i, j) += a(i, k) * x(k, j);
        }
    }
}
//% else
//%     error('not implemented');
//% end
//%-------------------------

// matrix-vector multiplication
//% types = {
//%     'VecDoub', 'CmatDoub', 'VecDoub';
//%     'VecDoub', 'CmatDoub', 'SvecDoub';
//%     'VecComp', 'CmatDoub', 'VecComp';
//%     'VecComp', 'CmatDoub', 'SvecComp';
//%     'VecComp', 'CmatComp', 'VecComp';
//%     'VecComp', 'ScmatDoub', 'VecComp';
//%     'DvecComp', 'DcmatDoub', 'DvecComp';
//%     'DvecComp', 'CmatDoub', 'DvecComp';
//%     'SvecDoub', 'CmatDoub', 'SvecDoub';
//%     'SvecComp', 'ScmatDoub', 'SvecComp';
//%     'SvecComp', 'ScmatComp', 'SvecComp';
//%     'SvecComp', 'ScmatComp', 'DvecComp';
//%     'SvecComp', 'DcmatDoub', 'SvecComp';
//%     'SvecComp', 'ScmatDoub', 'DvecComp';
//%     'SvecComp', 'CmatDoub', 'SvecComp';
//%     'SvecComp', 'CmatComp', 'SvecComp';  
//%     'DvecComp', 'ScmatDoub', 'SvecComp';
//%     };
//%------------------------------------
//% [Ty, Ta, Tx] = varargin{:};
//% Tsy = value_type(Ty); Tsa = value_type(Ta); Tsx = value_type(Tx);
inline void mul_gen(@Ty@_O &y, @Ta@_I a, @Tx@_I x, @Tsa@_I alpha = 1, @Tsa@_I beta = 0)
{
#ifdef SLS_CHECK_SHAPES
    if (x.size() != a.n2() || y.size() != a.n1())
        SLS_ERR("wrong shape!");
#endif
#ifdef SLS_USE_CBLAS
    Long N1 = a.n1(), N2 = a.n2(), lda, incx, incy;
//% if is_dense_vec(Ty)
    incy =  1;
//% else
    incy = y.step();
//% end
//% if is_dense_mat(Ta)
    lda = a.n1();
//% else
    lda = a.lda();
//% end
//% if is_dense_vec(Tx)
    incx = 1;
//% else
    incx = x.step();
//% end
//% if is_cmajor(Ta)
    CBLAS_LAYOUT layout = CblasColMajor;
//% else
    CBLAS_LAYOUT layout = CblasRowMajor;
//% end

//% if is_Float(Tsy) && is_Float(Tsa) && is_Float(Tsx)
    cblas_sgemv(layout, CblasNoTrans, N1, N2, alpha, a.p(),
        lda, x.p(), incx, beta, y.p(), incy);
//% elseif is_Doub(Tsy) && is_Doub(Tsa) && is_Doub(Tsx)
    cblas_dgemv(layout, CblasNoTrans, N1, N2, alpha, a.p(),
        lda, x.p(), incx, beta, y.p(), incy);
//% elseif is_Comp(Tsy) && is_Comp(Tsa) && is_Comp(Tsx)
    cblas_zgemv(layout, CblasNoTrans, N1, N2, &alpha, a.p(),
        lda, x.p(), incx, &beta, y.p(), incy);
//% elseif is_Comp(Tsy) && is_Doub(Tsa) && is_Comp(Tsx)
    // do real part
    cblas_dgemv(layout, CblasNoTrans, N1, N2, alpha, a.p(),
        lda, (@Tsa@*)x.p(), 2*incx, beta, (@Tsa@*)y.p(), 2*incy);
    // do imag part
    cblas_dgemv(layout, CblasNoTrans, N1, N2, alpha, a.p(),
        lda, (@Tsa@*)x.p()+1, 2*incx, beta, (@Tsa@*)y.p()+1, 2*incy);
//% else
//%     error('not implemented!');
//% end
#else
    mul(y, a, x);
#endif
}
//%-------------------------

//% types = {
//%     'VecDoub', 'CmatDoub', 'VecDoub';
//%     'VecComp', 'CmatDoub', 'VecComp';
//%   %  'SvecComp', 'DcmatDoub', 'SvecComp';
//%   %  'DvecComp', 'DcmatDoub', 'DvecComp';
//%     };
//%--------------------------------
//% [Ty, Ta, Tx] = varargin{:};
//% Tsy = value_type(Ty); Tsa = value_type(Ta); Tsx = value_type(Tx);
inline void mul_sym(@Ty@_O &y, @Ta@_I a, @Tx@_I x, @Tsa@_I alpha = 1, @Tsa@_I beta = 0)
{
#ifdef SLS_CHECK_SHAPES
    if (x.size() != a.n2() || y.size() != a.n1() || x.size() != y.size())
        SLS_ERR("wrong shape!");
#endif
#ifdef SLS_USE_CBLAS
    Long N1 = a.n1(), lda, incx, incy;
//% if is_dense_vec(Ty)
    incy =  1;
//% else
    incy = y.step();
//% end
//% if is_dense_mat(Ta)
    lda = a.n1();
//% else
    lda = a.lda();
//% end
//% if is_dense_vec(Tx)
    incx = 1;
//% else
    incx = x.step();
//% end
//% if is_cmajor(Ta)
    CBLAS_LAYOUT layout = CblasColMajor;
//% else
    CBLAS_LAYOUT layout = CblasRowMajor;
//% end

//% if is_Float(Tsy) && is_Float(Tsa) && is_Float(Tsx)
    cblas_ssymv(layout, CblasUpper, N1, alpha, a.p(),
        lda, x.p(), incx, beta, y.p(), incy);
//% elseif is_Doub(Tsy) && is_Doub(Tsa) && is_Doub(Tsx)
    cblas_dsymv(layout, CblasUpper, N1, alpha, a.p(),
        lda, x.p(), incx, beta, y.p(), incy);
//% elseif is_Comp(Tsy) && is_Comp(Tsa) && is_Comp(Tsx)
    cblas_zsymv(layout, CblasUpper, N1, &alpha, a.p(),
        lda, x.p(), incx, &beta, y.p(), incy);
//% elseif is_Comp(Tsy) && is_Doub(Tsa) && is_Comp(Tsx)
    // do real part
    cblas_dsymv(layout, CblasUpper, N1, alpha, a.p(),
        lda, (@Tsa@*)x.p(), 2*incx, beta, (@Tsa@*)y.p(), 2*incy);
    // do imag part
    cblas_dsymv(layout, CblasUpper, N1, alpha, a.p(),
        lda, (@Tsa@*)x.p()+1, 2*incx, beta, (@Tsa@*)y.p()+1, 2*incy);
//% else
//%     error('not implemented!');
//% end
#else
    mul(y, a, x);
#endif
}
//%--------------------------------

//% types = {
//%     'CmatDoub', 'CmatDoub', 'CmatDoub';
//%     'CmatComp', 'CmatComp', 'CmatDoub';
//%     'CmatComp', 'CmatComp', 'CmatComp';
//%     'ScmatComp', 'ScmatDoub', 'CmatComp';
//% };
//%--------------------------------
//% [Ty, Ta, Tx] = varargin{:};
//% Tsy = value_type(Ty); Tsa = value_type(Ta); Tsx = value_type(Tx);
inline void mul_gen(@Ty@_O y, @Ta@_I a, @Tx@_I &x)
{
#ifdef SLS_CHECK_SHAPES
    if (a.n2() != x.n1() || y.n1() != a.n1() || y.n2() != x.n2())
        SLS_ERR("illegal shape!");
#endif
#ifdef SLS_USE_CBLAS
//% if is_Doub(Tsy) && is_Doub(Tsa) && is_Doub(Tsx)
    cblas_dgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, a.n1(), x.n2(), a.n2(), 1, (Doub*)a.p(), a.n1(), (Doub*)x.p(), a.n2(), 0, (Doub*)y.p(), a.n1());
//% elseif is_Comp(Tsy) && is_Comp(Tsa) && is_Comp(Tsx)
        Comp alpha(1,0), beta(0,0);
        cblas_zgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, a.n1(), x.n2(), a.n2(), &alpha, a.p(), a.n1(), x.p(), a.n2(), &beta, y.p(), a.n1());
//% else
        SLS_WARN("not implemented with cBLAS, using slow version");
        mul(y, a, x);
//% end
#else
    mul(y, a, x);
#endif
}
//%--------------------------------

// concatinate std::vector
// get unique elements from a vector
//% types = {'vecInt'; 'vecLong'; 'vecStr'; 'vecStr32';};
//%---------------------
//% T = varargin{:};
inline void operator+=(@T@_IO v, @T@_I v1)
{
    v.insert(v.end(), v1.begin(), v1.end());
}
//%---------------------

// get unique elements from a vector
//% types = {'VecInt'; 'VecLong'; 'vecInt'; 'vecLong';
//%     'vecStr'; 'vecStr32';};
//%---------------------
//% T = varargin{:};
inline void uniq_elm(@T@_IO v)
{
    Long N = v.size(), n = 0; // already done
    for (Long i = 0; i < N; ++i) {
        Bool repeat = false;
        for (Long j = 0; j < n; ++j) {
            if (v[i] == v[j]) {
                repeat = true; break;
            }
        }
        if (!repeat) {
            v[n] = v[i];
            ++n;
        }
    }
    v.resize(n);
}
//%---------------------

// get all unique rows from a matrix
//% types = {
//%     'CmatInt', 'CmatInt';
//%     'CmatLlong', 'ScmatLlong';
//%     'CmatDoub', 'CmatDoub';
//% };
//%--------------------
//% [T, T1] = varargin{:};
//% Tsli1 = cut2_type(T1);
inline void uniq_rows(@T@_O a, @T1@_I a1)
{
    Long k = 0;
    a.resize(a1.n1(), a1.n2());
    for (Long i = 0; i < a1.n1(); ++i) {
        // check repeat
        Bool repeat = false;
        @Tsli1@_c sli1 = cut2(a1, i);
        for (Long j = 0; j < k; ++j) {
            if (cut2(a, j) == sli1) {
                repeat = true; break;
            }
        }
        if (repeat)
            continue;
        copy(cut2(a, k), sli1);
        ++k;
    }
    resize_cpy(a, k, a1.n2());
}
//%---------------------------

//% types = {'Doub'; 'Comp';};
//%-------------------
//% T = varargin{:};
inline void exp_v(@T@ *v, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = exp(v[i]);
}
//%-----------------

//% types = {
//%     'Doub', 'Doub';
//%     'Comp', 'Comp';
//% };
//%-------------------
//% [T, T1] = varargin{:};
inline void exp_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = exp(v1[i]);
}
//%--------------------

//% types = {
//%     'VecDoub'; 'VecComp';
//% };
//%-------------------
//% T = varargin{:};
inline void exp(@T@_IO v)
{
    exp_v(v.p(), v.size());
}
//%--------------------

//% types = {
//%     'VecDoub', 'VecDoub';
//%     'VecComp', 'VecComp';
//% };
//%-------------------
//% [T, T1] = varargin{:};
inline void exp(@T@_O v, @T1@_I v1)
{
@same_shape('v', 'v1')@
    exp_vv(v.p(), v1.p(), v1.size());
}
//%-------------------

} // namespace slisc
