#pragma once
#include "copy.h"
#include "scalar_arith.h"
#include "slice_arith.h"

namespace slisc {

//% types = {'VecInt'; 'VecLlong'; 'VecDoub'; 'Str'; 'Str32'; 'vecStr'; 'vecStr32';};
//%--------------------------
//% T = varargin{:};
inline Long size(@T@_I v)
{
	return v.size();
}
//%-------------------------

//% types = {'Int'; 'Llong'; 'Doub'; 'Comp';};
//%--------------------------
//% T = varargin{:}; Tr = rm_comp(T);
//% if is_integral(T)
inline Llong sum_abs_v(const @T@ *v, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    Llong s = v[0];
    for (Llong i = 1; i < N; ++i)
        s += abs(v[i]);
    return s;
}
//% elseif is_fpt(T) || is_comp(T)
inline @Tr@ sum_abs_v(const @T@ *v, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @Tr@ s = abs(v[0]);
    for (Long i = 1; i < N; ++i)
        s += abs(v[i]);
    return s;
}
//% else
//%     error('not implemented!');
//% end
//%---------------------------

//% types = {
//%     'VecInt'; 'VecLlong'; 'VecDoub'; 'VecComp'; 'SvecInt'; 'SvecDoub'; 'SvecComp';
//% };
//%--------------------------
//% T = varargin{:}; Ts = contain_type(T);
//% if is_integral(T)
//%     Tret = 'Llong';
//% else
//%     Tret = rm_comp(Ts);
//% end
//% if is_dense(T)
inline @Tret@ sum_abs(@T@_I v)
{
    return sum_abs_v(v.ptr(), v.size());
}
//% else
//%     error('not implemented!');
//% end
//%---------------------------

//% types = {
//%     'Int'; 'Llong'; 'Doub';
//% };
//%--------------------------
//% T = varargin{:};
//% if is_real(T) && ~is_Bool(T)
inline @T@ max_v(const @T@ *v, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @T@ s = v[0];
    for (Long i = 1; i < N; ++i) {
        if (s < v[i])
            s = v[i];
    }
    return s;
}

inline @T@ max_v(const @T@ *v, Long_I N, Long_I step)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @T@ s = v[0];
    for (Long i = step; i < N*step; i += step) {
        if (s < v[i])
            s = v[i];
    }
    return s;
}
//% else
//%     error('not implemented!');
//% end
//%-------------------------

//% types = {
//%     'VecInt'; 'VecLlong'; 'VecDoub'; 'SvecLlong';
//% };
//%--------------------------
//% T = varargin{:}; Ts = contain_type(T);
//% if is_dense(T) && is_real(Ts) && ~is_Bool(Ts)
inline const @Ts@ max(@T@_I v)
{
    return max_v(v.ptr(), v.size());
}
//% elseif is_Dvec(T) && is_real(Ts) && ~is_Bool(Ts)
inline const @Ts@ max(@T@_I v)
{
    return max_v(v.ptr(), v.size(), v.step());
}
//% else
//%     error('not implemented!');
//% end
//%-------------------------

//% types = {
//%     'VecChar'; 'VecInt'; 'VecLlong'; 'VecDoub';
//% };
//%--------------------------
//% T = varargin{:}; Ts = contain_type(T);
//% if is_dense(T) && is_real(Ts) && ~is_Bool(Ts)
inline @Ts@ max(Long_O ind, @T@_I v)
{
    Long N = v.size();
    @Ts@ val = v[0];
    for (Long i = 1; i < N; ++i) {
        if (val < v[i]) {
            val = v[i]; ind = i;
        }
    }
    return val;
}
//% end
//%--------------------------

//% types = {
//%     'Int'; 'Llong'; 'Float'; 'Doub'; 'Comp';
//% };
//%------------------------------
//% T = varargin{:};
//% Tr = rm_comp(T);
inline @Tr@ max_abs_v(const @T@ *v, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @Tr@ s = abs(v[0]), val;
    for (Long i = 1; i < N; ++i) {
        val = abs(v[i]);
        if (s < val)
            s = val;
    }
    return s;
}

inline @Tr@ max_abs_v(const @T@ *v, Long_I N, Long_I step)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @Tr@ s = abs(v[0]), val;
    for (Long i = step; i < N*step; i += step) {
        val = abs(v[i]);
        if (s < val)
            s = val;
    }
    return s;
}
//%-------------------------

//% types = {
//%     'VecInt'; 'VecLlong'; 'VecFloat'; 'VecDoub'; 'VecComp';
//%     'MatComp'; 'CmatDoub'; 'CmatComp'; 'DvecDoub'; 'DvecComp'; 'SvecComp';
//% };
//%------------------------------
//% T = varargin{:}; Tr = rm_comp(contain_type(T));
//% if is_dense(T)
inline @Tr@ max_abs(@T@_I v)
{
    return max_abs_v(v.ptr(), v.size());
}
//% elseif is_Dvec(T)
inline @Tr@ max_abs(@T@_I v)
{
    return max_abs_v(v.ptr(), v.size(), v.step());
}
//% else
//%     error('Not implemented!');
//% end
//%--------------------------

//% types = {
//%     'Char', 'Char';
//%     'Int', 'Int';
//%     'Llong', 'Llong';
//%     'Doub', 'Doub';
//% };
//%--------------------------
//% [T, T1] = varargin{:};
//% Ts1 = contain_type(T1);
inline void mod_vvs(@T@ *v, const @T1@ *v1, @Ts1@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = mod(v1[i], s);
}

inline void mod_vs(@T1@ *v, @Ts1@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = mod(v[i], s);
}
//%-------------------------

//% types = {
//%     'VecInt', 'VecInt', 'Int';
//%     'VecLlong', 'VecLlong', 'Llong';
//% };
//%--------------------------
//% [T, T1] = varargin{:};
//% Ts = contain_type(T);
//% Ts1 = contain_type(T1);
//% if ~(is_dense(T) && is_dense(T1) && is_same_major(T, T1) && is_promo(Ts, Ts1))
//%     error('error types!');
//% end
inline void mod(@T@_O v, @T1@_I v1, @Ts1@_I s)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong size!");
#endif
    mod_vvs(v.ptr(), v1.ptr(), s, v.size());
}

inline void mod(@T1@_O v, @Ts1@_I s)
{
    mod_vs(v.ptr(), s, v.size());
}
//%-------------------------

//% types = {'Char'; 'Int'; 'Llong'};
//%--------------------
//% T = varargin{:}; Ts = contain_type(T);
inline void rem_vs(@T@ *v, @Ts@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] %= s;
}
//%-------------------

//% types = {
//%     'Char', 'Char';
//%     'Int', 'Int';
//%     'Llong', 'Llong';
//% };
//%---------------------
//% [T, T1] = varargin{:}; Ts = contain_type(T1);
inline void rem_vvs(@T@ *v, const @T1@ *v1, @Ts@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[i] % s;
}
//%--------------------

//% types = {
//%     'VecChar'
//%     'VecInt'
//%     'VecLlong'
//% };
//%---------------------
//% T = varargin{:}; Ts = contain_type(T);
inline void rem(@T@_IO v, @Ts@_I s)
{
    rem_vs(v.ptr(), s, v.size());
}
//%--------------------

//% types = {
//%     'VecChar', 'VecChar', 'Char';
//%     'VecInt', 'VecInt', 'Int';
//%     'VecLlong', 'VecLlong', 'Llong';
//% };
//%---------------------
//% [T, T1] = varargin{:}; Ts = contain_type(T1);
inline void rem(@T@_O v, @T1@_I v1, @Ts@_I s)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong size!");
#endif
    rem_vvs(v.ptr(), v1.ptr(), s, v.size());
}
//%--------------------

//% types = {
//%     'Fcomp'; 'Comp'; 'Lcomp';
//% };
//%---------------------
//% T = varargin{:}; Tr = rm_comp(T);
inline void real_v(@T@ *v, Long_I N)
{
    @Tr@ *pr = (@Tr@ *)v;
    for (Long i = 1; i < 2*N; i += 2)
        pr[i] = 0;
}

inline void imag_v(@T@ *v, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = imag(v[i]);
}
//%---------------------

//% types = {
//%     'Doub', 'Comp';
//%     'Comp', 'Comp';
//% };
//%---------------------
//% [T, T1] = varargin{:};
inline void real_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = real(v1[i]); 
}

inline void imag_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = imag(v1[i]); 
}
//%---------------------

//% types = {
//%     'VecComp';
//% };
//%---------------------
//% T = varargin{:};
inline void real(@T@_IO v)
{
    real_v(v.ptr(), v.size());
}

inline void imag(@T@_IO v)
{
    imag_v(v.ptr(), v.size());
}
//%---------------------

//% types = {
//%     'VecDoub', 'VecComp';
//%     'VecComp', 'VecComp';
//% };
//%---------------------
//% [T, T1] = varargin{:};
inline void real(@T@_O v, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong size!");
#endif
    real_vv(v.ptr(), v1.ptr(), v1.size());
}

inline void imag(@T@_O v, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong size!");
#endif
    imag_vv(v.ptr(), v1.ptr(), v1.size());
}
//%--------------------

//% types = {
//%     'Int'; 'Llong'; 'Doub'; 'Fcomp'; 'Comp'; 'Lcomp';
//% };
//%---------------------
//% T = varargin{:}; Tr = rm_comp(T);
inline void abs_v(@T@ *v, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = abs(v[i]);
}
//%---------------------

//% types = {
//%     'Llong', 'Llong'; 
//%     'Doub', 'Doub'; 
//%     'Doub', 'Comp';
//%     'Comp', 'Comp';
//% };
//%---------------------
//% [T, T1] = varargin{:};
inline void abs_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = abs(v1[i]); 
}
//%---------------------

//% types = {
//%     'VecDoub'; 'VecComp';
//% };
//%---------------------
//% T = varargin{:};
inline void abs(@T@_IO v)
{
    abs_v(v.ptr(), v.size());
}
//%---------------------

//% types = {
//%     'VecDoub', 'VecDoub';
//%     'VecDoub', 'VecComp';
//%     'VecComp', 'VecComp';
//% };
//%---------------------
//% [T, T1] = varargin{:};
inline void abs(@T@_O v, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong size!");
#endif
    abs_vv(v.ptr(), v1.ptr(), v1.size());
}
//%--------------------

//% types = {'Bool'; 'Int'; 'Llong'; 'Doub'; 'Comp';};
//%--------------------
//% T = varargin{:};
//% if is_integral(T)
inline Llong sum_v(const @T@ *v, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    Llong s = v[0];
    for (Llong i = 1; i < N; ++i)
        s += v[i];
    return s;
}
//% else
inline @T@ sum_v(const @T@ *v, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @T@ s = v[0];
    for (Long i = 1; i < N; ++i)
        s += v[i];
    return s;
}
//% end
//%------------------------

//% types = {'VecInt'; 'VecLlong'; 'VecDoub'; 'SvecDoub';
//%     'MatComp'; 'CmatDoub'; 'CmatComp';};
//%----------------
//% T = varargin{:};
//% if is_integral(T)
//%     Tret = Long;
//% else
//%     Tret = contain_type(T);
//% end
inline const @Tret@ sum(@T@_I v)
{
    return sum_v(v.ptr(), v.size());
}
//%-----------------

//% types = {'VecDoub'; 'VecComp'; 'MatDoub'; 'MatComp';
//%     'CmatDoub'; 'CmatComp'; 'Cmat3Doub';
//%     'Cmat3Comp'; 'SvecComp'; 'DvecComp'; 'ScmatDoub'; 'DcmatComp';
//% };
//%-------------------------------
//% T = varargin{:};
//% Ts = contain_type(T);
//% Tr = rm_comp(Ts);
//% if is_dense(T) || is_Dvec(T)
inline @Tr@ norm2(@T@_I v)
{
    Long N = v.size();
    @Tr@ s2 = abs2(v[0]);
    for (Long i = 1; i < N; ++i)
        s2 += abs2(v[i]);
    return s2;
}
//% elseif is_Dcmat(T)
inline @Tr@ norm2(@T@_I a)
{
    const @Ts@ *p = a.ptr();
    Long Nr = a.n1(), lda = a.lda();
    @Tr@ s2 = 0;
    for (Long j = 0; j < a.n2(); ++j) {
        for (Long i = 0; i < Nr; ++i)
            s2 += abs2(p[i]);
        p += lda;
    }
    return s2;
}
//% else
//%     error('not implemented!');
//% end
inline @Tr@ norm(@T@_I v)
{
    return sqrt(norm2(v));
}
//%-------------------------

//% types = {'VecInt'; 'VecDoub'; 'CmatInt'; 'CmatLlong'; 'CmatDoub'; 'Cmat3Doub'; 'Cmat3Comp';};
//%--------------------------------
//% Tv = varargin{:};
//% T = contain_type(Tv);
//% if is_Vec(Tv)
inline void resize_cpy(@Tv@_IO v, Long_I N)
{
    Long N0 = v.size();
    if (N != N0) {
        if (N0 == 0) {
            v.resize(N); copy(v, 0);
        }
        else if (N == 0)
            v.resize(0);
        else {
            @Tv@ v1(N);
            if (N > N0) {
                veccpy(v1.ptr(), v.ptr(), N0);
                vecset(v1.ptr() + N0, 0, N - N0);
            }
            else // N < N0
                veccpy(v1.ptr(), v.ptr(), N);
            v << v1;
        }
    }
}
//% elseif is_Cmat(Tv) || is_Mat(Tv)
//%     Tsli = slice_type(Tv);
inline void resize_cpy(@Tv@_IO v, Long_I N1, Long_I N2)
{
    Long N10 = v.n1(), N20 = v.n2(), N0 = N1*N2;
    Long N = N1 * N2;
    if (N1 != N10 || N2 != N20) {
        if (N0 == 0) {
            v.resize(N1, N2); copy(v, 0);
        }
        else if (N == 0)
            v.resize(0, 0);
        else {
            @Tv@ v1(N1, N2); copy(v1, 0);
            Long N1min = min(N1, N10), N2min = min(N2, N20);
            copy(slice(v1, 0, N1min, 0, N2min),
				slice(v, 0, N1min, 0, N2min));
			v << v1;
        }
    }
}
//% elseif is_Cmat3(Tv) || is_Mat3(Tv)
inline void resize_cpy(@Tv@_IO v, Long_I N1, Long_I N2, Long_I N3)
{
    Long N10 = v.n1(), N20 = v.n2(), N30 = v.n3(), N0 = N1*N2;
    Long N = N1 * N2 * N3;
    if (N1 != N10 || N2 != N20 || N3 != N30) {
        if (N0 == 0) {
            v.resize(N1, N2, N3); copy(v, 0);
        }
        else if (N == 0)
            v.resize(0, 0, 0);
        else {
            @Tv@ v1(N1, N2, N3); copy(v1, 0);
            Long N1min = min(N1, N10), N2min = min(N2, N20), N3min = min(N3, N30);
            copy(slice(v1, 0, N1min, 0, N2min, 0, N3min),
				slice(v, 0, N1min, 0, N2min, 0, N3min));
			v << v1;
        }
    }
}
//% else
//%     error('not implemented');
//% end
//%-------------------------

//% types = {'Char'; 'Int'; 'Llong'; 'Doub'; 'Comp';};
//%-----------------------
//% T = varargin{:};
inline void linspace_vss(@T@ *v, @T@_I first, @T@_I last, Long N)
{
//% if is_integral(T)
    @T@ delta = (last - first), Nm1 = N-1;
    for (Long i = 0; i < N; ++i)
        v[i] = first + delta * i / Nm1;
//% else
    @T@ delta = (last - first) / (N - 1);
    for (Long i = 0; i < N; ++i)
        v[i] = first + delta * i;
//% end
}
//%-------------------------

//% types = {'VecChar'; 'VecInt'; 'VecLlong'; 'VecDoub'; 'VecComp'; 'MatInt';
//%     'MatComp'; 'CmatInt'; 'CmatLlong'; 'CmatDoub'; 'CmatComp';
//%     'Cmat3Int'; 'Cmat3Doub'; 'Cmat3Comp'; 'Cmat4Int'; 'Cmat4Doub'; 'Cmat4Comp'; 'ScmatInt';
//% };
//%---------------------------------
//% Tv = varargin{:};
//% Ts = contain_type(Tv);
//% if ~is_dense(Tv)
//%     error('illegal types');
//% end
inline void linspace(@Tv@_O v, @Ts@_I first, @Ts@_I last)
{
    linspace_vss(v.ptr(), first, last, v.size());
}
//%-------------------------

//% types = {
//%     'Char'; 'Int'; 'Llong'; 'Doub'; 'Comp';
//% };
//%---------------------------------
//% T = varargin{:};
inline void flip_v(@T@ *v, Long_I N)
{
    for (Long i = 0; i < N / 2; ++i)
        swap(v[i], v[N - i - 1]);
}
//%---------------------

//% types = {
//%     'Char', 'Char';
//%     'Int', 'Int';
//%     'Llong', 'Llong';
//%     'Doub', 'Doub';
//%     'Comp', 'Comp';
//% };
//%---------------------------------
//% [T, T1] = varargin{:};
inline void flip_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[N - i - 1];
}
//%----------------------------

//% types = {
//%     'VecChar'; 'VecInt'; 'VecLlong'; 'VecDoub'; 'VecComp';
//% };
//%---------------------------------
//% Tv = varargin{:};
//% Ts = contain_type(Tv);
//% if is_dense(Tv)
inline void flip(@Tv@_IO v)
{
    flip_v(v.ptr(), v.size());
}
//% else
//%     error('not implemented!');
//% end
//%---------------------------

//% types = {
//%     'VecChar', 'VecChar';
//%     'VecInt', 'VecInt';
//%     'VecLlong', 'VecLlong';
//%     'VecDoub', 'VecDoub';
//%     'VecComp', 'VecComp';
//% };
//%---------------------------------
//% [T, T1] = varargin{:};
//% if is_dense(T) && is_dense(T1)
inline void flip(@T@_O v, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong size!");
#endif
    flip_vv(v.ptr(), v1.ptr(), v1.size());
}
//% else
//%     error('not implemented!');
//% end
//%---------------------------

//% types = {
//%     'VecInt', 'VecLlong';
//%     'VecLlong', 'VecLlong';
//%     'VecDoub', 'VecLlong';
//%     'SvecChar', 'VecLlong';
//%     'SvecInt', 'VecLlong';
//%     'SvecLlong', 'VecLlong';
//%     'SvecDoub', 'VecLlong';
//%     'SvecComp', 'VecLlong';
//%     };
//%---------------------
//% [Tv, To] = varargin{:};
//% Tu = ['Vec' contain_type(Tv)];
inline void reorder(@Tv@_O v, @To@_I order)
{
    Long N = v.size();
#ifdef SLS_CHECK_SHAPE
    if (order.size() != N)
        SLS_ERR("wrong shape!");
#endif
    static @Tu@ u(N);
	if (N > u.size())
		u.resize(max(N, 2*u.size()));
    for (Long i = 0; i < N; ++i)
        u[i] = v[order[i]];
    for (Long i = 0; i < N; ++i)
        v[i] = u[i];
}
//%-------------------------

//% types = {'CmatDoub'; 'CmatComp';
//%     'MatComp'; 'DcmatDoub'; 'DcmatComp'};
//%--------------------------
//% T = varargin{:};
inline void trans(@T@_IO v)
{
#ifdef SLS_CHECK_SHAPE
    if (v.n1() != v.n2())
        SLS_ERR("illegal shape!");
#endif
    for (Long i = 0; i < v.n1(); ++i)
        for (Long j = 0; j < i; ++j)
            swap(v(i, j), v(j, i));
}
//%-------------------------

//% types = {
//%	    'CmatLlong' 'CmatLlong';
//%	    'CmatDoub' 'CmatDoub';
//%	    'MatComp' 'CmatComp';
//%	    'CmatComp' 'CmatComp';
//%	    'CmatComp' 'MatComp';
//%     'ScmatDoub' 'ScmatDoub';
//%     'ScmatComp' 'ScmatComp';
//%	    'DcmatLlong' 'DcmatLlong';
//%	    'DcmatDoub' 'DcmatDoub';
//%	    'DcmatComp' 'DcmatComp';
//% };
//%--------------------------
//% [T, T1] = varargin{:};
inline void trans(@T@_O v, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPE
    if (v.n1() != v1.n2() || v.n2() != v1.n1())
        SLS_ERR("wrong size!");
#endif
    for (Long i = 0; i < v.n1(); ++i)
        for (Long j = 0; j < v.n2(); ++j)
            v(i, j) = v1(j, i);
}
//%-------------------------

//% types = {
//%	    'Comp';
//% };
//%--------------------------
//% T = varargin{:}; Tr = rm_comp(T);
inline void conj_v(@T@ *v, Long_I N)
{
    @Tr@ *p = (@Tr@ *)v;
    for (Long i = 1; i < 2*N; i += 2)
        p[i] = -p[i];
}
//%--------------------------

//% types = {
//%	    'Comp', 'Comp';
//% };
//%--------------------------
//% [T, T1] = varargin{:};
inline void conj_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = conj(v1[i]);
}
//%-------------------------------

//% types = {
//%	    'VecComp'; 'CmatComp'; 'MatComp'; 'DcmatComp';
//% };
//%--------------------------
//% T = varargin{:}; Ts = contain_type(T);
//% if ~(is_comp(Ts))
//%     error('error types!');
//% end
//% if is_dense(T)
inline void conj(@T@_IO v)
{
    conj_v(v.ptr(), v.size());
}
//% elseif is_Dcmat(T)
inline void conj(@T@_IO v)
{
	for (Long j = 0; j < v.n2(); ++j)
    	conj_v(v.ptr(), v.n1());
}
//% end
//%----------------------------

//% types = {
//%	    'CmatComp', 'CmatComp';
//%	    'MatComp', 'MatComp';
//% };
//%--------------------------
//% [T, T1] = varargin{:};
inline void conj(@T@_O v, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong size!");
#endif
    conj_vv(v.ptr(), v1.ptr(), v.size());
}
//%----------------------------

//% types = {
//%	    'CmatComp'; 'MatComp';
//% };
//%--------------------------
//% T = varargin{:}; Ts = contain_type(T);
//% if ~(is_comp(Ts) && ndim(T) == 2)
//%     error('error types!');
//% end
inline void her(@T@_IO v)
{
#ifdef SLS_CHECK_SHAPE
    if (v.n1() != v.n2()) SLS_ERR("illegal shape!");
#endif
    trans(v); conj(v);
}
//%---------------------------

//% types = {
//%	    'MatComp' 'CmatComp';
//%	    'CmatComp' 'MatComp';
//%	    'CmatComp' 'CmatComp';
//%	    'DcmatComp' 'DcmatComp';
//% };
//%--------------------------
//% [T, T1] = varargin{:};
inline void her(@T@_O v, @T1@_I v1)
{
	trans(v, v1); conj(v);
}
//%-------------------------

//% types = {
//%     'Char', 'Char';
//%     'Int', 'Int';
//%     'Doub', 'Doub';
//%     'Comp', 'Comp';
//%     };
//%-------------------
//% [T, Ts] = varargin{:};
//% if ~is_promo(T, Ts)
//%     error('illegal types');
//% end
inline void plus_equals_vs(@T@ *v, @Ts@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] += s;
}

inline void minus_equals_vs(@T@ *v, @Ts@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] -= s;
}

inline void times_equals_vs(@T@ *v, @Ts@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] *= s;
}

inline void times_equals_vs(@T@ *v, @Ts@_I s, Long_I N, Long step)
{
    for (Long i = 0; i < N*step; i += step)
        v[i] *= s;
}

//% if is_integral(T)
inline void divide_equals_vs(@T@ *v, @Ts@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] /= s;
}

inline void divide_equals_vs(@T@ *v, @Ts@_I s, Long_I N, Long_I step)
{
    for (Long i = 0; i < N*step; i += step)
        v[i] /= s;
}
//% elseif is_fpt(Ts) || is_comp(Ts)
inline void divide_equals_vs(@T@ *v, @Ts@_I s, Long_I N)
{
    times_equals_vs(v, 1/s, N);
}

inline void divide_equals_vs(@T@ *v, @Ts@_I s, Long_I N, Long_I step)
{
    times_equals_vs(v, 1/s, N, step);
}
//% else
//%     disp(T); disp(Ts);
//%     error('not implemented');
//% end
//%-------------------------

//% types = {
//%     'VecChar', 'Char';
//%     'VecInt', 'Int';
//%     'VecDoub', 'Doub';
//%     'VecComp', 'Comp';
//%     'CmatChar', 'Char';
//%     'CmatInt', 'Int';
//%     'CmatDoub', 'Doub';
//%     'CmatComp', 'Doub';
//%     'CmatComp', 'Comp';
//%     'SvecDoub', 'Doub';
//%     'DvecComp', 'Doub';
//%     'DvecComp', 'Comp';
//%     'Cmat3Doub', 'Doub';
//%     'Cmat3Comp', 'Doub';
//%     'Cmat3Comp', 'Comp';
//% };
//%-------------------
//% [T, Ts] = varargin{:};
//% if is_dense(T) && is_scalar(Ts)
inline void operator+=(@T@_IO v, @Ts@_I s)
{
    plus_equals_vs(v.ptr(), s, v.size());
}

inline void operator-=(@T@_IO v, @Ts@_I s)
{
    minus_equals_vs(v.ptr(), s, v.size());
}

inline void operator*=(@T@_IO v, @Ts@_I s)
{
    times_equals_vs(v.ptr(), s, v.size());
}

inline void operator/=(@T@_IO v, @Ts@_I s)
{
    divide_equals_vs(v.ptr(), s, v.size());
}
//% elseif is_Dvec(T) && is_scalar(Ts)
inline void operator*=(@T@_IO v, @Ts@_I s)
{
    times_equals_vs(v.ptr(), s, v.size(), v.step());
}

inline void operator/=(@T@_IO v, @Ts@_I s)
{
    divide_equals_vs(v.ptr(), s, v.size(), v.step());
}
//% else
//%     disp(T); disp(Ts);
//%     error('not implemented');
//% end
//%-------------------------

//% types = {
//%     'Char', 'Char';
//%     'Int', 'Int';
//%     'Doub', 'Doub';
//%     'Comp', 'Doub';
//%     'Comp', 'Comp';
//%     };
//%-------------------
//% [T, T1] = varargin{:};
//% if ~is_promo(T, T1)
//%     error('illegal types');
//% end
inline void plus_equals_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] += v1[i];
}

inline void minus_equals_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] -= v1[i];
}

inline void times_equals_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] *= v1[i];
}

inline void divide_equals_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] /= v1[i];
}
//%-------------------------

//% types = {
//%     'VecChar', 'VecChar';
//%     'VecInt', 'VecInt';
//%     'VecDoub', 'VecDoub';
//%     'VecDoub', 'SvecDoub';
//%     'VecComp', 'VecComp';
//%     'MatDoub', 'MatDoub';
//%     'MatComp', 'MatComp';
//%     'CmatDoub', 'CmatDoub';
//%     'CmatComp', 'CmatComp';
//%     'Cmat3Doub', 'Cmat3Doub';
//%     'Cmat3Comp', 'Cmat3Comp';
//%     'SvecDoub', 'VecDoub';
//%     'SvecDoub', 'SvecDoub';
//%     'SvecComp', 'SvecComp';
//%     'ScmatDoub', 'ScmatDoub';
//%     'ScmatComp', 'CmatDoub';
//%     'ScmatComp', 'ScmatDoub';
//%     'ScmatComp', 'ScmatComp';
//%     'DcmatComp', 'DcmatDoub';
//% };
//%-------------------
//% [T, T1] = varargin{:};
//% if is_dense(T) && is_dense(T1) && is_same_major(T, T1)
inline void operator+=(@T@_O &v, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong shape!");
#endif
    plus_equals_vv(v.ptr(), v1.ptr(), v1.size());
}

inline void operator-=(@T@_O &v, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong shape!");
#endif
    minus_equals_vv(v.ptr(), v1.ptr(), v1.size());
}

inline void operator*=(@T@_O &v, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong shape!");
#endif
    times_equals_vv(v.ptr(), v1.ptr(), v1.size());
}

inline void operator/=(@T@_O &v, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong shape!");
#endif
    divide_equals_vv(v.ptr(), v1.ptr(), v1.size());
}
//% elseif ndim(T) == 1 && ndim(T1) == 1
// v += v
inline void operator+=(@T@_O &v, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong shape!");
#endif
    for (Long i = 0; i < v.size(); ++i)
		v[i] += v1[i];
}

// v -= v
inline void operator-=(@T@_O &v, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong shape!");
#endif
	for (Long i = 0; i < v.size(); ++i)
		v[i] -= v1[i];
}

// v *= v
inline void operator*=(@T@_O &v, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong shape!");
#endif
    for (Long i = 0; i < v.size(); ++i)
		v[i] *= v1[i];
}

// v /= v
inline void operator/=(@T@_O &v, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong shape!");
#endif
    for (Long i = 0; i < v.size(); ++i)
		v[i] /= v1[i];
}
//% elseif ndim(T) == 2 && ndim(T1) == 2
// v += v (slow!)
inline void operator+=(@T@_O &v, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong shape!");
#endif
	for (Long j = 0; j < v.n2(); ++j)
		for (Long i = 0; i < v.n1(); ++i)
			v(i, j) += v1(i, j);
}

// v -= v (slow!)
inline void operator-=(@T@_O &v, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong shape!");
#endif
	for (Long j = 0; j < v.n2(); ++j)
		for (Long i = 0; i < v.n1(); ++i)
			v(i, j) -= v1(i, j);
}

// v *= v (slow!)
inline void operator*=(@T@_O &v, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong shape!");
#endif
	for (Long j = 0; j < v.n2(); ++j)
		for (Long i = 0; i < v.n1(); ++i)
			v(i, j) *= v1(i, j);
}

// v /= v (slow!)
inline void operator/=(@T@_O &v, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong shape!");
#endif
	for (Long j = 0; j < v.n2(); ++j)
		for (Long i = 0; i < v.n1(); ++i)
			v(i, j) /= v1(i, j);
}
//% else
//%     error('not implemented!');
//% end
//%-------------------------

//% types = {
//%	    'Char', 'Char', 'Char';
//%	    'Int', 'Int', 'Int';
//%	    'Llong', 'Llong', 'Llong';
//%     'Float', 'Float', 'Float';
//%	    'Doub', 'Doub', 'Doub';
//%	    'Comp', 'Comp', 'Doub';
//%	    'Comp', 'Doub', 'Imag';
//%	    'Comp', 'Doub', 'Comp';
//%	    'Comp', 'Comp', 'Comp';
//% };
//%------------------------------
//% [T, T1, T2] = varargin{:};
//% if ~is_promo(T, T1) || ~is_promo(T, T2)
//%     error('illegal types');
//% end
inline void plus_vvs(@T@ *v, const @T1@ *v1, @T2@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[i] + s;
}

inline void minus_vvs(@T@ *v, const @T1@ *v1, @T2@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[i] - s;
}

inline void times_vvs(@T@ *v, const @T1@ *v1, @T2@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[i] * s;
}

inline void divide_vvs(@T@ *v, const @T1@ *v1, @T2@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[i] / s;
}
//%-------------------------

//% types = {
//%	    'Char', 'Char', 'Char';
//%	    'Int', 'Int', 'Int';
//%	    'Llong', 'Llong', 'Llong';
//%     'Float', 'Float', 'Float';
//%	    'Doub', 'Doub', 'Doub';
//%	    'Comp', 'Comp', 'Doub';
//%	    'Comp', 'Doub', 'Comp';
//%	    'Comp', 'Comp', 'Comp';
//% };
//%------------------------------
//% [T, T1, T2] = varargin{:};
//% if ~is_promo(T, T1) || ~is_promo(T, T2)
//%     error('illegal types');
//% end
inline void minus_vsv(@T@ *v, const @T1@ &s, const @T2@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = s - v1[i];
}

inline void divide_vsv(@T@ *v, const @T1@ &s, const @T2@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = s / v1[i];
}
//%-------------------------

//% types = {
//%     'Char', 'Char', 'Char';
//%     'Int', 'Int', 'Int';
//%     'Llong', 'Llong', 'Llong';
//%     'Float', 'Float', 'Float';
//%     'Doub', 'Doub', 'Doub';
//%     'Comp', 'Doub', 'Doub';
//%     'Comp', 'Comp', 'Doub';
//%     'Comp', 'Doub', 'Comp';
//%     'Comp', 'Comp', 'Comp';
//% };
//%------------------------------
//% [T, T1, T2] = varargin{:};
//% if ~is_promo(T, T1) || ~is_promo(T, T2)
//%     error('illegal type!');
//% end
inline void plus_vvv(@T@ *v, const @T1@ *v1, const @T2@ *v2, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[i] + v2[i];
}

inline void minus_vvv(@T@ *v, const @T1@ *v1, const @T2@ *v2, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[i] - v2[i];
}

inline void times_vvv(@T@ *v, const @T1@ *v1, const @T2@ *v2, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[i] * v2[i];
}

inline void divide_vvv(@T@ *v, const @T1@ *v1, const @T2@ *v2, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = v1[i] / v2[i];
}
//%-------------------------

//% types = {
//%	    'VecChar', 'VecChar', 'Char';
//%	    'VecInt', 'VecInt', 'Int';
//%	    'VecLlong', 'VecLlong', 'Llong';
//%	    'VecDoub', 'VecDoub', 'Doub';
//%	    'VecComp', 'VecComp', 'Doub';
//%	    'VecComp', 'VecDoub', 'Doub';
//%	    'VecComp', 'SvecDoub', 'Doub';
//%	    'VecComp', 'SvecDoub', 'Imag';
//%	    'VecComp', 'VecDoub', 'Comp';
//%	    'VecComp', 'VecComp', 'Comp';
//%	    'CmatInt', 'CmatInt', 'Int';
//%	    'CmatLlong', 'CmatLlong', 'Llong';
//%	    'CmatDoub', 'CmatDoub', 'Doub';
//%	    'CmatComp', 'CmatComp', 'Doub';
//%	    'CmatComp', 'CmatDoub', 'Comp';
//%	    'CmatComp', 'CmatComp', 'Comp';
//%	    'Cmat3Comp', 'Cmat3Comp', 'Comp';
//%	    'Cmat3Comp', 'Cmat3Doub', 'Comp';
//% };
//%------------------------------
//% [T, T1, Ts2] = varargin{:};
//% Ts = contain_type(T); Ts1 = contain_type(T1);
//% if ~is_promo(Ts, Ts1) || ~is_promo(Ts, Ts2)
//%     error('illegal types');
//% end
//% if is_dense(T) && is_dense(T1) && is_same_major(T, T1)
inline void plus(@T@_O v, @T1@_I v1, @Ts2@_I s)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong size!");
#endif
    plus_vvs(v.ptr(), v1.ptr(), s, v1.size());
}

inline void plus(@T@_O v, @Ts2@_I s, @T1@_I v1)
{
	plus(v, v1, s);
}

inline void minus(@T@_O v, @T1@_I v1, @Ts2@_I s)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong size!");
#endif
    minus_vvs(v.ptr(), v1.ptr(), s, v1.size());
}

inline void minus(@T@_O v, @Ts2@_I s, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong size!");
#endif
    minus_vsv(v.ptr(), s, v1.ptr(), v1.size());
}

inline void times(@T@_O v, @T1@_I v1, @Ts2@_I s)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong size!");
#endif
    times_vvs(v.ptr(), v1.ptr(), s, v1.size());
}

inline void times(@T@_O v, @Ts2@_I s, @T1@_I v1)
{
	times(v, v1, s);
}

inline void divide(@T@_O v, @T1@_I v1, @Ts2@_I s)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong size!");
#endif
    divide_vvs(v.ptr(), v1.ptr(), s, v1.size());
}

inline void divide(@T@_O v, @Ts2@_I s, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong size!");
#endif
    divide_vsv(v.ptr(), s, v1.ptr(), v1.size());
}
//% else
//%     error('not implemented!');
//% end
//%-------------------------

//% types = {
//%	    'VecChar', 'VecChar', 'VecChar';
//%	    'VecInt', 'VecInt', 'VecInt';
//%	    'VecLlong', 'VecLlong', 'VecLlong';
//%	    'VecDoub', 'VecDoub', 'VecDoub';
//%	    'VecComp', 'VecDoub', 'VecDoub';
//%	    'VecComp', 'VecComp', 'VecComp';
//%	    'CmatInt', 'CmatInt', 'CmatInt';
//%	    'CmatLlong', 'CmatLlong', 'CmatLlong';
//%	    'CmatDoub', 'CmatDoub', 'CmatDoub';
//%	    'CmatComp', 'CmatDoub', 'CmatDoub';
//%	    'CmatComp', 'CmatComp', 'CmatComp';
//% };
//%------------------------------
//% [T, T1, T2] = varargin{:};
//% Ts = contain_type(T); Ts1 = contain_type(T1); Ts2 = contain_type(T2);
//% if ~is_promo(Ts, Ts1) || ~is_promo(Ts, Ts2)
//%     error('illegal types');
//% end
//% if is_dense(T) && is_dense(T1)
inline void plus(@T@_O v, @T1@_I v1, @T2@_I v2)
{
#ifdef SLS_CHECK_SHAPE
	if (!shape_cmp(v, v1) || !shape_cmp(v, v2))
		SLS_ERR("wrong shape!");
#endif
	plus_vvv(v.ptr(), v1.ptr(), v2.ptr(), v.size());
}

inline void minus(@T@_O v, @T1@_I v1, @T2@_I v2)
{
#ifdef SLS_CHECK_SHAPE
	if (!shape_cmp(v, v1) || !shape_cmp(v, v2))
		SLS_ERR("wrong shape!");
#endif
	minus_vvv(v.ptr(), v1.ptr(), v2.ptr(), v.size());
}

inline void times(@T@_O v, @T1@_I v1, @T2@_I v2)
{
#ifdef SLS_CHECK_SHAPE
	if (!shape_cmp(v, v1) || !shape_cmp(v, v2))
		SLS_ERR("wrong shape!");
#endif
	times_vvv(v.ptr(), v1.ptr(), v2.ptr(), v.size());
}

inline void divide(@T@_O v, @T1@_I v1, @T2@_I v2)
{
#ifdef SLS_CHECK_SHAPE
	if (!shape_cmp(v, v1) || !shape_cmp(v, v2))
		SLS_ERR("wrong shape!");
#endif
	divide_vvv(v.ptr(), v1.ptr(), v2.ptr(), v.size());
}
//% else
//%     error('not implemented!');
//% end
//%--------------------------

//% types = {
//%     'Int', 'Int';
//%     'Llong', 'Llong';
//%     'Doub', 'Doub';
//%     'Comp', 'Doub';
//%     'Comp', 'Comp';
//% };
//%----------------------------------------------------------
//% [T, T1] = varargin{:};
inline void minus_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = -v1[i];
}
//%--------------------------

//% types = {
//%     'VecInt', 'VecInt';
//%     'VecLlong', 'VecLlong';
//%     'VecDoub', 'VecDoub';
//%     'VecComp', 'VecDoub';
//%     'VecComp', 'VecComp';
//%     'ScmatDoub', 'CmatDoub';
//% };
//%----------------------------------------------------------
//% [T, T1] = varargin{:};
//% if is_dense(T) && is_dense(T1) && is_same_major(T, T1)
inline void minus(@T@_O v, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong size!");
#endif
    minus_vv(v.ptr(), v1.ptr(), v1.size());
}
//% else
//%     error('not implemented!');
//% end
//%--------------------------

//% types = {
//%     'Int', 'Int';
//%     'Llong', 'Llong';
//%     'Float', 'Float';
//%     'Doub', 'Int';
//%     'Doub', 'Llong';
//%     'Doub', 'Doub';
//%     'Comp', 'Int';
//%     'Comp', 'Llong';
//%     'Comp', 'Doub';
//%     'Comp', 'Comp';  
//% };
//%----------------------------------------------------------
//% [T, Ts] = varargin{:};
inline void pow_vs(@T@ *v, @Ts@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = pow(v[i], s);
}
//%-------------------------

//% types = {
//%     'VecLlong', 'Llong';
//%     'VecDoub', 'Int';
//%     'VecDoub', 'Doub';
//%     'VecComp', 'Int';
//%     'VecComp', 'Doub';
//%     'VecComp', 'Comp';
//% };
//%---------------------
//% [T, Ts] = varargin{:};
inline void pow(@T@_IO v, @Ts@_I s)
{
    pow_vs(v.ptr(), s, v.size());
}
//%-------------------------

//% types = {
//%     'Int', 'Int', 'Int';
//%     'Llong', 'Llong', 'Llong';
//%     'Float', 'Float', 'Float';
//%     'Doub', 'Doub', 'Int';
//%     'Doub', 'Doub', 'Llong';
//%     'Doub', 'Doub', 'Doub';
//%     'Comp', 'Comp', 'Int';
//%     'Comp', 'Comp', 'Llong';
//%     'Comp', 'Comp', 'Doub';
//%     'Comp', 'Comp', 'Comp';  
//% };
//%----------------------------------------------------------
//% [T, T1, Ts] = varargin{:};
inline void pow_vvs(@T@ *v, const @T1@ *v1, @Ts@_I s, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = pow(v1[i], s);
}
//%-------------------------

//% types = {
//%     'VecLlong', 'VecLlong', 'Llong';
//%     'VecDoub', 'VecDoub', 'Int';
//%     'VecDoub', 'VecDoub', 'Llong';
//%     'VecDoub', 'VecDoub', 'Doub';
//%     'VecComp', 'VecComp', 'Int';
//%     'VecComp', 'VecComp', 'Doub';
//%     'VecComp', 'VecComp', 'Comp';
//% };
//%---------------------
//% [T, T1, Ts] = varargin{:};
inline void pow(@T@_O v, @T1@_I v1, @Ts@_I s)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong size!");
#endif
    pow_vvs(v.ptr(), v1.ptr(), s, v1.size());
}
//%-------------------------

//% types = {
//%     'Int', 'Int';
//%     'Llong', 'Llong';
//%     'Float', 'Float';
//%     'Doub', 'Int';
//%     'Doub', 'Comp';
//%     'Doub', 'Llong';
//%     'Doub', 'Char';
//%     'Doub', 'Doub';
//%     'Comp', 'Int';
//%     'Comp', 'Llong';
//%     'Comp', 'Doub';
//%     'Comp', 'Comp';
//% };
//%----------------------------------------------------------
//% [T1, T2] = varargin{:};
//% T = promo_type(T1, T2);
inline @T@ dot_vv(const @T1@ *v1, const @T2@ *v2, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
//% if is_comp(T1)
    @T@ s = conj(v1[0]) * v2[0];
//% else
	@T@ s = v1[0] * v2[0];
//% end
    for (Long i = 1; i < N; ++i) {
//% if is_comp(T1)
        s += conj(v1[i]) * v2[i];
//% else
		s += v1[i] * v2[i];
//% end
	}
    return s;
}
//%-------------------------

//% types = {
//%     'VecLlong', 'VecLlong';
//%     'VecDoub', 'VecChar';
//%     'VecDoub', 'VecDoub';
//%     'VecComp', 'VecDoub';
//%     'VecComp', 'VecComp';
//%     'SvecComp', 'VecComp';
//%     'VecDoub', 'SvecComp';
//%     'SvecDoub', 'SvecComp';
//%     'Cmat3Comp', 'Cmat3Comp';
//% };
//%---------------------
//% [T1, T2] = varargin{:};
//% T = promo_type(contain_type(T1), contain_type(T2));
//% if is_dense(T1) && is_dense(T2)
inline @T@ dot(@T1@_I v1, @T2@_I v2)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v1, v2))
        SLS_ERR("wrong shape!");
#endif
    return dot_vv(v1.ptr(), v2.ptr(), v2.size());
}
//% end
//%-------------------------

//% types = {
//%     'Int', 'Int';
//%     'Llong', 'Int';
//%     'Llong', 'Llong';
//%     'Doub', 'Doub';
//% };
//%---------------------
//% [T, T1] = varargin{:};
inline void cumsum_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    v[0] = v1[0];
    for (Long i = 1; i < N; ++i)
        v[i] = v[i - 1] + v1[i];
}
//%-------------------------

//% types = {
//%     'VecInt', 'VecInt';
//%     'VecLlong', 'VecInt';
//%     'VecLlong', 'VecLlong';
//%     'VecDoub', 'VecDoub';
//% };
//%---------------------
//% [T, T1] = varargin{:};
inline void cumsum(@T@_O v, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("illegal shape!");
#endif
        cumsum_vv(v.ptr(), v1.ptr(), v1.size());
}
//%-------------------------

//% types = {'VecDoub', 'CmatDoub', 'VecDoub';
//%   %  'VecLcomp', 'MatComp', 'VecInt';
//%     'VecInt', 'CmatInt', 'VecInt';
//%     'VecComp', 'CmatComp', 'VecComp';
//%     'VecComp', 'CmatDoub', 'VecComp';
//%     'DvecComp', 'DcmatDoub', 'DvecComp';
//%     'VecComp', 'MatComp', 'VecDoub';
//%     'VecComp', 'MatComp', 'VecComp';
//%   %  'VecComp', 'CmatImag', 'VecComp';
//%   %  'VecComp', 'MatDoub', 'VecComp';
//%   %  'SvecComp', 'MatDoub', 'VecComp';
//%     'SvecComp', 'DcmatComp', 'SvecComp';
//%     'SvecComp', 'DcmatDoub', 'SvecComp';
//%     };
//%-------------------------------
//% [T,T1,T2] = varargin{:};
//% Ts = contain_type(T); Ts1 = contain_type(T1); Ts2 = contain_type(T2);
//% if ~(is_promo(Ts, Ts1) && is_promo(Ts, Ts2));
//%     error('illegal type!');
//% end
//% if ndim(T) ~= 1 || ndim(T1) ~= 2 || ndim(T2) ~= 1
//%     error('illegal dim!');
//% end
inline void mul(@T@_O y, @T1@_I a, @T2@_I x)
{
    Long Nr = a.n1(), Nc = a.n2();
#ifdef SLS_CHECK_SHAPE
    if (Nc != x.size() || y.size() != Nr)
        SLS_ERR("illegal shape!");
#endif
    for (Long i = 0; i < Nr; ++i) {
        y[i] = 0;
        for (Long j = 0; j < Nc; ++j)
            y[i] += a(i, j) * x[j];
    }
}
//%-------------------------

//% types = {
//%     'VecDoub', 'VecDoub', 'MatDoub';
//%     'VecComp', 'VecDoub', 'MatComp';
//%     'VecComp', 'VecComp', 'MatComp';
//% };
//%-------------------------------
//% [T,T1,T2] = varargin{:};
//% Ts = contain_type(T); Ts1 = contain_type(T1); Ts2 = contain_type(T2);
//% if ~(is_promo(Ts, Ts1) && is_promo(Ts, Ts2));
//%     error('illegal type!');
//% end
//% if ndim(T) ~= 1 || ndim(T1) ~= 1 || ndim(T2) ~= 2
//%     error('illegal dim!');
//% end
inline void mul(@T@_O &y, @T1@_I x, @T2@_I a)
{
    Long Nr_a = a.n1(), Nc_a = a.n2();
#ifdef SLS_CHECK_SHAPE
    if (x.size() != a.n1() || y.size() != Nc_a)
        SLS_ERR("illegal shape!");
#endif
    vecset(y.ptr(), 0, Nc_a);
    for (Long j = 0; j < Nc_a; ++j) {
        for (Long i = 0; i < Nr_a; ++i)
            y[j] += x[i] * a(i, j);
    }
}
//%-----------------------------

//% types = {
//%     'CmatDoub', 'CmatDoub', 'CmatDoub';
//%     'CmatComp', 'CmatComp', 'CmatDoub';
//%     'CmatComp', 'CmatComp', 'CmatComp';
//%     'CmatComp', 'CmatComp', 'MatComp';
//%     'ScmatComp', 'ScmatDoub', 'CmatComp';
//% };
//%-------------------------------
//% [T,T1,T2] = varargin{:};
//% if ndim(T) == 2 && ndim(T1) == 2 && ndim(T2) == 2
inline void mul(@T@_O y, @T1@_I a, @T2@_I x)
{
    Long Nr_a = a.n1(), Nc_a = a.n2(), Nc_x = x.n2();
#ifdef SLS_CHECK_SHAPE
    if (a.n2() != x.n1() || y.n1() != Nr_a || y.n2() != Nc_x)
        SLS_ERR("illegal shape!");
#endif
    vecset(y.ptr(), 0, Nr_a*Nc_x);
    for (Long i = 0; i < Nr_a; ++i) {
        for (Long j = 0; j < Nc_x; ++j) {
            for (Long k = 0; k < Nc_a; ++k)
                y(i, j) += a(i, k) * x(k, j);
        }
    }
}
//% else
//%     error('not implemented');
//% end
//%-------------------------

// matrix-vector multiplication
//% types = {
//%     'VecDoub', 'CmatDoub', 'VecDoub';
//%     'VecComp', 'CmatDoub', 'VecComp';
//%     'VecComp', 'ScmatDoub', 'VecComp';
//%     'DvecComp', 'DcmatDoub', 'DvecComp';
//%     'DvecComp', 'CmatDoub', 'DvecComp';
//%     'SvecComp', 'ScmatDoub', 'SvecComp';
//%     'SvecComp', 'ScmatComp', 'SvecComp';
//%     'SvecComp', 'ScmatComp', 'DvecComp';
//%     'SvecComp', 'DcmatDoub', 'SvecComp';
//%     'SvecComp', 'ScmatDoub', 'DvecComp';
//%     'DvecComp', 'ScmatDoub', 'SvecComp';
//%     };
//%------------------------------------
//% [Ty, Ta, Tx] = varargin{:};
//% Tsy = contain_type(Ty); Tsa = contain_type(Ta); Tsx = contain_type(Tx);
inline void mul_gen(@Ty@_O &y, @Ta@_I a, @Tx@_I x, @Tsa@_I alpha = 1, @Tsa@_I beta = 0)
{
#ifdef SLS_CHECK_SHAPE
    if (x.size() != a.n2() || y.size() != a.n1())
        SLS_ERR("wrong shape!");
#endif
#ifdef SLS_USE_CBLAS
    Long N1 = a.n1(), N2 = a.n2(), lda, incx, incy;
//% if is_dense_vec(Ty)
    incy =  1;
//% else
    incy = y.step();
//% end
//% if is_dense_mat(Ta)
    lda = a.n1();
//% else
    lda = a.lda();
//% end
//% if is_dense_vec(Tx)
    incx = 1;
//% else
    incx = x.step();
//% end
//% if is_cmajor(Ta)
    CBLAS_LAYOUT layout = CblasColMajor;
//% else
    CBLAS_LAYOUT layout = CblasRowMajor;
//% end

//% if is_Float(Tsy) && is_Float(Tsa) && is_Float(Tsx)
    cblas_sgemv(layout, CblasNoTrans, N1, N2, alpha, a.ptr(),
        lda, x.ptr(), incx, beta, y.ptr(), incy);
//% elseif is_Doub(Tsy) && is_Doub(Tsa) && is_Doub(Tsx)
    cblas_dgemv(layout, CblasNoTrans, N1, N2, alpha, a.ptr(),
        lda, x.ptr(), incx, beta, y.ptr(), incy);
//% elseif is_Comp(Tsy) && is_Comp(Tsa) && is_Comp(Tsx)
    cblas_zgemv(layout, CblasNoTrans, N1, N2, &alpha, a.ptr(),
        lda, x.ptr(), incx, &beta, y.ptr(), incy);
//% elseif is_Comp(Tsy) && is_Doub(Tsa) && is_Comp(Tsx)
    // do real part
    cblas_dgemv(layout, CblasNoTrans, N1, N2, alpha, a.ptr(),
        lda, (@Tsa@*)x.ptr(), 2*incx, beta, (@Tsa@*)y.ptr(), 2*incy);
    // do imag part
    cblas_dgemv(layout, CblasNoTrans, N1, N2, alpha, a.ptr(),
        lda, (@Tsa@*)x.ptr()+1, 2*incx, beta, (@Tsa@*)y.ptr()+1, 2*incy);
//% else
//%     error('not implemented!');
//% end
#else
    mul(y, a, x);
#endif
}
//%-------------------------

//% types = {
//%     'VecDoub', 'CmatDoub', 'VecDoub';
//%     'VecComp', 'CmatDoub', 'VecComp';
//%   %  'SvecComp', 'DcmatDoub', 'SvecComp';
//%   %  'DvecComp', 'DcmatDoub', 'DvecComp';
//%     };
//%--------------------------------
//% [Ty, Ta, Tx] = varargin{:};
//% Tsy = contain_type(Ty); Tsa = contain_type(Ta); Tsx = contain_type(Tx);
inline void mul_sym(@Ty@_O &y, @Ta@_I a, @Tx@_I x, @Tsa@_I alpha = 1, @Tsa@_I beta = 0)
{
#ifdef SLS_CHECK_SHAPE
    if (x.size() != a.n2() || y.size() != a.n1() || x.size() != y.size())
        SLS_ERR("wrong shape!");
#endif
#ifdef SLS_USE_CBLAS
    Long N1 = a.n1(), lda, incx, incy;
//% if is_dense_vec(Ty)
    incy =  1;
//% else
    incy = y.step();
//% end
//% if is_dense_mat(Ta)
    lda = a.n1();
//% else
    lda = a.lda();
//% end
//% if is_dense_vec(Tx)
    incx = 1;
//% else
    incx = x.step();
//% end
//% if is_cmajor(Ta)
    CBLAS_LAYOUT layout = CblasColMajor;
//% else
    CBLAS_LAYOUT layout = CblasRowMajor;
//% end

//% if is_Float(Tsy) && is_Float(Tsa) && is_Float(Tsx)
    cblas_ssymv(layout, CblasUpper, N1, alpha, a.ptr(),
        lda, x.ptr(), incx, beta, y.ptr(), incy);
//% elseif is_Doub(Tsy) && is_Doub(Tsa) && is_Doub(Tsx)
    cblas_dsymv(layout, CblasUpper, N1, alpha, a.ptr(),
        lda, x.ptr(), incx, beta, y.ptr(), incy);
//% elseif is_Comp(Tsy) && is_Comp(Tsa) && is_Comp(Tsx)
    cblas_zsymv(layout, CblasUpper, N1, &alpha, a.ptr(),
        lda, x.ptr(), incx, &beta, y.ptr(), incy);
//% elseif is_Comp(Tsy) && is_Doub(Tsa) && is_Comp(Tsx)
    // do real part
    cblas_dsymv(layout, CblasUpper, N1, alpha, a.ptr(),
        lda, (@Tsa@*)x.ptr(), 2*incx, beta, (@Tsa@*)y.ptr(), 2*incy);
    // do imag part
    cblas_dsymv(layout, CblasUpper, N1, alpha, a.ptr(),
        lda, (@Tsa@*)x.ptr()+1, 2*incx, beta, (@Tsa@*)y.ptr()+1, 2*incy);
//% else
//%     error('not implemented!');
//% end
#else
    mul(y, a, x);
#endif
}
//%--------------------------------

//% types = {
//%     'CmatDoub', 'CmatDoub', 'CmatDoub';
//%     'CmatComp', 'CmatComp', 'CmatDoub';
//%     'CmatComp', 'CmatComp', 'CmatComp';
//%     'ScmatComp', 'ScmatDoub', 'CmatComp';
//% };
//%--------------------------------
//% [Ty, Ta, Tx] = varargin{:};
//% Tsy = contain_type(Ty); Tsa = contain_type(Ta); Tsx = contain_type(Tx);
inline void mul_gen(@Ty@_O y, @Ta@_I a, @Tx@_I &x)
{
#ifdef SLS_CHECK_SHAPE
    if (a.n2() != x.n1() || y.n1() != a.n1() || y.n2() != x.n2())
        SLS_ERR("illegal shape!");
#endif
#ifdef SLS_USE_CBLAS
//% if is_Doub(Tsy) && is_Doub(Tsa) && is_Doub(Tsx)
    cblas_dgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, a.n1(), x.n2(), a.n2(), 1, (Doub*)a.ptr(), a.n1(), (Doub*)x.ptr(), a.n2(), 0, (Doub*)y.ptr(), a.n1());
//% elseif is_Comp(Tsy) && is_Comp(Tsa) && is_Comp(Tsx)
        Comp alpha(1,0), beta(0,0);
        cblas_zgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, a.n1(), x.n2(), a.n2(), &alpha, a.ptr(), a.n1(), x.ptr(), a.n2(), &beta, y.ptr(), a.n1());
//% else
        SLS_WARN("not implemented with cBLAS, using slow version");
		mul(y, a, x);
//% end
#else
    mul(y, a, x);
#endif
}
//%--------------------------------

// get all unique rows from a matrix
//% types = {
//%     'CmatInt', 'CmatInt';
//%     'CmatLlong', 'ScmatLlong';
//%     'CmatDoub', 'CmatDoub';
//% };
//%--------------------
//% [T, T1] = varargin{:};
//% Tsli1 = slice2_type(T1);
inline void uniq_rows(@T@_O a, @T1@_I a1)
{
    Long k = 0;
    a.resize(a1.n1(), a1.n2());
    for (Long i = 0; i < a1.n1(); ++i) {
        // check repeat
        Bool repeat = false;
        @Tsli1@_c sli1 = slice2(a1, i);
        for (Long j = 0; j < k; ++j) {
            if (slice2(a, j) == sli1) {
                repeat = true; break;
            }
        }
        if (repeat)
            continue;
        copy(slice2(a, k), sli1);
        ++k;
    }
    resize_cpy(a, k, a1.n2());
}
//%---------------------------

//% types = {'Doub'; 'Comp';};
//%-------------------
//% T = varargin{:};
inline void exp_v(@T@ *v, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = exp(v[i]);
}
//%-----------------

//% types = {
//%     'Doub', 'Doub';
//%     'Comp', 'Comp';
//% };
//%-------------------
//% [T, T1] = varargin{:};
inline void exp_vv(@T@ *v, const @T1@ *v1, Long_I N)
{
    for (Long i = 0; i < N; ++i)
        v[i] = exp(v1[i]);
}
//%--------------------

//% types = {
//%     'VecDoub'; 'VecComp';
//% };
//%-------------------
//% T = varargin{:};
inline void exp(@T@_IO v)
{
    exp_v(v.ptr(), v.size());
}
//%--------------------

//% types = {
//%     'VecDoub', 'VecDoub';
//%     'VecComp', 'VecComp';
//% };
//%-------------------
//% [T, T1] = varargin{:};
inline void exp(@T@_O v, @T1@_I v1)
{
#ifdef SLS_CHECK_SHAPE
    if (!shape_cmp(v, v1))
        SLS_ERR("wrong size!");
#endif
    exp_vv(v.ptr(), v1.ptr(), v1.size());
}
//%-------------------

} // namespace slisc
