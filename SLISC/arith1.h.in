// functions that loop through every element of a container
#pragma once
#include "scalar_arith.h"
#include "compare.h"

namespace slisc {
// maximum/minimum element (pointer version)
// max_v(), min_v()
//% tem('max_v', {
//%     'max', 'Doub';
//%     'min', 'Doub';
//% });
//%--------------------------
//% [fun, T] = varargin{:};
//% if strcmp(fun, 'max'), oper = '<'; else, oper = '>'; end
//% if is_real(T) && ~is_Bool(T)
inline @T@ @fun@_v(const @T@ *v, Long_I N, Long_I step = 1)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    const @T@ *end = v + N*step, *p = v; v+=step;
    for (; v < end; v+=step) if (*p @oper@ *v) p = v;
    return *p;
}

inline @T@ @fun@_v(Long_O ind, const @T@ *v, Long_I N, Long_I step = 1)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    const @T@ *beg = v, *end = v + N, *p = v; v+=step;
    for (; v < end; ++v) if (*p @oper@ *v) p = v;
    ind = (p - beg)/step;
    return *p;
}

inline @T@ @fun@_dcmat(const @T@ *v, Long_I N0, Long_I N1, Long_I step1)
{
#ifdef SLS_CHECK_BOUNDS
    if (N0 <= 0 || N1 <= 0 || step1 < N1) SLS_ERR("illegal length!");
#endif
    const @T@ *p = v, *end = v + N1*step1, *beg0 = v, *end0 = v + N0;
    while (1) {
        if (v == end0) {
            beg0 += step1;
            if (beg0 >= end) break;
            v = beg0; end0 += step1;
        }
        if (*p @oper@ *v) p = v;
        ++v;
    }
    return *p;
}

inline @T@ @fun@_dcmat(Long_O i, Long_O j, const @T@ *v, Long_I N0, Long_I N1, Long_I step1)
{
#ifdef SLS_CHECK_BOUNDS
    if (N0 <= 0 || N1 <= 0 || step1 < N1) SLS_ERR("illegal length!");
#endif
    const @T@ *p = v, *beg = v, *end = v + N1*step1, *beg0 = v, *end0 = v + N0;
    while (1) {
        if (v == end0) {
            beg0 += step1;
            if (beg0 >= end) break;
            v = beg0; end0 += step1;
        }
        if (*p @oper@ *v) p = v;
        ++v;
    }
    i = (p - beg) % N0; j = (p - beg) / step1;
    return *p;
}

//% else
//%     error(['max_v: not implemented (4): ' T]);
//% end
//%-------------------------

//% tem('max', {'VecInt'; 'VecLlong'; 'VecDoub';
//%  'SvecInt'; 'SvecLlong'; 'SvecDoub';
//%  'DcmatLlong'; 'DcmatDoub'; });
//%--------------------------
//% T = varargin{:}; Ts = val_t(T);
//% req('max_v', { 'max', Ts; 'min', Ts });
//% if is_dense(T) && is_real(Ts) && ~is_Bool(Ts)
inline @Ts@ max(@T@_I v) { return max_v(v.p(), v.size()); }

inline @Ts@ max(Long_O ind, @T@_I v) { return max_v(ind, v.p(), v.size()); }

inline @Ts@ min(@T@_I v) { return min_v(v.p(), v.size()); }

inline @Ts@ min(Long_O ind, @T@_I v) { return min_v(ind, v.p(), v.size()); }
//% elseif is_Dvec(T) && is_real(Ts) && ~is_Bool(Ts)
inline @Ts@ max(@T@_I v) { return max_v(v.p(), v.size(), v.step()); }

inline @Ts@ max(Long_O ind, @T@_I v) { return max_v(v.p(), v.size(), v.step()); }

inline @Ts@ min(@T@_I v) { return min_v(v.p(), v.size(), v.step()); }

inline @Ts@ min(Long_O ind, @T@_I v) { return min_v(v.p(), v.size(), v.step()); }
//% elseif is_Dcmat(T) && is_real(Ts) && ~is_Bool(Ts)
//% % max2 prevents name conflict with std::max
inline @Ts@ max(@T@_I v) { return max_dcmat(v.p(), v.n0(), v.n1(), v.lda()); }

inline @Ts@ max2(Long_O i, Long_O j, @T@_I v) { return max_dcmat(i, j, v.p(), v.n0(), v.n1(), v.lda()); }

inline @Ts@ min(@T@_I v) { return min_dcmat(v.p(), v.n0(), v.n1(), v.lda()); }

inline @Ts@ min2(Long_O i, Long_O j, @T@_I v) { return min_dcmat(i, j, v.p(), v.n0(), v.n1(), v.lda()); }
//% else
//%     error(['max: not implemented (5): ' T]);
//% end
//%-------------------------

// find smallest Nmin elements
template <class T>
inline void minN(vector<T> &vals, vector<Long> &inds, T *v, Long_I N, Long_I Nmin)
{
#ifdef SLS_CHECK_SHAPES
    if (N < Nmin)
        SLS_ERR("wrong shape!");
#endif
    typedef pair<T,Long> P; // (val, ind)
    vals.resize(Nmin); inds.resize(Nmin);
    priority_queue<P> q;
    for (Long i = 0; i < Nmin; ++i)
        q.push(P(v[i], i));
    for (Long i = Nmin; i < N; ++i) {
        T &val = v[i];
        if (val < q.top().first) {
            q.pop();
            q.push(P(val, i));
        }
    }
    for (Long i = 0; i < Nmin; ++i) {
        Long j = Nmin-i-1;
        vals[j] = q.top().first;
        inds[j] = q.top().second;
        q.pop();
    }
}

// find largest Nmax elements
template <class T>
inline void maxN(vector<T> &vals, vector<Long> &inds, T *v, Long_I N, Long_I Nmax)
{
#ifdef SLS_CHECK_SHAPES
    if (N < Nmax)
        SLS_ERR("wrong shape!");
#endif
    typedef pair<T,Long> P; // (val, ind)
    vals.resize(Nmax); inds.resize(Nmax);
    priority_queue<P, vector<P>, std::greater<P>> q;
    for (Long i = 0; i < Nmax; ++i)
        q.push(P(v[i], i));
    for (Long i = Nmax; i < N; ++i) {
        T &val = v[i];
        if (val > q.top().first) {
            q.pop();
            q.push(P(val, i));
        }
    }
    for (Long i = 0; i < Nmax; ++i) {
        Long j = Nmax-i-1;
        vals[j] = q.top().first;
        inds[j] = q.top().second;
        q.pop();
    }
}

//% tem('max_abs_v', { 'Doub' });
//%------------------------------
//% T = varargin{:};
//% Tr = rm_comp(T);
inline @Tr@ max_abs_v(const @T@ *v, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @Tr@ s = abs(v[0]), val;
    for (Long i = 1; i < N; ++i) {
        val = abs(v[i]);
        if (s < val)
            s = val;
    }
    return s;
}

inline @Tr@ max_abs_v(const @T@ *v, Long_I N, Long_I step)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @Tr@ s = abs(v[0]), val;
    for (Long i = step; i < N*step; i += step) {
        val = abs(v[i]);
        if (s < val)
            s = val;
    }
    return s;
}

inline @Tr@ max_abs_dcmat(const @T@ *v, Long_I N0, Long_I N1, Long_I step1)
{
#ifdef SLS_CHECK_BOUNDS
    if (N0 <= 0 || N1 <= 0 || step1 < N1) SLS_ERR("illegal length!");
#endif
    const @T@ *end = v + N1*step1, *beg0 = v, *end0 = v + N0;
    @Tr@ s = abs(*v); ++v;
    while (1) {
        if (v == end0) {
            beg0 += step1;
            if (beg0 >= end) break;
            v = beg0; end0 += step1;
        }
        const @Tr@ &t = abs(*v);
        if (s < t) s = abs(t);
        ++v;
    }
    return s;
}

inline @Tr@ max_abs_dcmat(Long_O i, Long_O j, const @T@ *v, Long_I N0, Long_I N1, Long_I step1)
{
#ifdef SLS_CHECK_BOUNDS
    if (N0 <= 0 || N1 <= 0 || step1 < N1) SLS_ERR("illegal length!");
#endif
    const @T@ *p = v, *beg = v, *end = v + N1*step1, *beg0 = v, *end0 = v + N0;
    @Tr@ s = abs(*v); ++v;
    while (1) {
        if (v == end0) {
            beg0 += step1;
            if (beg0 >= end) break;
            v = beg0; end0 += step1;
        }
        const @Tr@ &t = abs(*v);
        if (s < t) s = abs(t), p = v;
        ++v;
    }
    i = (p - beg) % N0; j = (p - beg) / step1;
    return s;
}
//%-------------------------

//% tem('max_abs', { 'VecDoub'; 'VecComp'; 'VecInt';
//%   'VecQdoub'; 'SvecComp'; 'DvecDoub'; 'DvecComp';
//%   'CmatDoub'; 'CmatComp'; 'MatComp'; 'DcmatDoub'; 'DcmatComp'; });
//%------------------------------
//% T = varargin{:}; Ts = val_t(T);
//% Tr = rm_comp(Ts);
//% req('max_abs_v', { Ts });
//% if is_dense(T)
inline @Tr@ max_abs(@T@_I v) { return max_abs_v(v.p(), v.size()); }
//% elseif is_Dvec(T)
inline @Tr@ max_abs(@T@_I v) { return max_abs_v(v.p(), v.size(), v.step()); }
//% elseif is_Dcmat(T)
inline @Tr@ max_abs(@T@_I v) { return max_abs_dcmat(v.p(), v.n0(), v.n1(), v.lda()); }
inline @Tr@ max_abs(Long_O i, Long_O j, @T@_I v) { return max_abs_dcmat(i, j, v.p(), v.n0(), v.n1(), v.lda()); }
//% else
//%     error('Not implemented!');
//% end
//%--------------------------

// sum of absolute values
//% tem('sum_abs_v', { 'Int'; 'Llong'; 'Doub'; 'Comp' });
//%--------------------------
//% T = varargin{:};
//% % decide return type
//% if is_integral(T)
//%     Tr = 'Llong';
//% elseif is_fpt(T) || is_comp(T)
//%     Tr = rm_comp(T);
//% else
//%     error('not implemented (1)!');
//% end
inline @Tr@ sum_abs_v(const @T@ *v, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @Tr@ s = abs(v[0]);
    for (Long i = 1; i < N; ++i)
        s += abs(v[i]);
    return s;
}
//%---------------------------

// sum of absolute values
//% tem('sum_abs', {'VecInt'; 'VecLlong'; 'VecDoub'; 'VecComp';
//%     'SvecInt'; 'SvecLlong'; 'SvecDoub'; 'SvecComp';
//%     'CmatInt'; 'CmatLlong'; 'CmatDoub'; 'CmatComp';
//%     'ScmatInt'; 'ScmatLlong'; 'ScmatDoub'; 'ScmatComp'; });
//%--------------------------
//% T = varargin{:}; Ts = val_t(T);
//% if is_integral(Ts)
//%     Tr = 'Llong';
//% elseif is_fpt(Ts) || is_comp(Ts)
//%     Tr = rm_comp(Ts);
//% else
//%     error(['sum_abs: not implemented (2): ' T]);
//% end
//% if is_dense(T)
//% req('sum_abs_v', {Ts});
inline @Tr@ sum_abs(@T@_I v)
{ return sum_abs_v(v.p(), v.size()); }
//% else
//%     error('sum_abs: not implemented (3)!');
//% end
//%---------------------------

//% tem('sum_abs_bool', {'VecBool'});
//%--------------------------
//% T = varargin{:};
inline Long sum_abs(@T@_I v)
{
    Long N = v.size();
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    Long s = v[0];
    for (Long i = 1; i < N; ++i)
        s += v[i];
    return s;
}
//%--------------------------

//% tem('sum_v', { 'Doub' });
//%--------------------
//% T = varargin{:};
//% if is_integral(T)
//%     Tret = 'Llong';
//% else
//%     Tret = T;
//% end
inline @Tret@ sum_v(const @T@ *v, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @Tret@ s = v[0];
    for (Long i = 1; i < N; ++i)
        s += v[i];
    return s;
}

inline @Tret@ prod_v(const @T@ *v, Long_I N)
{
#ifdef SLS_CHECK_BOUNDS
    if (N <= 0) SLS_ERR("illegal length!");
#endif
    @Tret@ s = v[0];
    for (Long i = 1; i < N; ++i)
        s *= v[i];
    return s;
}
//%------------------------

//% tem('sum', { 'VecInt'; 'VecLlong';
//%   'VecDoub'; 'VecComp'; 'CmatDoub'; 'CmatComp'; 'MatComp'; });
//%----------------
//% T = varargin{:}; Ts = val_t(T);
//% if is_integral(Ts)
//%     Tret = 'Llong';
//% else
//%     Tret = Ts;
//% end
//% req('sum_v', {Ts});
inline @Tret@ sum(@T@_I v)
{ return sum_v(v.p(), v.size()); }

inline @Tret@ prod(@T@_I v)
{ return prod_v(v.p(), v.size()); }
//%-----------------

//% tem('norm2', { 'VecDoub'; 'VecComp';
//% 'SvecDoub'; 'SvecComp'; 'DvecDoub'; 'CmatDoub'; 'CmatComp';
//% 'MatDoub'; 'MatComp';
//% 'ScmatComp'; 'DcmatComp'; 'Mat3Doub'; 'Mat3Comp'; 'Cmat3Comp'; });
//%-------------------------------
//% T = varargin{:};
//% Ts = val_t(T);
//% Tr = rm_comp(Ts);
//% if is_dense(T) || is_Dvec(T)
inline @Tr@ norm2(@T@_I v)
{
    Long N = v.size();
    @Tr@ s2 = abs2(v[0]);
    for (Long i = 1; i < N; ++i)
        s2 += abs2(v[i]);
    return s2;
}

inline @Tr@ norm2_dif(@T@_I v, @T@_I v1)
{
    Long N = v.size();
    @Tr@ s2 = abs2(v[0] - v1[0]);
    for (Long i = 1; i < N; ++i)
        s2 += abs2(v[i] - v1[i]);
    return s2;
}
//% elseif is_Dcmat(T)
inline @Tr@ norm2(@T@_I a)
{
    const @Ts@ *p = a.p();
    Long Nr = a.n0(), lda = a.lda();
    @Tr@ s2 = 0;
    for (Long j = 0; j < a.n1(); ++j) {
        for (Long i = 0; i < Nr; ++i)
            s2 += abs2(p[i]);
        p += lda;
    }
    return s2;
}

inline @Tr@ norm2_dif(@T@_I a, @T@_I a1)
{
    const @Ts@ *p = a.p(), *p1 = a1.p();
    Long Nr = a.n0(), lda = a.lda(), lda1 = a1.lda();
    @Tr@ s2 = 0;
    for (Long j = 0; j < a.n1(); ++j) {
        for (Long i = 0; i < Nr; ++i)
            s2 += abs2(p[i] - p1[i]);
        p += lda; p1 += lda1;
    }
    return s2;
}
//% else
//%     error('not implemented (6)!');
//% end
inline @Tr@ norm(@T@_I v)
{
    return sqrt(norm2(v));
}

inline @Tr@ norm_dif(@T@_I v, @T@_I v1)
{
    return sqrt(norm2_dif(v, v1));
}
//%-------------------------
} // namespace slisc
