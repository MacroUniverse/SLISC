// lanczos algorithm to propagate wave function by exp(-iH dt)
// for error estimation, see 4.51 of Johannes Feist's thesis: prod(beta) * (dt^Nk / Nk!)
// however, (dt^Nk / Nk!) is extremely small and omitted.

#pragma once
#include "../global.h"
#ifdef SLS_USE_LAPACKE
#include "../dense/cut.h"
#include "../sparse/sparse_arith.h"
#include "../sparse/band_arith.h"
#include "../lin/mul.h"
#include "../dense/WorkSpace.h"

namespace slisc {

// bytes of workspace required
inline Long exp_Hdt_v_lanc_Comp_Nwsp(Long_I N, Long_I Nk) {
	return sizeof(Doub)*((2*N+Nk)*(Nk+1)+Nk)+4*(SLS_WSP_ALIGN-1);
}

// calculate y = exp(H*dt) * x
// x, y can be the same object
// mul_fun(y, x) performs y = H*x, where H is a hermitian matrix
// return error
//% tem('exp_Hdt_v_lanc', {
//%   'SvbaseComp'; 'SvbaseQcomp';
//%   'DvecComp'; 'DvecQcomp';
//% });
//%-------------------------------
//% Tv = varargin{:};
//% Tc = val_t(Tv);
//% Tr = rm_comp(Tc);
// required workspace: sizeof(@Tr@)*((2*N+Nk)*(Nk+1)+Nk)+4*align
template <class Tmul>
inline @Tr@ exp_Hdt_v_lanc(@Tv@_O y, Tmul &mul_fun, @Tv@_I x, @Tr@_I dt, Long_I Nkrylov, WorkSpace &wsp)
{
	Long N = x.size(), Nk = Nkrylov;
#ifdef SLS_CHECK_SHAPES
	if (Nk > N) SLS_ERR("Nk > N !");
#endif
	auto alpha = wsp.Svec@Tr@(Nk); // alpha[i] = <v_i|H|v_i>
	auto beta = wsp.Svec@Tr@(Nk); // beta[i] = norm(bar v_i)
	auto eigV = wsp.Scmat@Tr@(Nk, Nk); // eigen vectors
	auto vc = wsp.Svec@Tc@(N); // temp vec
	auto bases = wsp.Scmat@Tc@(N, Nk); // Krylov bases

//% req('cut0', { ['Scmat' Tc] });
	Svec@Tc@ v0 = cut0(bases, 0), v1 = cut0(bases, 1), v2 = cut0(bases, 2);
//% req('norm2', {base_t(Tv)});
	beta[0] = norm(x);
	if (beta[0] == 0) {
		if (y.p() == x.p()) copy(y, 0);
		return 0;
	}
	times(v0, x, 1/beta[0]); 

	mul_fun(vc, v0);
//% req('dot', { ['Svbase' Tc] ['Svbase' Tc] });
	alpha[0] = real(dot(v0, vc));
	for (Long i = 0; i < N; ++i)
		v1[i] = vc[i] - alpha[0] * v0[i];
	beta[1] = norm(v1);
	if (beta[1] == 0) { // H*x is an exact eigen state of x
		// do y = exp(eigval*dt)*x
		Long ind;
		max_abs(ind, vc);
		Doub eigval = real(vc[ind] / v0[ind]);
		times(y, x, exp(eigval*dt));
	}
	v1 /= beta[1];
	mul_fun(vc, v1);
	alpha[1] = real(dot(v1, vc));

	for (Long j = 0; j < Nk-2; ++j) {
		Long j1 = j+1, j2 = j+2;
		mul_fun(v2, v1);
		@Tr@ a = alpha[j1], b = beta[j1];
		for (Long i = 0; i < N; ++i)
//% req('v+=s', { ['Svec' Tc] Tc; ['Svec' Tc] Tr});
			v2[i] -= a * v1[i] + b * v0[i];
		beta[j2] = norm(v2);
#ifndef NDEBUG
		if (beta[j2] == 0)
			SLS_ERR("exp_Hdt_v_lanc(): input H^" + num2str(j2) + "*x is linearly dependent!");
#endif
		v2 /= beta[j2];
		mul_fun(vc, v2);
		alpha[j2] = real(dot(v2, vc));
		v0.next(); v1.next(); v2.next();
	}
//% req('sum', { ['Svbase' Tr] });
	@Tr@ err = prod(beta);

//% if is_Doub(Tr)
	lapack_int info =
		LAPACKE_dstev(LAPACK_COL_MAJOR, 'V', Nk, alpha.p(), beta.p()+1, eigV.p(), Nk);
	// alpha is now eigen values
	if (info != 0) SLS_ERR("something wrong with LAPACKE_dstev: return = " + num2str(info));
//% elseif is_Qdoub(Tr)
#ifdef SLS_USE_MPLAPACK
	mplapackint info;
	Rstev("V", Nk, alpha.p(), beta.p()+1, eigV.p(), Nk, wsp.pQdoub(Nk), info);
	if (info != 0) SLS_ERR("something wrong with Rstev: return = " + num2str((Long)info));
#else
	SLS_ERR("MPLAPACK is turned off!");
#endif
//% end
	
	for (Long i = 0; i < Nk; ++i)
		alpha[i] = exp(alpha[i] * dt) * eigV[i*Nk] * beta[0];
	// alpha, beta are just work spaces now
//% req('mul_gen', { ['Svec' Tr] ['Scmat' Tr] ['Svec' Tr]});
	mul_gen(beta, eigV, alpha);
//% req('mul(v,m,v)', {Tv ['Scmat' Tc] ['Svec' Tr]});
	mul(y, bases, beta);

	return err;
}
//%-------------------------------

// bytes of workspace required
inline Long exp_miHdt_v_lanc_Comp_Nwsp(Long_I N, Long_I Nk) {
	return sizeof(Doub)*((2*N+Nk)*(Nk+1)+3*Nk)+5*(SLS_WSP_ALIGN-1);
}

// calculate y = exp(-i*H*dt) * x
// x, y can be the same object
// mul_fun(y, x) performs y = H*x, where H is a hermitian matrix
// return error
//% tem('exp_miHdt_v_lanc', {
//%   'SvbaseComp'; 'SvbaseQcomp';
//%   'DvecComp'; 'DvecQcomp';
//% });
//%-------------------------------
//% Tv = varargin{:};
//% Tc = val_t(Tv);
//% Tr = rm_comp(Tc);
// required workspace: sizeof(@Tr@)*((2*N+Nk)*(Nk+1)+3*Nk)+5*align
template <class Tmul>
inline @Tr@ exp_miHdt_v_lanc(@Tv@_IO y, Tmul &mul_fun, @Tv@_I x, @Tr@_I dt, Long_I Nkrylov, WorkSpace &wsp)
{
	Long N = x.size(), Nk = Nkrylov;
#ifdef SLS_CHECK_SHAPES
	if (Nk > N)
		SLS_ERR("Nk > N !");
#endif

	auto alpha = wsp.Svec@Tr@(Nk); // alpha[i] = <v_i|H|v_i> // eq_Lanc_31
	auto beta = wsp.Svec@Tr@(Nk); // beta[i] = norm(bar v_i) // eq_Lanc_13
	auto eigV = wsp.Scmat@Tr@(Nk, Nk); // eigen vectors
	
	auto vc = wsp.Svec@Tc@(N); // temp vec
	auto vc1 = wsp.Svec@Tc@(Nk); // temp vec
	auto bases = wsp.Scmat@Tc@(N, Nk); // orthonormal Krylov bases eq_Lanc_7
//% req('cut0', { ['Scmat' Tc] });
	Svec@Tc@ v0 = cut0(bases, 0), v1 = cut0(bases, 1), v2 = cut0(bases, 2);
//% req('norm2', {base_t(Tv)});
	beta[0] = norm(x);
	if (beta[0] == 0) {
		if (y.p() == x.p()) copy(y, 0);
		return 0;
	}
//% req('add(v,v,s)', {['Svec' Tc] Tv Tr});
	times(v0, x, 1/beta[0]);
	mul_fun(vc, v0);
//% req('dot', {['Svbase' Tc] ['Svbase' Tc]});
	alpha[0] = real(dot(v0, vc));
	for (Long i = 0; i < N; ++i)
		v1[i] = vc[i] - alpha[0] * v0[i];
//% req('norm2', { ['Svbase' Tc] });
	beta[1] = norm(v1);
	if (beta[1] == 0) { // H*x is an exact eigen state of x
		// do y = exp(-i*eigval*dt)*x
		Long ind;
		max_abs(ind, vc);
		Doub eigval = real(vc[ind] / v0[ind]);
		times(y, x, exp(Comp(0, -eigval*dt)));
	}
	v1 /= beta[1];
	mul_fun(vc, v1);
	alpha[1] = real(dot(v1, vc));

	for (Long j = 0; j < Nk-2; ++j) {
		Long j1 = j+1, j2 = j+2;
		mul_fun(v2, v1);
		@Tr@ a = alpha[j1], b = beta[j1];
		for (Long i = 0; i < N; ++i)
//% req('v+=s', {['Svec' Tc] Tc; ['Svec' Tc] Tr});
		v2[i] -= a * v1[i] + b * v0[i];
		beta[j2] = norm(v2);
#ifndef NDEBUG
		if (beta[j2] == 0)
			SLS_ERR("exp_miHdt_v_lanc(): H^" + num2str(j2) + "*x is linearly dependent!");
#endif
		v2 /= beta[j2];
		mul_fun(vc, v2);
		alpha[j2] = real(dot(v2, vc));
		v0.next(); v1.next(); v2.next();
	}
//% req('sum', { ['Svbase' Tr] });
	@Tr@ err = prod(beta);
//% if is_Doub(Tr)
	lapack_int info =
	LAPACKE_dstev(LAPACK_COL_MAJOR, 'V', Nk, alpha.p(), beta.p()+1, eigV.p(), Nk);
	// alpha is now eigen values
	if (info != 0)
		SLS_ERR("something wrong with LAPACKE_dstev: return = " + num2str(info));
//% elseif is_Qdoub(Tr)
#ifdef SLS_USE_MPLAPACK
	mplapackint info;
	// alpha is now eigen values
	Rstev("V", Nk, alpha.p(), beta.p()+1, eigV.p(), Nk, wsp.pQdoub(Nk), info);
	if (info != 0)
		SLS_ERR("something wrong with Rstev: return = " + num2str((Long)info));
#else
	SLS_ERR("MPLAPACK is turned off!");
#endif
//% end
//% req('cut', { ['Svec' Tc] });
	Svec@Tc@ vc2 = cut(vc, 0, Nk);
	for (Long i = 0; i < Nk; ++i)
		vc2[i] = exp(@Tc@(0,-1) * (alpha[i] * dt)) * eigV[i*Nk] * beta[0];
//% req('mul_gen', { ['Svec' Tc] ['Scmat' Tr] ['Svec' Tc]; Tv ['Scmat' Tc] ['Svec' Tc]});
	mul_gen(vc1, eigV, vc2);
	mul_gen(y, bases, vc1);
	return err;
}
//%-----------------------

} // namespace slisc

#endif
