// delete a table (or sub table satisfying a condition) and insert new records are slow, when there are lots of unchanged records
// this is a optimized version

#include "../str/str.h"
#include "../util/STL_util.h"

#include <SQLiteCpp/Statement.h>
#include <SQLiteCpp/Database.h>
#include <SQLiteCpp/Transaction.h>

namespace slisc {

// helper for update_sqlite_table()
inline tuple<SQLite::Statement,SQLite::Statement,SQLite::Statement,SQLite::Statement>
	update_sqlite_table_stmt(
		Str_I table_name, Str_I condition, vecStr_I field_names, Long_I Npk,
		SQLite::Database &db_rw
) {
	// SELECT statement
	Str tmp = "SELECT ";
	for (auto &field : field_names)
		tmp << field << ", ";
	tmp.resize(tmp.size()-2);
	tmp << " FROM " << table_name;
	if (!condition.empty())
		tmp << " WHERE " << condition;
	SQLite::Statement stmt_select(db_rw, tmp);

	// INSERT statement
	clear(tmp) << "INSERT INTO " << table_name << '(';
	for (auto &field : field_names)
		tmp << field << ", ";
	tmp.resize(tmp.size()-2);
	tmp << ") VALUES (";
	for (Long i = 0; i < size(field_names); ++i)
		tmp << "?, ";
	tmp.resize(tmp.size()-3);
	tmp << ");";
	SQLite::Statement stmt_insert(db_rw, tmp);

	// UPDATE statement
	clear(tmp) << "UPDATE " << table_name << " SET ";
	for (auto &field : field_names)
		tmp << field << "=?, ";
	tmp.resize(tmp.size()-2);
	tmp << ';';
	SQLite::Statement stmt_update(db_rw, tmp);

	// DELETE statement
	clear(tmp) << "DELETE FROM " << table << " WHERE ";
	for (Long i = 0; i < Npk; ++i)
		tmp << field_names[i] << "=? AND ";
	tmp.resize(tmp.size()-5);
	SQLite::Statement stmt_delete(db_rw, tmp);

	return make_tuple(stmt_select, stmt_insert, stmt_update, stmt_delete);
}

//% tem('update_sqlite_table', {
//%   'Str' 'Long,Str,Str,Str'
//% });
//%--------------------
//% [TpkS, TvalS] = varargin{:};
//% Tpk = strsplit(TpkS, ',');
//% Tval = strsplit(TvalS, ',');
//% Npk = numel(Tpk); Nval = numel(Tval);
// sync `data` to a db table, perform DELETE and UPDATE as needed, unchanged records won't be touched
// only record in db satisfying `condition` will be checked
// assume `data` satisfy `condition` (no check)
inline void update_sqlite_table(
	const unordered_map<tuple<@TpkS@>, tuple<@TvalS@>> &data, // (primary keys) -> (other fields)
	Str_I table_name,
	Str_I condition, // the SQL statement after "WHERE"s
	vecStr_I field_names, // field names of `data`, in order
	Long_I Npk, // number of primary keys
	SQLite::Database &db_rw
) {
	auto ret = update_sqlite_table_stmt(table_name, condition, field_names, Npk, db_rw);
	auto &stmt_select = get<0>(ret);
	auto &stmt_insert = get<1>(ret);
	auto &stmt_update = get<2>(ret);
	auto &stmt_delete = get<3>(ret);

	while (stmt_select.executeStep()) {
		auto key = make_tuple(
//% for j = 0:Npk-2
//%     tmp = '';
//%     if strcmp(Tpk{j+1}, 'Str')
//%         tmp = '.getString()';
//%     end
			(@Tpk{j+1}@)stmt_select.getColumn(@j@)@tmp@,
//% end
//%     tmp = '';
//%     if strcmp(Tpk{Npk}, 'Str')
//%         tmp = '.getString()';
//%     end
			(@Tpk{Npk}@)stmt_select.getColumn(@Npk-1@)@tmp@
		);
		if (!data.count(key)) {
			// key not found, deleted
//% for j = 0:Npk-1
			stmt_delete.bind(@j+1@, get<@j@>(key));
//% end
			stmt_delete.exec(); stmt_delete.reset();
			continue;
		}
		// check for change
		bool changed = false;
		auto &vals = data.at(key);
//% for j = 0:Nval-1
//%     tmp = '';
//%     if strcmp(Tval{j+1}, 'Str')
//%         tmp = '.getString()';
//%     end
		if (!changed && get<@j@>(vals) != (@Tval{j+1}@)stmt_select.getColumn(@j@)@tmp@)
			changed = true;
//% end
		if (changed) {
			// update db record
//% for j = 0:Nval-1
			stmt_update.bind(@j+1@, get<@j@>(vals));
//% end
//% for j = 0:Npk-1
			stmt_update.bind(@Npk+j@, get<@j@>(key));
//% end
			stmt_update.exec(); stmt_update.reset();
		}
	}
}
//%--------------------

} // namespace
