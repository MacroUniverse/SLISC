// delete a table (or sub table satisfying a condition) and insert new records are slow, when there are lots of unchanged records
// this is a optimized version

#include "../str/str.h"
#include "../util/STL_util.h"

namespace slisc {

// similar to std::hash, for pair<T,T1> as key

inline size_t operator()(const vector<const void *> &v,
		const vector<char> &types // type for each column, 'i' is int, 's' is string
	) const {
		size_t h = 0;
		for (Long i = 0; i < size(data); ++i) {
			if (types[i] == 'i')
				hash_combine(h, *(*int)v[i]);
			else if (types[i] == 's')
				hash_combine(h, *(*Str)v[i]);
		}
		return h;
	}
};

//% tem('update_sqlite_table', {
//%     1 'Str' 'Long' 'Str' 'Str' 'Long'; // 'part'
//%	});
//%--------------------
//% TT = varargin{:};
//% Npk = TT{1};
//% Tlist1 = ''; Tlist2 = '';
//% for i = 1:Npk
//%     Tlist1 = [Tlist1 ',' TT(i+1)]
//% end
//% for i = Npk+1:numel(TT)
//%     Tlist2 = [Tlist2 ',' TT(i+1)]
//% end
inline void update_sqlite_table(
	Str_I table_name,
	vecStr_I field_names, // field names of `data`s
	Str_I condition, // the SQL statement after "WHERE"s
	vecLong_I primary_keys, // which columns of `data` are primary keys
	unordered_map<tuple<@Tlist1@>, tuple<@Tlist2@>> data, // new records
	// assuming `data` doesn't have repeated primary keys
	// assuming `data` satisfy `condition`
	SQLite::Database &db_rw
) {
	Str tmp;
	
	// SELECT statement
	tmp = "SELECT ";
	for (auto &field : field_names)
		tmp << field << ", ";
	tmp.resize(tmp.size()-2);
	tmp << " FROM " << table_name << " WHERE " << condition;
	SQLite::Statement stmt_select0(db_rw, tmp);

	// INSERT statement
	clear(tmp) << "INSERT INTO " << table_name << '(';
	for (auto &field : field_names)
		tmp << field << ", ";
	tmp.resize(tmp.size()-2);
	tmp << ") VALUES (";
	for (Long i = 0; i < size(field_names); ++i)
		tmp << "?, ";
	tmp.resize(tmp.size()-3);
	tmp << ");";
	SQLite::Statement stmt_insert(db_rw, tmp);

	// UPDATE statement
	clear(tmp) << "UPDATE " << table_name << " SET ";
	for (auto &field : field_names)
		tmp << field << "=?, ";
	tmp.resize(tmp.size()-2);
	tmp << ';';
	SQLite::Statement stmt_update(db_rw, tmp);

	// DELETE statement
	clear(tmp) << "DELETE FROM " << table << " WHERE ";
	for (Long i : primary_keys)
		tmp << field_names[i] << "=? AND ";
	tmp.resize(tmp.size()-5);
	SQLite::Statement stmt_delete(db_rw, tmp);

	// delete record
	while (stmt_select.executeStep()) {
		for (Long j = 0; j < size(field_names); ++j) {
			stmt_select.getColumn(j);
		}
		deleted.push_back(make_tuple(, 
			stmt_select.getColumn(primary_key2_ind)))
	}

	while (stmt_select0.execStep()) {
		auto key = make_tuple(
//% for j = 1:Npk-1
			(@Tlist1(j)@)stmt_select0.getColumn(@j-1@),
//% end
			(@Tlist1(Npk-1)@)stmt_select0.getColumn(@Npk-1@);
		);
		if (!data.count(key)) {
			// key not found, deleted
//% for j = 1:Npk-1
			stmt_delete.bind(@j@, get<@j@>(key));
//% end
			stmt_delete.exec(); stmt_delete.reset();
			continue;
		}
		// check for change

	}
}

} // namespace
