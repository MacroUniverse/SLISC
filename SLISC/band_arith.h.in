#pragma once
#include "arithmetic.h"
#include "slice_arith.h"
#include "Cband.h"

namespace slisc {

// conversion between full matrix and band diagonal matrix
// Nup and Nlow are the number of upper diagonals and lower diagonals
// ref: cBLAS gbmv() routine
// https://software.intel.com/en-us/node/834918#DAEC7CD0-620A-4696-9612-C295F8211646

// slice the non-zero band
//% types = {
//%     'Doub'; 'Comp';
//% };
//%------------------------------
//% T = varargin{:};
//% CbandT = ['Cband' T]; DcmatT = ['Dcmat' T];
inline @DcmatT@ band(@CbandT@_IO a)
{
    return @DcmatT@(&a.cmat()[a.idiag() - a.nup()], a.nup() + a.nlow() + 1, a.n2(), a.lda());
}

inline @DcmatT@_c band(@CbandT@_I a)
{
    return @DcmatT@_c(&a.cmat()[a.idiag() - a.nup()], a.nup() + a.nlow() + 1, a.n2(), a.lda());
}
//%------------------------------

// detect band width of dense matrix
// a(i,j) < tol is considered 0
//% types = {
//%     'CmatDoub'; 'CmatComp'; 'ScmatDoub'; 'ScmatComp';
//% };
//%----------------
//% Tmat = varargin{:}; Ttol = rm_comp(contain_type(Tmat));
inline void nband(Long_O Nup, Long_O Nlow, @Tmat@_I a, @Ttol@_I tol = 0)
{
    Bool found = false;
    // check upper diagonals
    for (Long k = a.n2() - 1; k > 0 && !found; --k) {
        Long i = 0;
        for (Long j = k; j < a.n2() && !found; ++j) {
            if (i > a.n1()) break;
            if (abs(a(i, j)) > tol)  {
                Nup = k; found = true;
            }
            ++i;
        }
    }
    
    // check lower diagonals
    found = false;
	for (Long k = a.n1() - 1; k > 0  && !found; --k) {
        Long j = 0;
        for (Long i = k; i < a.n1() && !found; ++i) {
            if (j > a.n2()) break;
            if (abs(a(i, j)) > tol) {
                Nlow = k; found = true;
            }
            ++j;
        }
	}
}
//%----------------

// matrix-vector multiplication for band matrix
#ifdef SLS_USE_CBLAS
//% types = {
//%     'VecDoub' 'CbandDoub' 'VecDoub';
//%     'VecComp' 'CbandComp' 'VecComp';
//%     'VecComp' 'CbandComp' 'SvecComp';
//% };
//%------------------
//% [Ty, Ta, Tx] = varargin{:};
//% Tsx = contain_type(Tx); Tsy = contain_type(Ty);
//% Tsa = contain_type(Ta);
inline void mul(@Ty@_O y, @Ta@_I a, @Tx@_I x)
{
//% if is_dense_vec(Tx)
    Long incx = 1;
//% elseif is_Dvec(Tx)
	Long incx = x.step();
//% end
//% if is_dense_vec(Ty)
    Long incy = 1;
//% elseif is_Dvec(Ty)
	Long incy = x.step();
//% end
//% if is_Doub(Tsx) && is_Doub(Tsa) && is_Doub(Tsy)
	Doub alpha = 1, beta = 0;
    cblas_dgbmv(CblasColMajor, CblasNoTrans, a.n1(), a.n2(), a.nlow(), a.nup(),
        alpha, a.ptr() + a.idiag() - a.nup(), a.lda(), x.ptr(), incx, beta, y.ptr(), incy);
//% elseif is_Comp(Tsx) && is_Comp(Tsa) && is_Comp(Tsy)
	Comp alpha(1, 0), beta(0, 0);
    cblas_zgbmv(CblasColMajor, CblasNoTrans, a.n1(), a.n2(), a.nlow(), a.nup(),
        &alpha, a.ptr() + a.idiag() - a.nup(), a.lda(), x.ptr(), incx, &beta, y.ptr(), incy);
//% else
//%     error('not implemented!');
//% end
}
//%----------------------
#endif

} // namespace slisc
